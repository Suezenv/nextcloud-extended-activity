const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=[window.OC.filePath('extended_activity', '', 'js/index-BCb9v7K0.chunk.mjs'),window.OC.filePath('extended_activity', '', 'js/_commonjsHelpers-s2JqeXRS.chunk.mjs'),window.OC.filePath('extended_activity', '', 'js/translation-CD_FiYBO-CK2BqXfP.chunk.mjs'),window.OC.filePath('extended_activity', '', 'js/index-BJ7ydZxs.chunk.mjs'),window.OC.filePath('extended_activity', '', 'js/index-KfUaQuGs.chunk.mjs'),window.OC.filePath('extended_activity', '', 'js/NcCheckboxRadioSwitch-Ca1ouh22-BmLj0R_Y.chunk.mjs'),window.OC.filePath('extended_activity', '', 'js/preload-helper-C0h9nzpy.chunk.mjs'),window.OC.filePath('extended_activity', '', 'js/public-BbQmCZDA.chunk.mjs'),window.OC.filePath('extended_activity', '', 'js/logger-27ZxKlei.chunk.mjs')])))=>i.map(i=>d[i]);
(function() {
  "use strict";
  try {
    if (typeof document != "undefined") {
      var elementStyle = document.createElement("style");
      elementStyle.appendChild(document.createTextNode('@charset "UTF-8";/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-697cfd8f] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n.empty-content[data-v-697cfd8f] {\n  display: flex;\n  align-items: center;\n  flex-direction: column;\n  justify-content: center;\n  /* In case of using in a flex container - flex in advance */\n  flex-grow: 1;\n  padding: var(--default-grid-baseline);\n}\n.modal-wrapper .empty-content[data-v-697cfd8f] {\n  margin-top: 5vh;\n  margin-bottom: 5vh;\n}\n.empty-content__icon[data-v-697cfd8f] {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 64px;\n  height: 64px;\n  margin: 0 auto 15px;\n  opacity: 0.4;\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: 64px;\n}\n.empty-content__icon[data-v-697cfd8f] svg {\n  width: 64px !important;\n  height: 64px !important;\n  max-width: 64px !important;\n  max-height: 64px !important;\n}\n.empty-content__name[data-v-697cfd8f] {\n  margin-bottom: 10px;\n  text-align: center;\n  font-weight: bold;\n  font-size: 20px;\n  line-height: 30px;\n}\n.empty-content__description[data-v-697cfd8f] {\n  color: var(--color-text-maxcontrast);\n  text-align: center;\n  text-wrap-style: balance;\n}\n.empty-content__action[data-v-697cfd8f] {\n  margin-top: 8px;\n}\n.modal-wrapper .empty-content__action[data-v-697cfd8f] {\n  margin-top: 20px;\n  display: flex;\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-af2d3203] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n.avatardiv[data-v-af2d3203] {\n  position: relative;\n  display: inline-block;\n  width: var(--size);\n  height: var(--size);\n}\n.avatardiv--unknown[data-v-af2d3203] {\n  position: relative;\n  background-color: var(--color-main-background);\n  white-space: normal;\n}\n.avatardiv[data-v-af2d3203]:not(.avatardiv--unknown) {\n  background-color: var(--color-main-background) !important;\n  box-shadow: 0 0 5px rgba(0, 0, 0, 0.05) inset;\n}\n.avatardiv--with-menu[data-v-af2d3203] {\n  cursor: pointer;\n}\n.avatardiv--with-menu .action-item[data-v-af2d3203] {\n  position: absolute;\n  top: 0;\n  inset-inline-start: 0;\n}\n.avatardiv--with-menu[data-v-af2d3203] .action-item__menutoggle {\n  cursor: pointer;\n  opacity: 0;\n}\n.avatardiv--with-menu[data-v-af2d3203]:focus-within .action-item__menutoggle, .avatardiv--with-menu[data-v-af2d3203]:hover .action-item__menutoggle, .avatardiv--with-menu.avatardiv--with-menu-loading[data-v-af2d3203] .action-item__menutoggle {\n  opacity: 1;\n}\n.avatardiv--with-menu:focus-within img[data-v-af2d3203], .avatardiv--with-menu:hover img[data-v-af2d3203], .avatardiv--with-menu.avatardiv--with-menu-loading img[data-v-af2d3203] {\n  opacity: 0.3;\n}\n.avatardiv--with-menu[data-v-af2d3203] .action-item__menutoggle,\n.avatardiv--with-menu img[data-v-af2d3203] {\n  transition: opacity var(--animation-quick);\n}\n.avatardiv--with-menu[data-v-af2d3203]  .button-vue,\n.avatardiv--with-menu[data-v-af2d3203]  .button-vue__icon {\n  height: var(--size);\n  min-height: var(--size);\n  width: var(--size) !important;\n  min-width: var(--size);\n}\n.avatardiv--with-menu[data-v-af2d3203] >  .button-vue, .avatardiv--with-menu[data-v-af2d3203] >  .action-item .button-vue {\n  --button-radius: calc(var(--size) / 2);\n}\n.avatardiv .avatardiv__initials-wrapper[data-v-af2d3203] {\n  display: block;\n  height: var(--size);\n  width: var(--size);\n  background-color: var(--color-main-background);\n  border-radius: calc(var(--size) / 2);\n}\n.avatardiv .avatardiv__initials-wrapper .avatardiv__initials[data-v-af2d3203] {\n  position: absolute;\n  top: 0;\n  inset-inline-start: 0;\n  display: block;\n  width: 100%;\n  text-align: center;\n  font-weight: normal;\n}\n.avatardiv img[data-v-af2d3203] {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n.avatardiv .material-design-icon[data-v-af2d3203] {\n  width: var(--size);\n  height: var(--size);\n}\n.avatardiv .avatardiv__user-status[data-v-af2d3203] {\n  box-sizing: border-box;\n  position: absolute;\n  inset-inline-end: -4px;\n  bottom: -4px;\n  min-height: 14px;\n  min-width: 14px;\n  max-height: 18px;\n  max-width: 18px;\n  height: 40%;\n  width: 40%;\n  line-height: 1;\n  font-size: clamp(var(--font-size-small, 13px), 85%, var(--default-font-size));\n  border: 2px solid var(--color-main-background);\n  background-color: var(--color-main-background);\n  background-repeat: no-repeat;\n  background-size: 16px;\n  background-position: center;\n  border-radius: 50%;\n}\n.acli:hover .avatardiv .avatardiv__user-status[data-v-af2d3203] {\n  border-color: var(--color-background-hover);\n  background-color: var(--color-background-hover);\n}\n.acli.active .avatardiv .avatardiv__user-status[data-v-af2d3203] {\n  border-color: var(--color-primary-element-light);\n  background-color: var(--color-primary-element-light);\n}\n.avatardiv .avatardiv__user-status--icon[data-v-af2d3203] {\n  border: none;\n  background-color: transparent;\n}\n.avatardiv .popovermenu-wrapper[data-v-af2d3203] {\n  position: relative;\n  display: inline-block;\n}\n.avatar-class-icon[data-v-af2d3203] {\n  display: block;\n  border-radius: calc(var(--size) / 2);\n  background-color: var(--color-background-darker);\n  height: 100%;\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-786624ec] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n\n/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nli.action[data-v-786624ec]:hover, li.action.active[data-v-786624ec] {\n  border-radius: 6px;\n  padding: 0;\n}\nli.action[data-v-786624ec]:hover {\n  background-color: var(--color-background-hover);\n}\n.action-link[data-v-786624ec] {\n  display: flex;\n  align-items: flex-start;\n  width: 100%;\n  height: auto;\n  margin: 0;\n  padding: 0;\n  padding-inline-end: calc((var(--default-clickable-area) - 16px) / 2);\n  box-sizing: border-box;\n  cursor: pointer;\n  white-space: nowrap;\n  color: var(--color-main-text);\n  border: 0;\n  border-radius: 0;\n  background-color: transparent;\n  box-shadow: none;\n  font-weight: normal;\n  font-size: var(--default-font-size);\n  line-height: var(--default-clickable-area);\n}\n.action-link > span[data-v-786624ec] {\n  cursor: pointer;\n  white-space: nowrap;\n}\n.action-link__icon[data-v-786624ec] {\n  width: var(--default-clickable-area);\n  height: var(--default-clickable-area);\n  opacity: 1;\n  background-position: calc((var(--default-clickable-area) - 16px) / 2) center;\n  background-size: 16px;\n  background-repeat: no-repeat;\n}\n.action-link[data-v-786624ec] .material-design-icon {\n  width: var(--default-clickable-area);\n  height: var(--default-clickable-area);\n  opacity: 1;\n}\n.action-link[data-v-786624ec] .material-design-icon .material-design-icon__svg {\n  vertical-align: middle;\n}\n.action-link__longtext-wrapper[data-v-786624ec], .action-link__longtext[data-v-786624ec] {\n  max-width: 220px;\n  line-height: 1.6em;\n  padding: calc((var(--default-clickable-area) - 1.6em) / 2) 0;\n  cursor: pointer;\n  text-align: start;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.action-link__longtext[data-v-786624ec] {\n  cursor: pointer;\n  white-space: pre-wrap !important;\n}\n.action-link__name[data-v-786624ec] {\n  font-weight: bold;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n  max-width: 100%;\n  display: block;\n}\n.action-link__description[data-v-786624ec] {\n  display: block;\n  white-space: pre-wrap;\n  font-size: var(--font-size-small);\n  line-height: var(--default-line-height);\n  color: var(--color-text-maxcontrast);\n  cursor: pointer;\n}\n.action-link__menu-icon[data-v-786624ec] {\n  margin-inline: auto calc((var(--default-clickable-area) - 16px) / 2 * -1);\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-d4dc7cdf] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n\n/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nli.action[data-v-d4dc7cdf]:hover, li.action.active[data-v-d4dc7cdf] {\n  border-radius: 6px;\n  padding: 0;\n}\nli.action[data-v-d4dc7cdf]:hover {\n  background-color: var(--color-background-hover);\n}\n.action-router[data-v-d4dc7cdf] {\n  display: flex;\n  align-items: flex-start;\n  width: 100%;\n  height: auto;\n  margin: 0;\n  padding: 0;\n  padding-inline-end: calc((var(--default-clickable-area) - 16px) / 2);\n  box-sizing: border-box;\n  cursor: pointer;\n  white-space: nowrap;\n  color: var(--color-main-text);\n  border: 0;\n  border-radius: 0;\n  background-color: transparent;\n  box-shadow: none;\n  font-weight: normal;\n  font-size: var(--default-font-size);\n  line-height: var(--default-clickable-area);\n}\n.action-router > span[data-v-d4dc7cdf] {\n  cursor: pointer;\n  white-space: nowrap;\n}\n.action-router__icon[data-v-d4dc7cdf] {\n  width: var(--default-clickable-area);\n  height: var(--default-clickable-area);\n  opacity: 1;\n  background-position: calc((var(--default-clickable-area) - 16px) / 2) center;\n  background-size: 16px;\n  background-repeat: no-repeat;\n}\n.action-router[data-v-d4dc7cdf] .material-design-icon {\n  width: var(--default-clickable-area);\n  height: var(--default-clickable-area);\n  opacity: 1;\n}\n.action-router[data-v-d4dc7cdf] .material-design-icon .material-design-icon__svg {\n  vertical-align: middle;\n}\n.action-router__longtext-wrapper[data-v-d4dc7cdf], .action-router__longtext[data-v-d4dc7cdf] {\n  max-width: 220px;\n  line-height: 1.6em;\n  padding: calc((var(--default-clickable-area) - 1.6em) / 2) 0;\n  cursor: pointer;\n  text-align: start;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.action-router__longtext[data-v-d4dc7cdf] {\n  cursor: pointer;\n  white-space: pre-wrap !important;\n}\n.action-router__name[data-v-d4dc7cdf] {\n  font-weight: bold;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n  max-width: 100%;\n  display: block;\n}\n.action-router__description[data-v-d4dc7cdf] {\n  display: block;\n  white-space: pre-wrap;\n  font-size: var(--font-size-small);\n  line-height: var(--default-line-height);\n  color: var(--color-text-maxcontrast);\n  cursor: pointer;\n}\n.action-router__menu-icon[data-v-d4dc7cdf] {\n  margin-inline: auto calc((var(--default-clickable-area) - 16px) / 2 * -1);\n}\n.action--disabled[data-v-d4dc7cdf] {\n  pointer-events: none;\n  opacity: 0.5;\n}\n.action--disabled[data-v-d4dc7cdf]:hover, .action--disabled[data-v-d4dc7cdf]:focus {\n  cursor: default;\n  opacity: 0.5;\n}\n.action--disabled[data-v-d4dc7cdf] * {\n  opacity: 1 !important;\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-a8e61e98] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n\n/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nli.action[data-v-a8e61e98]:hover, li.action.active[data-v-a8e61e98] {\n  border-radius: 6px;\n  padding: 0;\n}\nli.action[data-v-a8e61e98]:hover {\n  background-color: var(--color-background-hover);\n}\n.action-text[data-v-a8e61e98] {\n  display: flex;\n  align-items: flex-start;\n  width: 100%;\n  height: auto;\n  margin: 0;\n  padding: 0;\n  padding-inline-end: calc((var(--default-clickable-area) - 16px) / 2);\n  box-sizing: border-box;\n  cursor: pointer;\n  white-space: nowrap;\n  color: var(--color-main-text);\n  border: 0;\n  border-radius: 0;\n  background-color: transparent;\n  box-shadow: none;\n  font-weight: normal;\n  font-size: var(--default-font-size);\n  line-height: var(--default-clickable-area);\n}\n.action-text > span[data-v-a8e61e98] {\n  cursor: pointer;\n  white-space: nowrap;\n}\n.action-text__icon[data-v-a8e61e98] {\n  width: var(--default-clickable-area);\n  height: var(--default-clickable-area);\n  opacity: 1;\n  background-position: calc((var(--default-clickable-area) - 16px) / 2) center;\n  background-size: 16px;\n  background-repeat: no-repeat;\n}\n.action-text[data-v-a8e61e98] .material-design-icon {\n  width: var(--default-clickable-area);\n  height: var(--default-clickable-area);\n  opacity: 1;\n}\n.action-text[data-v-a8e61e98] .material-design-icon .material-design-icon__svg {\n  vertical-align: middle;\n}\n.action-text__longtext-wrapper[data-v-a8e61e98], .action-text__longtext[data-v-a8e61e98] {\n  max-width: 220px;\n  line-height: 1.6em;\n  padding: calc((var(--default-clickable-area) - 1.6em) / 2) 0;\n  cursor: pointer;\n  text-align: start;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.action-text__longtext[data-v-a8e61e98] {\n  cursor: pointer;\n  white-space: pre-wrap !important;\n}\n.action-text__name[data-v-a8e61e98] {\n  font-weight: bold;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n  max-width: 100%;\n  display: block;\n}\n.action-text__description[data-v-a8e61e98] {\n  display: block;\n  white-space: pre-wrap;\n  font-size: var(--font-size-small);\n  line-height: var(--default-line-height);\n  color: var(--color-text-maxcontrast);\n  cursor: pointer;\n}\n.action-text__menu-icon[data-v-a8e61e98] {\n  margin-inline: auto calc((var(--default-clickable-area) - 16px) / 2 * -1);\n}\n.action--disabled[data-v-a8e61e98] {\n  pointer-events: none;\n  opacity: 0.5;\n}\n.action--disabled[data-v-a8e61e98]:hover, .action--disabled[data-v-a8e61e98]:focus {\n  cursor: default;\n  opacity: 0.5;\n}\n.action--disabled[data-v-a8e61e98] * {\n  opacity: 1 !important;\n}\n.action-text[data-v-a8e61e98],\n.action-text span[data-v-a8e61e98] {\n  cursor: default;\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-350f3d1c] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n.user-status-icon[data-v-350f3d1c] {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-width: 16px;\n  min-height: 16px;\n  max-width: 20px;\n  max-height: 20px;\n}\n.user-status-icon--invisible[data-v-350f3d1c] {\n  filter: var(--background-invert-if-dark);\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-992f2357] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n\n/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nli.action[data-v-992f2357]:hover, li.action.active[data-v-992f2357] {\n  border-radius: 6px;\n  padding: 0;\n}\nli.action[data-v-992f2357]:hover {\n  background-color: var(--color-background-hover);\n}\n.action--disabled[data-v-992f2357] {\n  pointer-events: none;\n  opacity: 0.5;\n}\n.action--disabled[data-v-992f2357]:hover, .action--disabled[data-v-992f2357]:focus {\n  cursor: default;\n  opacity: 0.5;\n}\n.action--disabled[data-v-992f2357] * {\n  opacity: 1 !important;\n}\n.action-button[data-v-992f2357] {\n  display: flex;\n  align-items: flex-start;\n  width: 100%;\n  height: auto;\n  margin: 0;\n  padding: 0;\n  padding-inline-end: calc((var(--default-clickable-area) - 16px) / 2);\n  box-sizing: border-box;\n  cursor: pointer;\n  white-space: nowrap;\n  color: var(--color-main-text);\n  border: 0;\n  border-radius: 0;\n  background-color: transparent;\n  box-shadow: none;\n  font-weight: normal;\n  font-size: var(--default-font-size);\n  line-height: var(--default-clickable-area);\n}\n.action-button > span[data-v-992f2357] {\n  cursor: pointer;\n  white-space: nowrap;\n}\n.action-button__icon[data-v-992f2357] {\n  width: var(--default-clickable-area);\n  height: var(--default-clickable-area);\n  opacity: 1;\n  background-position: calc((var(--default-clickable-area) - 16px) / 2) center;\n  background-size: 16px;\n  background-repeat: no-repeat;\n}\n.action-button[data-v-992f2357] .material-design-icon {\n  width: var(--default-clickable-area);\n  height: var(--default-clickable-area);\n  opacity: 1;\n}\n.action-button[data-v-992f2357] .material-design-icon .material-design-icon__svg {\n  vertical-align: middle;\n}\n.action-button__longtext-wrapper[data-v-992f2357], .action-button__longtext[data-v-992f2357] {\n  max-width: 220px;\n  line-height: 1.6em;\n  padding: calc((var(--default-clickable-area) - 1.6em) / 2) 0;\n  cursor: pointer;\n  text-align: start;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.action-button__longtext[data-v-992f2357] {\n  cursor: pointer;\n  white-space: pre-wrap !important;\n}\n.action-button__name[data-v-992f2357] {\n  font-weight: bold;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n  max-width: 100%;\n  display: block;\n}\n.action-button__description[data-v-992f2357] {\n  display: block;\n  white-space: pre-wrap;\n  font-size: var(--font-size-small);\n  line-height: var(--default-line-height);\n  color: var(--color-text-maxcontrast);\n  cursor: pointer;\n}\n.action-button__menu-icon[data-v-992f2357] {\n  margin-inline: auto calc((var(--default-clickable-area) - 16px) / 2 * -1);\n}\n.action-button__pressed-icon[data-v-992f2357] {\n  margin-inline: auto calc((var(--default-clickable-area) - 16px) / 2 * -1);\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-c29760cd] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n.mention-bubble--primary .mention-bubble__content[data-v-c29760cd] {\n  color: var(--color-primary-element-text);\n  background-color: var(--color-primary-element);\n}\n.mention-bubble__wrapper[data-v-c29760cd] {\n  position: relative;\n  max-width: 150px;\n  height: 18px;\n  vertical-align: text-bottom;\n  display: inline-flex;\n  align-items: center;\n}\n.mention-bubble__content[data-v-c29760cd] {\n  display: inline-flex;\n  overflow: hidden;\n  align-items: center;\n  max-width: 100%;\n  height: 20px;\n  -webkit-user-select: none;\n  user-select: none;\n  padding-inline: 2px 6px;\n  border-radius: 10px;\n  background-color: var(--color-background-dark);\n}\n.mention-bubble__icon[data-v-c29760cd] {\n  position: relative;\n  width: 16px;\n  height: 16px;\n  border-radius: 8px;\n  background-color: var(--color-background-darker);\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: 12px;\n}\n.mention-bubble__icon--with-avatar[data-v-c29760cd] {\n  color: inherit;\n  background-size: cover;\n}\n.mention-bubble__title[data-v-c29760cd] {\n  overflow: hidden;\n  margin-inline-start: 2px;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n.mention-bubble__title[data-v-c29760cd]::before {\n  content: attr(title);\n}\n.mention-bubble__select[data-v-c29760cd] {\n  position: absolute;\n  z-index: -1;\n  inset-inline-start: -100vw;\n  width: 1px;\n  height: 1px;\n  overflow: hidden;\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-8e70b916] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n.widgets--list[data-v-8e70b916] {\n  width: 100%;\n  min-height: var(--default-clickable-area);\n}\n/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-9d3e4618] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n\n/**\n * SPDX-FileCopyrightText: 2024 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n* Colors and class selectors are extracted from source code of:\n* - library: highlight.js (v11.10.0)\n* - light theme: highlight.js/styles/github.css\n* - dark theme: highlight.js/styles/github-dark.css\n* and reworked to use with Nextcloud dark and light theme\n*/\n.rich-text--wrapper[data-v-9d3e4618] {\n  overflow-wrap: break-word;\n  line-height: 1.5;\n}\n.rich-text--wrapper .rich-text--fallback[data-v-9d3e4618], .rich-text--wrapper .rich-text-component[data-v-9d3e4618] {\n  display: inline;\n}\n.rich-text--wrapper .rich-text--external-link[data-v-9d3e4618] {\n  text-decoration: underline;\n}\n.rich-text--wrapper .rich-text--external-link[data-v-9d3e4618]:after {\n  content: " â†—";\n}\n\n/* Markdown styles */\n.rich-text--wrapper-markdown[data-v-9d3e4618] {\n  tab-size: 4;\n  /* Flavored Markdown styles */\n}\n.rich-text--wrapper-markdown div[data-v-9d3e4618] > *:first-child,\n.rich-text--wrapper-markdown blockquote[data-v-9d3e4618] > *:first-child {\n  margin-top: 0 !important;\n}\n.rich-text--wrapper-markdown div[data-v-9d3e4618] > *:last-child,\n.rich-text--wrapper-markdown blockquote[data-v-9d3e4618] > *:last-child {\n  margin-block-end: 0 !important;\n}\n.rich-text--wrapper-markdown blockquote[data-v-9d3e4618] {\n  padding-inline-start: 13px;\n  border-inline-start: 2px solid var(--color-border-dark);\n  color: var(--color-text-lighter);\n}\n.rich-text--wrapper-markdown h1[data-v-9d3e4618], .rich-text--wrapper-markdown h2[data-v-9d3e4618], .rich-text--wrapper-markdown h3[data-v-9d3e4618], .rich-text--wrapper-markdown h4[data-v-9d3e4618], .rich-text--wrapper-markdown h5[data-v-9d3e4618], .rich-text--wrapper-markdown h6[data-v-9d3e4618], .rich-text--wrapper-markdown p[data-v-9d3e4618], .rich-text--wrapper-markdown ul[data-v-9d3e4618], .rich-text--wrapper-markdown ol[data-v-9d3e4618], .rich-text--wrapper-markdown blockquote[data-v-9d3e4618], .rich-text--wrapper-markdown pre[data-v-9d3e4618] {\n  margin-top: 0;\n  margin-block-end: 1em;\n}\n.rich-text--wrapper-markdown h1[data-v-9d3e4618], .rich-text--wrapper-markdown h2[data-v-9d3e4618], .rich-text--wrapper-markdown h3[data-v-9d3e4618], .rich-text--wrapper-markdown h4[data-v-9d3e4618], .rich-text--wrapper-markdown h5[data-v-9d3e4618], .rich-text--wrapper-markdown h6[data-v-9d3e4618] {\n  font-weight: bold;\n}\n.rich-text--wrapper-markdown h1[data-v-9d3e4618] {\n  font-size: 30px;\n}\n.rich-text--wrapper-markdown ul[data-v-9d3e4618], .rich-text--wrapper-markdown ol[data-v-9d3e4618] {\n  padding-inline-start: 4ch;\n}\n.rich-text--wrapper-markdown ul[data-v-9d3e4618] {\n  list-style-type: disc;\n}\n.rich-text--wrapper-markdown ul.contains-task-list[data-v-9d3e4618] {\n  list-style-type: none;\n  padding: 0;\n}\n.rich-text--wrapper-markdown li.task-list-item > ul[data-v-9d3e4618],\n.rich-text--wrapper-markdown li.task-list-item > ol[data-v-9d3e4618],\n.rich-text--wrapper-markdown li.task-list-item > li[data-v-9d3e4618],\n.rich-text--wrapper-markdown li.task-list-item > blockquote[data-v-9d3e4618],\n.rich-text--wrapper-markdown li.task-list-item > pre[data-v-9d3e4618] {\n  margin-inline-start: 15px;\n  margin-block-end: 0;\n}\n.rich-text--wrapper-markdown table[data-v-9d3e4618] {\n  border-collapse: collapse;\n  border: 2px solid var(--color-border-maxcontrast);\n}\n.rich-text--wrapper-markdown table th[data-v-9d3e4618],\n.rich-text--wrapper-markdown table td[data-v-9d3e4618] {\n  padding: var(--default-grid-baseline);\n  border: 1px solid var(--color-border-maxcontrast);\n}\n.rich-text--wrapper-markdown table th[data-v-9d3e4618]:first-child,\n.rich-text--wrapper-markdown table td[data-v-9d3e4618]:first-child {\n  border-inline-start: 0;\n}\n.rich-text--wrapper-markdown table th[data-v-9d3e4618]:last-child,\n.rich-text--wrapper-markdown table td[data-v-9d3e4618]:last-child {\n  border-inline-end: 0;\n}\n.rich-text--wrapper-markdown table tr:first-child th[data-v-9d3e4618] {\n  border-top: 0;\n}\n.rich-text--wrapper-markdown table tr:last-child td[data-v-9d3e4618] {\n  border-block-end: 0;\n}\n\n/* Highlight code syntax in code blocks */\n/* stylelint-disable-next-line no-duplicate-selectors */\n.rich-text--wrapper-markdown pre[data-v-9d3e4618]:has(.hljs) {\n  color: var(--hljs-color);\n  background: var(--hljs-background-color);\n}\n.rich-text--wrapper-markdown .hljs-doctag[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-keyword[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-meta .hljs-keyword[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-template-tag[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-template-variable[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-type[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-variable.language_[data-v-9d3e4618] {\n  /* prettylights-syntax-keyword */\n  color: var(--hljs-syntax-keyword-color);\n}\n.rich-text--wrapper-markdown .hljs-title[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-title.class_[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-title.class_.inherited__[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-title.function_[data-v-9d3e4618] {\n  /* prettylights-syntax-entity */\n  color: var(--hljs-syntax-entity-color);\n}\n.rich-text--wrapper-markdown .hljs-attr[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-attribute[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-literal[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-meta[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-number[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-operator[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-variable[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-selector-attr[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-selector-class[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-selector-id[data-v-9d3e4618] {\n  /* prettylights-syntax-constant */\n  color: var(--hljs-syntax-constant-color);\n}\n.rich-text--wrapper-markdown .hljs-regexp[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-string[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-meta .hljs-string[data-v-9d3e4618] {\n  /* prettylights-syntax-string */\n  color: var(--hljs-syntax-string-color);\n}\n.rich-text--wrapper-markdown .hljs-built_in[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-symbol[data-v-9d3e4618] {\n  /* prettylights-syntax-variable */\n  color: var(--hljs-syntax-variable-color);\n}\n.rich-text--wrapper-markdown .hljs-comment[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-code[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-formula[data-v-9d3e4618] {\n  /* prettylights-syntax-comment */\n  color: var(--hljs-syntax-comment-color);\n}\n.rich-text--wrapper-markdown .hljs-name[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-quote[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-selector-tag[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-selector-pseudo[data-v-9d3e4618] {\n  /* prettylights-syntax-entity-tag */\n  color: var(--hljs-syntax-entity-tag-color);\n}\n.rich-text--wrapper-markdown .hljs-subst[data-v-9d3e4618] {\n  /* prettylights-syntax-storage-modifier-import */\n  color: var(--hljs-syntax-storage-modifier-import-color);\n}\n.rich-text--wrapper-markdown .hljs-section[data-v-9d3e4618] {\n  /* prettylights-syntax-markup-heading */\n  color: var(--hljs-syntax-markup-heading-color);\n  font-weight: bold;\n}\n.rich-text--wrapper-markdown .hljs-bullet[data-v-9d3e4618] {\n  /* prettylights-syntax-markup-list */\n  color: var(--hljs-syntax-markup-list-color);\n}\n.rich-text--wrapper-markdown .hljs-emphasis[data-v-9d3e4618] {\n  /* prettylights-syntax-markup-italic */\n  color: var(--hljs-syntax-markup-italic-color);\n  font-style: italic;\n}\n.rich-text--wrapper-markdown .hljs-strong[data-v-9d3e4618] {\n  /* prettylights-syntax-markup-bold */\n  color: var(--hljs-syntax-markup-bold-color);\n  font-weight: bold;\n}\n.rich-text--wrapper-markdown .hljs-addition[data-v-9d3e4618] {\n  /* prettylights-syntax-markup-inserted */\n  color: var(--hljs-syntax-markup-inserted-color);\n  background-color: var(--hljs-syntax-markup-inserted-background-color);\n}\n.rich-text--wrapper-markdown .hljs-deletion[data-v-9d3e4618] {\n  /* prettylights-syntax-markup-deleted */\n  color: var(--hljs-syntax-markup-deleted-color);\n  background-color: var(--hljs-syntax-markup-deleted-background-color);\n}\n.rich-text--wrapper-markdown .hljs-char.escape_[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-link[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-params[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-property[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-punctuation[data-v-9d3e4618],\n.rich-text--wrapper-markdown .hljs-tag[data-v-9d3e4618] {\n  /* purposely ignored */\n}\na[data-v-9d3e4618]:not(.rich-text--component) {\n  text-decoration: underline;\n}\n@media (prefers-color-scheme: light) {\n.rich-text--wrapper-markdown[data-v-9d3e4618] {\n    --hljs-color: var(--color-main-text, #24292e);\n    --hljs-background-color: var(--color-background-dark, #ffffff);\n    --hljs-syntax-keyword-color: #d73a49;\n    --hljs-syntax-entity-color: #6f42c1;\n    --hljs-syntax-constant-color: #005cc5;\n    --hljs-syntax-string-color: #032f62;\n    --hljs-syntax-variable-color: #e36209;\n    --hljs-syntax-comment-color: #6a737d;\n    --hljs-syntax-entity-tag-color: #22863a;\n    --hljs-syntax-storage-modifier-import-color: #24292e;\n    --hljs-syntax-markup-heading-color: #005cc5;\n    --hljs-syntax-markup-list-color: #735c0f;\n    --hljs-syntax-markup-italic-color: #24292e;\n    --hljs-syntax-markup-bold-color: #24292e;\n    --hljs-syntax-markup-inserted-color: #22863a;\n    --hljs-syntax-markup-inserted-background-color: #f0fff4;\n    --hljs-syntax-markup-deleted-color: #b31d28;\n    --hljs-syntax-markup-deleted-background-color: #ffeef0;\n}\n[data-theme-dark] .rich-text--wrapper-markdown[data-v-9d3e4618] {\n    --hljs-color: var(--color-main-text, #c9d1d9);\n    --hljs-background-color: var(--color-background-dark, #0d1117);\n    --hljs-syntax-keyword-color: #ff7b72;\n    --hljs-syntax-entity-color: #d2a8ff;\n    --hljs-syntax-constant-color: #79c0ff;\n    --hljs-syntax-string-color: #a5d6ff;\n    --hljs-syntax-variable-color: #ffa657;\n    --hljs-syntax-comment-color: #8b949e;\n    --hljs-syntax-entity-tag-color: #7ee787;\n    --hljs-syntax-storage-modifier-import-color: #c9d1d9;\n    --hljs-syntax-markup-heading-color: #1f6feb;\n    --hljs-syntax-markup-list-color: #f2cc60;\n    --hljs-syntax-markup-italic-color: #c9d1d9;\n    --hljs-syntax-markup-bold-color: #c9d1d9;\n    --hljs-syntax-markup-inserted-color: #aff5b4;\n    --hljs-syntax-markup-inserted-background-color: #033a16;\n    --hljs-syntax-markup-deleted-color: #ffdcd7;\n    --hljs-syntax-markup-deleted-background-color: #67060c;\n}\n}\n@media (prefers-color-scheme: dark) {\n.rich-text--wrapper-markdown[data-v-9d3e4618] {\n    --hljs-color: var(--color-main-text, #c9d1d9);\n    --hljs-background-color: var(--color-background-dark, #0d1117);\n    --hljs-syntax-keyword-color: #ff7b72;\n    --hljs-syntax-entity-color: #d2a8ff;\n    --hljs-syntax-constant-color: #79c0ff;\n    --hljs-syntax-string-color: #a5d6ff;\n    --hljs-syntax-variable-color: #ffa657;\n    --hljs-syntax-comment-color: #8b949e;\n    --hljs-syntax-entity-tag-color: #7ee787;\n    --hljs-syntax-storage-modifier-import-color: #c9d1d9;\n    --hljs-syntax-markup-heading-color: #1f6feb;\n    --hljs-syntax-markup-list-color: #f2cc60;\n    --hljs-syntax-markup-italic-color: #c9d1d9;\n    --hljs-syntax-markup-bold-color: #c9d1d9;\n    --hljs-syntax-markup-inserted-color: #aff5b4;\n    --hljs-syntax-markup-inserted-background-color: #033a16;\n    --hljs-syntax-markup-deleted-color: #ffdcd7;\n    --hljs-syntax-markup-deleted-background-color: #67060c;\n}\n[data-theme-light] .rich-text--wrapper-markdown[data-v-9d3e4618] {\n    --hljs-color: var(--color-main-text, #24292e);\n    --hljs-background-color: var(--color-background-dark, #ffffff);\n    --hljs-syntax-keyword-color: #d73a49;\n    --hljs-syntax-entity-color: #6f42c1;\n    --hljs-syntax-constant-color: #005cc5;\n    --hljs-syntax-string-color: #032f62;\n    --hljs-syntax-variable-color: #e36209;\n    --hljs-syntax-comment-color: #6a737d;\n    --hljs-syntax-entity-tag-color: #22863a;\n    --hljs-syntax-storage-modifier-import-color: #24292e;\n    --hljs-syntax-markup-heading-color: #005cc5;\n    --hljs-syntax-markup-list-color: #735c0f;\n    --hljs-syntax-markup-italic-color: #24292e;\n    --hljs-syntax-markup-bold-color: #24292e;\n    --hljs-syntax-markup-inserted-color: #22863a;\n    --hljs-syntax-markup-inserted-background-color: #f0fff4;\n    --hljs-syntax-markup-deleted-color: #b31d28;\n    --hljs-syntax-markup-deleted-background-color: #ffeef0;\n}\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-314bfb3a] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-aed6d462] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n.provider-list[data-v-aed6d462] {\n  width: 100%;\n  min-height: 400px;\n  padding: 0 16px 16px 16px;\n  display: flex;\n  flex-direction: column;\n}\n.provider-list--select[data-v-aed6d462] {\n  width: 100%;\n}\n.provider-list--select .provider[data-v-aed6d462] {\n  display: flex;\n  align-items: center;\n  height: 28px;\n  overflow: hidden;\n}\n.provider-list--select .provider .link-icon[data-v-aed6d462] {\n  margin-inline-end: 8px;\n}\n.provider-list--select .provider .provider-icon[data-v-aed6d462] {\n  width: 20px;\n  height: 20px;\n  object-fit: contain;\n  margin-inline-end: 8px;\n  filter: var(--background-invert-if-dark);\n}\n.provider-list--select .provider .option-text[data-v-aed6d462] {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-236df0ce] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n.widget-custom[data-v-236df0ce] {\n  width: 100%;\n  margin: auto;\n  margin-bottom: calc(var(--default-grid-baseline, 4px) * 3);\n  margin-top: calc(var(--default-grid-baseline, 4px) * 3);\n  overflow: hidden;\n  border: 2px solid var(--color-border);\n  border-radius: var(--border-radius-container);\n  background-color: transparent;\n  display: flex;\n}\n.widget-custom.full-width[data-v-236df0ce] {\n  width: var(--widget-full-width, 100%) !important;\n  inset-inline-start: calc((var(--widget-full-width, 100%) - 100%) / 2 * -1);\n  position: relative;\n}\n.widget-access[data-v-236df0ce] {\n  width: 100%;\n  margin: auto;\n  margin-bottom: calc(var(--default-grid-baseline, 4px) * 3);\n  margin-top: calc(var(--default-grid-baseline, 4px) * 3);\n  overflow: hidden;\n  border: 2px solid var(--color-border);\n  border-radius: var(--border-radius-container);\n  background-color: transparent;\n  display: flex;\n  padding: calc(var(--default-grid-baseline, 4px) * 3);\n}\n.widget-default[data-v-236df0ce] {\n  width: 100%;\n  margin: auto;\n  margin-bottom: calc(var(--default-grid-baseline, 4px) * 3);\n  margin-top: calc(var(--default-grid-baseline, 4px) * 3);\n  overflow: hidden;\n  border: 2px solid var(--color-border);\n  border-radius: var(--border-radius-container);\n  background-color: transparent;\n  display: flex;\n}\n.widget-default--compact[data-v-236df0ce] {\n  flex-direction: column;\n}\n.widget-default--compact .widget-default--image[data-v-236df0ce] {\n  width: 100%;\n  height: 150px;\n}\n.widget-default--compact .widget-default--details[data-v-236df0ce] {\n  width: 100%;\n  padding-top: calc(var(--default-grid-baseline, 4px) * 2);\n  padding-bottom: calc(var(--default-grid-baseline, 4px) * 2);\n}\n.widget-default--compact .widget-default--description[data-v-236df0ce] {\n  display: none;\n}\n.widget-default--image[data-v-236df0ce] {\n  width: 40%;\n  background-position: center;\n  background-size: cover;\n  background-repeat: no-repeat;\n}\n.widget-default--name[data-v-236df0ce] {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  font-weight: bold;\n}\n.widget-default--details[data-v-236df0ce] {\n  padding: calc(var(--default-grid-baseline, 4px) * 3);\n  width: 60%;\n}\n.widget-default--details p[data-v-236df0ce] {\n  margin: 0;\n  padding: 0;\n}\n.widget-default--description[data-v-236df0ce] {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 3;\n  line-clamp: 3; /* stylelint-disable-line property-no-unknown */\n  -webkit-box-orient: vertical;\n}\n.widget-default--link[data-v-236df0ce] {\n  color: var(--color-text-maxcontrast);\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.toggle-interactive[data-v-236df0ce] {\n  position: relative;\n}\n.toggle-interactive .toggle-interactive--button[data-v-236df0ce] {\n  position: absolute;\n  bottom: var(--default-grid-baseline);\n  inset-inline-end: var(--default-grid-baseline);\n  z-index: 10000;\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-0393ee75] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n.raw-link[data-v-0393ee75] {\n  width: 100%;\n  min-height: 350px;\n  display: flex;\n  flex-direction: column;\n  overflow-y: auto;\n  padding: 0 16px 16px 16px;\n}\n.raw-link .input-wrapper[data-v-0393ee75] {\n  width: 100%;\n}\n.raw-link .reference-widget[data-v-0393ee75] {\n  display: flex;\n}\n.raw-link--empty-content .provider-icon[data-v-0393ee75] {\n  width: 150px;\n  height: 150px;\n  object-fit: contain;\n  filter: var(--background-invert-if-dark);\n}\n.raw-link--input[data-v-0393ee75] {\n  width: 99%;\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-ff4bcbf3] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n.result[data-v-ff4bcbf3] {\n  display: flex;\n  align-items: center;\n  height: var(--default-clickable-area);\n  overflow: hidden;\n}\n.result--icon-class[data-v-ff4bcbf3], .result--image[data-v-ff4bcbf3] {\n  width: 40px;\n  min-width: 40px;\n  height: 40px;\n  object-fit: contain;\n}\n.result--icon-class.rounded[data-v-ff4bcbf3], .result--image.rounded[data-v-ff4bcbf3] {\n  border-radius: 50%;\n}\n.result--content[data-v-ff4bcbf3] {\n  display: flex;\n  flex-direction: column;\n  padding-inline-start: 10px;\n  overflow: hidden;\n}\n.result--content--name[data-v-ff4bcbf3], .result--content--subline[data-v-ff4bcbf3] {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-c1841318] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n.smart-picker-search[data-v-c1841318] {\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n  padding: 0 16px 16px 16px;\n}\n.smart-picker-search.with-empty-content[data-v-c1841318] {\n  min-height: 400px;\n}\n.smart-picker-search .provider-icon[data-v-c1841318] {\n  width: 150px;\n  height: 150px;\n  object-fit: contain;\n  filter: var(--background-invert-if-dark);\n}\n.smart-picker-search--select[data-v-c1841318] {\n  width: 100%;\n}\n.smart-picker-search--select .search-result[data-v-c1841318] {\n  width: 100%;\n}\n.smart-picker-search--select .group-name-icon[data-v-c1841318],\n.smart-picker-search--select .option-simple-icon[data-v-c1841318] {\n  width: 20px;\n  height: 20px;\n  margin: 0 20px 0 10px;\n}\n.smart-picker-search--select .custom-option[data-v-c1841318] {\n  height: var(--default-clickable-area);\n  display: flex;\n  align-items: center;\n  overflow: hidden;\n}\n.smart-picker-search--select .option-text[data-v-c1841318] {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-cd33df8e] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n.reference-picker[data-v-cd33df8e] {\n  display: flex;\n  overflow-y: auto;\n  width: 100%;\n}\n.reference-picker .custom-element-wrapper[data-v-cd33df8e] {\n  display: flex;\n  overflow-y: auto;\n  width: 100%;\n}\n.reference-picker .custom-element-wrapper .custom-element[data-v-cd33df8e] {\n  display: flex;\n  overflow-y: auto;\n  width: 100%;\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n.reference-picker-modal .modal-container {\n  display: flex !important;\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-b92e97e4] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n.reference-picker-modal--content[data-v-b92e97e4] {\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  overflow-y: auto;\n}\n.reference-picker-modal--content .close-button[data-v-b92e97e4],\n.reference-picker-modal--content .back-button[data-v-b92e97e4] {\n  position: absolute;\n  top: 4px;\n}\n.reference-picker-modal--content .back-button[data-v-b92e97e4] {\n  inset-inline-start: 4px;\n}\n.reference-picker-modal--content .close-button[data-v-b92e97e4] {\n  inset-inline-end: 4px;\n}\n.reference-picker-modal--content > h2[data-v-b92e97e4] {\n  display: flex;\n  margin: 12px 0 20px 0;\n}\n.reference-picker-modal--content > h2 .icon[data-v-b92e97e4] {\n  margin-inline-end: 8px;\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\nbody {\n  /**\n   * Set custom vue-select CSS variables.\n   * Needs to be on the body (not :root) for theming to apply (see nextcloud/server#36462)\n   */\n  /* Search Input */\n  --vs-search-input-color: var(--color-main-text);\n  --vs-search-input-bg: var(--color-main-background);\n  --vs-search-input-placeholder-color: var(--color-text-maxcontrast);\n  /* Font */\n  --vs-font-size: var(--default-font-size);\n  --vs-line-height: var(--default-line-height);\n  /* Disabled State */\n  --vs-state-disabled-bg: var(--color-background-hover);\n  --vs-state-disabled-color: var(--color-text-maxcontrast);\n  --vs-state-disabled-controls-color: var(--color-text-maxcontrast);\n  --vs-state-disabled-cursor: not-allowed;\n  --vs-disabled-bg: var(--color-background-hover);\n  --vs-disabled-color: var(--color-text-maxcontrast);\n  --vs-disabled-cursor: not-allowed;\n  /* Borders */\n  --vs-border-color: var(--color-border-maxcontrast);\n  --vs-border-width: var(--border-width-input, 2px) !important;\n  --vs-border-style: solid;\n  --vs-border-radius: var(--border-radius-large);\n  /* Component Controls: Clear, Open Indicator */\n  --vs-controls-color: var(--color-main-text);\n  /* Selected */\n  --vs-selected-bg: var(--color-background-hover);\n  --vs-selected-color: var(--color-main-text);\n  --vs-selected-border-color: var(--vs-border-color);\n  --vs-selected-border-style: var(--vs-border-style);\n  --vs-selected-border-width: var(--vs-border-width);\n  /* Dropdown */\n  --vs-dropdown-bg: var(--color-main-background);\n  --vs-dropdown-color: var(--color-main-text);\n  --vs-dropdown-z-index: 9999;\n  --vs-dropdown-box-shadow: 0px 2px 2px 0px var(--color-box-shadow);\n  /* Options */\n  --vs-dropdown-option-padding: 8px 20px;\n  /* Active State */\n  --vs-dropdown-option--active-bg: var(--color-background-hover);\n  --vs-dropdown-option--active-color: var(--color-main-text);\n  /* Keyboard Focus State */\n  --vs-dropdown-option--kb-focus-box-shadow: inset 0px 0px 0px 2px var(--vs-border-color);\n  /* Deselect State */\n  --vs-dropdown-option--deselect-bg: var(--color-error);\n  --vs-dropdown-option--deselect-color: #fff;\n  /* Transitions */\n  --vs-transition-duration: 0ms;\n  /* Actions */\n  --vs-actions-padding: 0 8px 0 4px;\n}\n.v-select.select {\n  /* Override default vue-select styles */\n  min-height: var(--default-clickable-area);\n  min-width: 260px;\n  margin: 0 0 var(--default-grid-baseline);\n}\n.v-select.select.vs--open {\n  --vs-border-width: var(--border-width-input-focused, 2px);\n}\n.v-select.select .select__label {\n  display: block;\n  margin-bottom: 2px;\n}\n.v-select.select .vs__selected {\n  height: calc(var(--default-clickable-area) - 2 * var(--vs-border-width) - var(--default-grid-baseline));\n  margin: calc(var(--default-grid-baseline) / 2);\n  padding-block: 0;\n  padding-inline: 12px 8px;\n  border-radius: 16px !important;\n  background: var(--color-primary-element-light);\n  border: none;\n}\n.v-select.select.vs--open .vs__selected:first-of-type {\n  margin-inline-start: calc(var(--default-grid-baseline) / 2 - (var(--border-width-input-focused, 2px) - var(--border-width-input, 2px))) !important;\n}\n.v-select.select .vs__search {\n  text-overflow: ellipsis;\n  color: var(--color-main-text);\n  min-height: unset !important;\n  height: calc(var(--default-clickable-area) - 2 * var(--vs-border-width)) !important;\n}\n.v-select.select .vs__search::placeholder {\n  color: var(--color-text-maxcontrast);\n}\n.v-select.select .vs__search, .v-select.select .vs__search:focus {\n  margin: 0;\n}\n.v-select.select .vs__dropdown-toggle {\n  position: relative;\n  max-height: 100px;\n  padding: 0;\n  overflow-y: auto;\n}\n.v-select.select .vs__actions {\n  position: sticky;\n  top: 0;\n}\n.v-select.select .vs__clear {\n  margin-inline-end: 2px;\n}\n.v-select.select.vs--open .vs__dropdown-toggle {\n  border-width: var(--border-width-input-focused);\n  outline: 2px solid var(--color-main-background);\n  border-color: var(--color-main-text);\n  border-bottom-color: transparent;\n}\n.v-select.select:not(.vs--disabled, .vs--open) .vs__dropdown-toggle:hover {\n  outline: 2px solid var(--color-main-background);\n  border-color: var(--color-main-text);\n}\n.v-select.select.vs--disabled .vs__search,\n.v-select.select.vs--disabled .vs__selected {\n  color: var(--color-text-maxcontrast);\n}\n.v-select.select.vs--disabled .vs__clear,\n.v-select.select.vs--disabled .vs__deselect {\n  display: none;\n}\n.v-select.select--no-wrap .vs__selected-options {\n  flex-wrap: nowrap;\n  overflow: auto;\n  min-width: unset;\n}\n.v-select.select--no-wrap .vs__selected-options .vs__selected {\n  min-width: unset;\n}\n.v-select.select--drop-up.vs--open .vs__dropdown-toggle {\n  border-radius: 0 0 var(--vs-border-radius) var(--vs-border-radius);\n  border-top-color: transparent;\n  border-bottom-color: var(--color-main-text);\n}\n.v-select.select .vs__selected-options {\n  min-height: calc(var(--default-clickable-area) - 2 * var(--vs-border-width));\n  padding: 0 5px;\n}\n.v-select.select .vs__selected-options .vs__selected ~ .vs__search[readonly] {\n  position: absolute;\n}\n.v-select.select.vs--single.vs--loading .vs__selected, .v-select.select.vs--single.vs--open .vs__selected {\n  max-width: 100%;\n  opacity: 1;\n  color: var(--color-text-maxcontrast);\n}\n.v-select.select.vs--single .vs__selected-options {\n  flex-wrap: nowrap;\n}\n.v-select.select.vs--single .vs__selected {\n  background: unset !important;\n}\n.vs__dropdown-menu {\n  border-width: var(--border-width-input-focused) !important;\n  border-color: var(--color-main-text) !important;\n  outline: none !important;\n  box-shadow: -2px 0 0 var(--color-main-background), 0 2px 0 var(--color-main-background), 2px 0 0 var(--color-main-background), !important;\n  padding: 4px !important;\n}\n.vs__dropdown-menu--floating {\n  /* Fallback styles overidden by programmatically set inline styles */\n  width: max-content;\n  position: absolute;\n  top: 0;\n  inset-inline-start: 0;\n}\n.vs__dropdown-menu--floating-placement-top {\n  border-radius: var(--vs-border-radius) var(--vs-border-radius) 0 0 !important;\n  border-top-style: var(--vs-border-style) !important;\n  border-bottom-style: none !important;\n  box-shadow: 0 -2px 0 var(--color-main-background), -2px 0 0 var(--color-main-background), 2px 0 0 var(--color-main-background), !important;\n}\n.vs__dropdown-menu .vs__dropdown-option {\n  border-radius: 6px !important;\n}\n.vs__dropdown-menu .vs__no-options {\n  color: var(--color-text-lighter) !important;\n}:root{--vs-colors--lightest: rgba(60, 60, 60, .26);--vs-colors--light: rgba(60, 60, 60, .5);--vs-colors--dark: #333;--vs-colors--darkest: rgba(0, 0, 0, .15);--vs-search-input-color: inherit;--vs-search-input-placeholder-color: inherit;--vs-font-size: 1rem;--vs-line-height: 1.4;--vs-state-disabled-bg: rgb(248, 248, 248);--vs-state-disabled-color: var(--vs-colors--light);--vs-state-disabled-controls-color: var(--vs-colors--light);--vs-state-disabled-cursor: not-allowed;--vs-border-color: var(--vs-colors--lightest);--vs-border-width: 1px;--vs-border-style: solid;--vs-border-radius: 4px;--vs-actions-padding: 4px 6px 0 3px;--vs-controls-color: var(--vs-colors--light);--vs-controls-size: 1;--vs-controls--deselect-text-shadow: 0 1px 0 #fff;--vs-selected-bg: #f0f0f0;--vs-selected-color: var(--vs-colors--dark);--vs-selected-border-color: var(--vs-border-color);--vs-selected-border-style: var(--vs-border-style);--vs-selected-border-width: var(--vs-border-width);--vs-dropdown-bg: #fff;--vs-dropdown-color: inherit;--vs-dropdown-z-index: 1000;--vs-dropdown-min-width: 160px;--vs-dropdown-max-height: 350px;--vs-dropdown-box-shadow: 0px 3px 6px 0px var(--vs-colors--darkest);--vs-dropdown-option-bg: #000;--vs-dropdown-option-color: var(--vs-dropdown-color);--vs-dropdown-option-padding: 3px 20px;--vs-dropdown-option--active-bg: #5897fb;--vs-dropdown-option--active-color: #fff;--vs-dropdown-option--deselect-bg: #fb5858;--vs-dropdown-option--deselect-color: #fff;--vs-transition-timing-function: cubic-bezier(1, -.115, .975, .855);--vs-transition-duration: .15s}.v-select{position:relative;font-family:inherit}.v-select,.v-select *{box-sizing:border-box}:root{--vs-transition-timing-function: cubic-bezier(1, .5, .8, 1);--vs-transition-duration: .15s}@-webkit-keyframes vSelectSpinner{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes vSelectSpinner{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.vs__fade-enter-active,.vs__fade-leave-active{pointer-events:none;transition:opacity var(--vs-transition-duration) var(--vs-transition-timing-function)}.vs__fade-enter,.vs__fade-leave-to{opacity:0}:root{--vs-disabled-bg: var(--vs-state-disabled-bg);--vs-disabled-color: var(--vs-state-disabled-color);--vs-disabled-cursor: var(--vs-state-disabled-cursor)}.vs--disabled .vs__dropdown-toggle,.vs--disabled .vs__clear,.vs--disabled .vs__search,.vs--disabled .vs__selected,.vs--disabled .vs__open-indicator{cursor:var(--vs-disabled-cursor);background-color:var(--vs-disabled-bg)}.v-select[dir=rtl] .vs__actions{padding:0 3px 0 6px}.v-select[dir=rtl] .vs__clear{margin-left:6px;margin-right:0}.v-select[dir=rtl] .vs__deselect{margin-left:0;margin-right:2px}.v-select[dir=rtl] .vs__dropdown-menu{text-align:right}.vs__dropdown-toggle{-webkit-appearance:none;-moz-appearance:none;appearance:none;display:flex;padding:0 0 4px;background:none;border:var(--vs-border-width) var(--vs-border-style) var(--vs-border-color);border-radius:var(--vs-border-radius);white-space:normal}.vs__selected-options{display:flex;flex-basis:100%;flex-grow:1;flex-wrap:wrap;padding:0 2px;position:relative}.vs__actions{display:flex;align-items:center;padding:var(--vs-actions-padding)}.vs--searchable .vs__dropdown-toggle{cursor:text}.vs--unsearchable .vs__dropdown-toggle{cursor:pointer}.vs--open .vs__dropdown-toggle{border-bottom-color:transparent;border-bottom-left-radius:0;border-bottom-right-radius:0}.vs__open-indicator{fill:var(--vs-controls-color);transform:scale(var(--vs-controls-size));transition:transform var(--vs-transition-duration) var(--vs-transition-timing-function);transition-timing-function:var(--vs-transition-timing-function)}.vs--open .vs__open-indicator{transform:rotate(180deg) scale(var(--vs-controls-size))}.vs--loading .vs__open-indicator{opacity:0}.vs__clear{fill:var(--vs-controls-color);padding:0;border:0;background-color:transparent;cursor:pointer;margin-right:8px}.vs__dropdown-menu{display:block;box-sizing:border-box;position:absolute;top:calc(100% - var(--vs-border-width));left:0;z-index:var(--vs-dropdown-z-index);padding:5px 0;margin:0;width:100%;max-height:var(--vs-dropdown-max-height);min-width:var(--vs-dropdown-min-width);overflow-y:auto;box-shadow:var(--vs-dropdown-box-shadow);border:var(--vs-border-width) var(--vs-border-style) var(--vs-border-color);border-top-style:none;border-radius:0 0 var(--vs-border-radius) var(--vs-border-radius);text-align:left;list-style:none;background:var(--vs-dropdown-bg);color:var(--vs-dropdown-color)}.vs__no-options{text-align:center}.vs__dropdown-option{line-height:1.42857143;display:block;padding:var(--vs-dropdown-option-padding);clear:both;color:var(--vs-dropdown-option-color);white-space:nowrap;cursor:pointer}.vs__dropdown-option--highlight{background:var(--vs-dropdown-option--active-bg);color:var(--vs-dropdown-option--active-color)}.vs__dropdown-option--deselect{background:var(--vs-dropdown-option--deselect-bg);color:var(--vs-dropdown-option--deselect-color)}.vs__dropdown-option--disabled{background:var(--vs-state-disabled-bg);color:var(--vs-state-disabled-color);cursor:var(--vs-state-disabled-cursor)}.vs__selected{display:flex;align-items:center;background-color:var(--vs-selected-bg);border:var(--vs-selected-border-width) var(--vs-selected-border-style) var(--vs-selected-border-color);border-radius:var(--vs-border-radius);color:var(--vs-selected-color);line-height:var(--vs-line-height);margin:4px 2px 0;padding:0 .25em;z-index:0}.vs__deselect{display:inline-flex;-webkit-appearance:none;-moz-appearance:none;appearance:none;margin-left:4px;padding:0;border:0;cursor:pointer;background:none;fill:var(--vs-controls-color);text-shadow:var(--vs-controls--deselect-text-shadow)}.vs--single .vs__selected{background-color:transparent;border-color:transparent}.vs--single.vs--open .vs__selected,.vs--single.vs--loading .vs__selected{position:absolute;opacity:.4}.vs--single.vs--searching .vs__selected{display:none}.vs__search::-webkit-search-cancel-button{display:none}.vs__search::-webkit-search-decoration,.vs__search::-webkit-search-results-button,.vs__search::-webkit-search-results-decoration,.vs__search::-ms-clear{display:none}.vs__search,.vs__search:focus{color:var(--vs-search-input-color);-webkit-appearance:none;-moz-appearance:none;appearance:none;line-height:var(--vs-line-height);font-size:var(--vs-font-size);border:1px solid transparent;border-left:none;outline:none;margin:4px 0 0;padding:0 7px;background:none;box-shadow:none;width:0;max-width:100%;flex-grow:1;z-index:1}.vs__search::-moz-placeholder{color:var(--vs-search-input-placeholder-color)}.vs__search::placeholder{color:var(--vs-search-input-placeholder-color)}.vs--unsearchable .vs__search{opacity:1}.vs--unsearchable:not(.vs--disabled) .vs__search{cursor:pointer}.vs--single.vs--searching:not(.vs--open):not(.vs--loading) .vs__search{opacity:.2}.vs__spinner{align-self:center;opacity:0;font-size:5px;text-indent:-9999em;overflow:hidden;border-top:.9em solid rgba(100,100,100,.1);border-right:.9em solid rgba(100,100,100,.1);border-bottom:.9em solid rgba(100,100,100,.1);border-left:.9em solid rgba(60,60,60,.45);transform:translateZ(0) scale(var(--vs-controls--spinner-size, var(--vs-controls-size)));-webkit-animation:vSelectSpinner 1.1s infinite linear;animation:vSelectSpinner 1.1s infinite linear;transition:opacity .1s}.vs__spinner,.vs__spinner:after{border-radius:50%;width:5em;height:5em;transform:scale(var(--vs-controls--spinner-size, var(--vs-controls-size)))}.vs--loading .vs__spinner{opacity:1}\n/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-88bce9ff] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n.name-parts[data-v-88bce9ff] {\n  display: flex;\n  max-width: 100%;\n  cursor: inherit;\n}\n.name-parts__first[data-v-88bce9ff] {\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.name-parts__first[data-v-88bce9ff], .name-parts__last[data-v-88bce9ff] {\n  white-space: pre;\n  cursor: inherit;\n}\n.name-parts__first strong[data-v-88bce9ff], .name-parts__last strong[data-v-88bce9ff] {\n  font-weight: bold;\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-c64ebaf9] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n.input-field[data-v-c64ebaf9] {\n  --input-border-radius: var(--border-radius-element, var(--border-radius-large));\n  --input-padding-start: var(--border-radius-large);\n  --input-padding-end: var(--border-radius-large);\n  position: relative;\n  width: 100%;\n  margin-block-start: 6px;\n}\n.input-field--disabled[data-v-c64ebaf9] {\n  opacity: 0.4;\n  filter: saturate(0.4);\n}\n.input-field--label-outside[data-v-c64ebaf9] {\n  margin-block-start: 0;\n}\n.input-field--leading-icon[data-v-c64ebaf9] {\n  --input-padding-start: calc(var(--default-clickable-area) - var(--default-grid-baseline));\n}\n.input-field--trailing-icon[data-v-c64ebaf9] {\n  --input-padding-end: calc(var(--default-clickable-area) - var(--default-grid-baseline));\n}\n.input-field--pill[data-v-c64ebaf9] {\n  --input-border-radius: var(--border-radius-pill);\n}\n.input-field__main-wrapper[data-v-c64ebaf9] {\n  height: var(--default-clickable-area);\n  position: relative;\n}\n.input-field__input[data-v-c64ebaf9] {\n  --input-border-width-offset: calc(var(--border-width-input-focused, 2px) - var(--border-width-input, 2px));\n  background-color: var(--color-main-background);\n  color: var(--color-main-text);\n  border: var(--border-width-input, 2px) solid var(--color-border-maxcontrast);\n  border-radius: var(--input-border-radius);\n  cursor: pointer;\n  -webkit-appearance: textfield !important;\n  -moz-appearance: textfield !important;\n  appearance: textfield !important;\n  font-size: var(--default-font-size);\n  text-overflow: ellipsis;\n  height: calc(var(--default-clickable-area) - 2 * var(--input-border-width-offset)) !important;\n  width: 100%;\n  padding-inline: calc(var(--input-padding-start) + var(--input-border-width-offset)) calc(var(--input-padding-end) + var(--input-border-width-offset));\n  padding-block: var(--input-border-width-offset);\n}\n.input-field__input[data-v-c64ebaf9]::placeholder {\n  color: var(--color-text-maxcontrast);\n}\n.input-field__input[data-v-c64ebaf9]:active:not([disabled]), .input-field__input[data-v-c64ebaf9]:hover:not([disabled]), .input-field__input[data-v-c64ebaf9]:focus:not([disabled]) {\n  border-color: var(--color-main-text);\n  border-width: var(--border-width-input-focused, 2px);\n  box-shadow: 0 0 0 2px var(--color-main-background) !important;\n  --input-border-width-offset: 0px;\n}\n.input-field__input:focus + .input-field__label[data-v-c64ebaf9], .input-field__input:hover:not(:placeholder-shown) + .input-field__label[data-v-c64ebaf9] {\n  color: var(--color-main-text);\n}\n.input-field__input[data-v-c64ebaf9]:focus {\n  cursor: text;\n}\n.input-field__input[data-v-c64ebaf9]:disabled {\n  cursor: default;\n}\n.input-field__input[data-v-c64ebaf9]:focus-visible {\n  box-shadow: unset !important;\n}\n.input-field__input--success[data-v-c64ebaf9] {\n  border-color: var(--color-success) !important;\n}\n.input-field__input--success[data-v-c64ebaf9]:focus-visible {\n  box-shadow: rgb(248, 250, 252) 0px 0px 0px 2px, var(--color-primary-element) 0px 0px 0px 4px, rgba(0, 0, 0, 0.05) 0px 1px 2px 0px;\n}\n.input-field__input--error[data-v-c64ebaf9], .input-field__input[data-v-c64ebaf9]:user-invalid {\n  border-color: var(--color-error) !important;\n}\n.input-field__input--error[data-v-c64ebaf9]:focus-visible, .input-field__input[data-v-c64ebaf9]:user-invalid:focus-visible {\n  box-shadow: rgb(248, 250, 252) 0px 0px 0px 2px, var(--color-primary-element) 0px 0px 0px 4px, rgba(0, 0, 0, 0.05) 0px 1px 2px 0px;\n}\n.input-field:not(.input-field--label-outside) .input-field__input[data-v-c64ebaf9]:not(:focus)::placeholder {\n  opacity: 0;\n}\n.input-field__label[data-v-c64ebaf9] {\n  --input-label-font-size: var(--default-font-size);\n  font-size: var(--input-label-font-size);\n  position: absolute;\n  margin-inline: var(--input-padding-start) var(--input-padding-end);\n  max-width: fit-content;\n  inset-block-start: calc((var(--default-clickable-area) - 1lh) / 2);\n  inset-inline: var(--border-width-input-focused, 2px);\n  color: var(--color-text-maxcontrast);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  pointer-events: none;\n  transition: height var(--animation-quick), inset-block-start var(--animation-quick), font-size var(--animation-quick), color var(--animation-quick), background-color var(--animation-quick) var(--animation-slow);\n}\n.input-field__input:focus + .input-field__label[data-v-c64ebaf9], .input-field__input:not(:placeholder-shown) + .input-field__label[data-v-c64ebaf9] {\n  --input-label-font-size: 13px;\n  line-height: 1.5;\n  inset-block-start: calc(-1.5 * var(--input-label-font-size) / 2);\n  font-weight: 500;\n  border-radius: var(--default-grid-baseline) var(--default-grid-baseline) 0 0;\n  background-color: var(--color-main-background);\n  padding-inline: var(--default-grid-baseline);\n  margin-inline: calc(var(--input-padding-start) - var(--default-grid-baseline)) calc(var(--input-padding-end) - var(--default-grid-baseline));\n  transition: height var(--animation-quick), inset-block-start var(--animation-quick), font-size var(--animation-quick), color var(--animation-quick);\n}\n.input-field__icon[data-v-c64ebaf9] {\n  position: absolute;\n  height: var(--default-clickable-area);\n  width: var(--default-clickable-area);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  opacity: 0.7;\n  inset-block-end: 0;\n}\n.input-field__icon--leading[data-v-c64ebaf9] {\n  inset-inline-start: 0px;\n}\n.input-field__icon--trailing[data-v-c64ebaf9] {\n  inset-inline-end: 0px;\n}\n.input-field__trailing-button[data-v-c64ebaf9] {\n  --button-size: calc(var(--default-clickable-area) - 2 * var(--border-width-input-focused, 2px)) !important;\n  --button-radius: calc(var(--input-border-radius) - var(--border-width-input-focused, 2px));\n}\n.input-field__trailing-button.button-vue[data-v-c64ebaf9] {\n  position: absolute;\n  top: var(--border-width-input-focused, 2px);\n  inset-inline-end: var(--border-width-input-focused, 2px);\n}\n.input-field__trailing-button.button-vue[data-v-c64ebaf9]:focus-visible {\n  box-shadow: none !important;\n}\n.input-field__helper-text-message[data-v-c64ebaf9] {\n  padding-block: 4px;\n  padding-inline: var(--border-radius-large);\n  display: flex;\n  align-items: center;\n  color: var(--color-text-maxcontrast);\n}\n.input-field__helper-text-message__icon[data-v-c64ebaf9] {\n  margin-inline-end: 8px;\n}\n.input-field__helper-text-message--error[data-v-c64ebaf9] {\n  color: var(--color-error-text);\n}\n.input-field__helper-text-message--success[data-v-c64ebaf9] {\n  color: var(--color-success-text);\n}/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/*\n* Ensure proper alignment of the vue material icons\n*/\n.material-design-icon[data-v-6e4010a7] {\n  display: flex;\n  align-self: center;\n  justify-self: center;\n  align-items: center;\n  justify-content: center;\n}\n.user-bubble__wrapper[data-v-6e4010a7] {\n  display: inline-block;\n  vertical-align: middle;\n  min-width: 0;\n  max-width: 100%;\n}\n.user-bubble__content[data-v-6e4010a7] {\n  display: inline-flex;\n  max-width: 100%;\n  background-color: var(--color-background-dark);\n}\n.user-bubble__content--primary[data-v-6e4010a7] {\n  color: var(--color-primary-element-text);\n  background-color: var(--color-primary-element);\n}\n.user-bubble__content[data-v-6e4010a7] > :last-child {\n  padding-inline-end: 8px;\n}\n.user-bubble__avatar[data-v-6e4010a7] {\n  align-self: center;\n}\n.user-bubble__name[data-v-6e4010a7] {\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n.user-bubble__name[data-v-6e4010a7], .user-bubble__secondary[data-v-6e4010a7] {\n  padding-block: 0;\n  padding-inline: 4px 0;\n}.rich-text-file .icon-home[data-v-1e310300] {\n  display: inline-block;\n  vertical-align: text-top;\n}\nstrong[data-v-68cdf5ca] {\n	padding: 2px 5px;\n	border-radius: 3px;\n	background-color: var(--color-background-darker);\n	font-weight: normal;\n}\n.comments-activity[data-v-a396141a] {\n  display: flex;\n  flex-wrap: nowrap;\n  align-items: flex-start;\n  width: 100%;\n  min-height: 32px;\n  padding: 8px 0;\n  gap: 8px;\n}\n.comments-activity__icon[data-v-a396141a] {\n  flex: 0 0 fit-content;\n}\n.comments-activity__content[data-v-a396141a] {\n  flex: 1 0;\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n}\n.comments-activity__title[data-v-a396141a] {\n  color: var(--color-text-maxcontrast);\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n}\n.comments-activity__date[data-v-a396141a] {\n  color: var(--color-text-maxcontrast);\n}.activity-entry[data-v-3de9cd45] {\n  display: flex;\n  flex-wrap: wrap;\n  align-items: flex-start;\n  width: 100%;\n  height: var(--height);\n  min-height: 32px;\n  padding: 8px 0;\n}\n.activity-entry__icon[data-v-3de9cd45] {\n  opacity: 0.5;\n  margin-top: 2px;\n}\n.activity-entry .avatardiv[data-v-3de9cd45] {\n  box-sizing: content-box !important;\n  background-color: unset !important;\n}\n.activity-entry .avatardiv[data-v-3de9cd45] img {\n  border-radius: 0 !important;\n}\n.activity-entry__content[data-v-3de9cd45] {\n  display: flex;\n  flex-basis: min-content;\n  flex-direction: column;\n  flex-grow: 1;\n  overflow-wrap: break-word;\n  white-space: pre-wrap;\n  word-break: break-word;\n  overflow: hidden;\n}\n.activity-entry__content__subject[data-v-3de9cd45] {\n  padding: 0 5px;\n}\n.activity-entry__content__message[data-v-3de9cd45] {\n  color: var(--color-text-lighter);\n}\n.activity-entry__content[data-v-3de9cd45] a {\n  font-weight: bold;\n}\n.activity-entry__content[data-v-3de9cd45] a:hover {\n  opacity: 0.7;\n  text-decoration: underline;\n}\n.activity-entry__actions[data-v-3de9cd45] {\n  inset-block: -8px;\n}\n.activity-entry__date[data-v-3de9cd45] {\n  color: var(--color-text-lighter);\n  margin-left: 5px;\n  flex-shrink: 0;\n}\n.activity-entry__preview-wrapper[data-v-3de9cd45] {\n  flex: 0 0 100%;\n  gap: 12px;\n  padding-inline-start: 24px;\n  display: flex;\n  flex-wrap: wrap;\n}\n.activity-entry__preview[data-v-3de9cd45]:hover {\n  opacity: 0.75;\n}\n.activity-entry__preview-image[data-v-3de9cd45] {\n  height: 50px;\n  width: 50px;\n}\n.activity-entry__preview-image[data-v-3de9cd45]:not(.activity-entry__preview-mimetype) {\n  border: 2px solid var(--color-border);\n  border-radius: var(--border-radius-large);\n}\n.activity-entry__preview-image[data-v-3de9cd45]:not(.activity-entry__preview-mimetype):hover {\n  border-color: var(--color-main-text);\n  outline: 2px solid var(--color-main-background);\n}'));
      document.head.appendChild(elementStyle);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
const appName = "extended_activity";
const appVersion = "5.0.0-dev.0";
import { k as defineComponent, W as useCssVars, p as computed, X as purify, J as warn, c as createElementBlock, o as openBlock, f as createBaseVNode, n as normalizeClass, Y as getLocale, l as createCommentVNode, e as renderSlot, t as toDisplayString, i as createTextVNode, C as normalizeStyle, b as resolveComponent, g as createVNode, h as withCtx, Z as mergeModels, _ as useModel, q as watch, d as createBlock, m as mergeProps, E as h, $ as shallowRef, a0 as toValue, D as unref, a1 as resolveDirective, w as withDirectives, Q as createSlots, G as Fragment, I as renderList, z as resolveDynamicComponent, a2 as toHandlers, r as ref, a3 as getCanonicalLocale, a4 as getLanguage, a5 as watchEffect, a6 as onUnmounted, a7 as toRef$1, M as normalizeProps, N as guardReactiveProps, v as vShow, j as withModifiers, P as Transition, F as nextTick, H as translate, s as onMounted, B as getCurrentInstance } from "./translation-CD_FiYBO-CK2BqXfP.chunk.mjs";
import { _ as _export_sfc, A as getGettextBuilder, B as NC_ACTIONS_CLOSE_MENU, C as NC_ACTIONS_IS_SEMANTIC_MENU, l as loadState, r as register, D as t10, t, d as cancelableClient, v, E as t3, s as _, F as w, G as f$1, H as toRef, I as tryOnScopeDispose, J as isIOS, K as toArray, L as watchImmediate, M as isObject, O as isClient, P as noop, Q as t9, N as NcButton, p as NcActions, R as DotsHorizontal, S as t2, T as t16, o as createElementId, k as t46, V as t17, W as t7, X as h$1, Y as t41, Z as t37, $ as t22, a0 as t23, a1 as t39, a2 as t30, a3 as t18, a4 as t11, a5 as RouterLink, a6 as useElementSize, a7 as useIntersectionObserver, a8 as NcPopover } from "./index-BJ7ydZxs.chunk.mjs";
import { g as getLoggerBuilder, d as distExports, a as getCurrentUser, u as unsubscribe, s as subscribe, p as process$1 } from "./index-KfUaQuGs.chunk.mjs";
import { N as NcLoadingIcon, a as NcCheckboxRadioSwitch, _ as _export_sfc$1 } from "./NcCheckboxRadioSwitch-Ca1ouh22-BmLj0R_Y.chunk.mjs";
import { _ as __vitePreload } from "./preload-helper-C0h9nzpy.chunk.mjs";
import { g as getSharingToken } from "./public-BbQmCZDA.chunk.mjs";
import { g as getDefaultExportFromCjs } from "./_commonjsHelpers-s2JqeXRS.chunk.mjs";
import { l as logger$1 } from "./logger-27ZxKlei.chunk.mjs";
const _hoisted_1$k = ["aria-hidden", "aria-label"];
const _hoisted_2$e = {
  key: 0,
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_3$d = ["d"];
const _hoisted_4$b = ["innerHTML"];
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "NcIconSvgWrapper",
  props: {
    directional: { type: Boolean },
    inline: { type: Boolean },
    svg: { default: "" },
    name: { default: void 0 },
    path: { default: "" },
    size: { default: 20 }
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "4f0d35a8": iconSize.value
    }));
    const props = __props;
    const iconSize = computed(() => typeof props.size === "number" ? `${props.size}px` : props.size);
    const cleanSvg = computed(() => {
      if (!props.svg || props.path) {
        return;
      }
      const svg2 = purify.sanitize(props.svg);
      const svgDocument = new DOMParser().parseFromString(svg2, "image/svg+xml");
      if (svgDocument.querySelector("parsererror")) {
        warn("SVG is not valid");
        return "";
      }
      if (svgDocument.documentElement.id) {
        svgDocument.documentElement.removeAttribute("id");
      }
      return svgDocument.documentElement.outerHTML;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", {
        "aria-hidden": _ctx.name ? void 0 : "true",
        "aria-label": _ctx.name || void 0,
        class: normalizeClass(["icon-vue", {
          "icon-vue--directional": _ctx.directional,
          "icon-vue--inline": _ctx.inline
        }]),
        role: "img"
      }, [
        !cleanSvg.value ? (openBlock(), createElementBlock("svg", _hoisted_2$e, [
          createBaseVNode("path", { d: _ctx.path }, null, 8, _hoisted_3$d)
        ])) : (openBlock(), createElementBlock("span", {
          key: 1,
          innerHTML: cleanSvg.value
        }, null, 8, _hoisted_4$b))
      ], 10, _hoisted_1$k);
    };
  }
});
const NcIconSvgWrapper = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__scopeId", "data-v-0aa5a569"]]);
function dirname$1(path2) {
  return path2.replace(/\\/g, "/").replace(/\/[^\/]*$/, "");
}
function joinPaths(...args) {
  if (arguments.length < 1) {
    return "";
  }
  const nonEmptyArgs = args.filter((arg) => arg.length > 0);
  if (nonEmptyArgs.length < 1) {
    return "";
  }
  const lastArg = nonEmptyArgs[nonEmptyArgs.length - 1];
  const leadingSlash = nonEmptyArgs[0].charAt(0) === "/";
  const trailingSlash = lastArg.charAt(lastArg.length - 1) === "/";
  const sections = nonEmptyArgs.reduce((acc, section) => acc.concat(section.split("/")), []);
  let first = !leadingSlash;
  const path2 = sections.reduce((acc, section) => {
    if (section === "") {
      return acc;
    }
    if (first) {
      first = false;
      return acc + section;
    }
    return acc + "/" + section;
  }, "");
  if (trailingSlash) {
    return path2 + "/";
  }
  return path2;
}
function isSamePath(path1, path2) {
  const pathSections1 = (path1 || "").split("/").filter((p) => p !== ".");
  const pathSections2 = (path2 || "").split("/").filter((p) => p !== ".");
  path1 = joinPaths.apply(void 0, pathSections1);
  path2 = joinPaths.apply(void 0, pathSections2);
  return path1 === path2;
}
var mdiArrowRight = "M4,11V13H16L10.5,18.5L11.92,19.92L19.84,12L11.92,4.08L10.5,5.5L16,11H4Z";
var mdiCheck = "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z";
var mdiChevronRight = "M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z";
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var momentWithLocales$1 = { exports: {} };
var momentWithLocales = momentWithLocales$1.exports;
var hasRequiredMomentWithLocales;
function requireMomentWithLocales() {
  if (hasRequiredMomentWithLocales) return momentWithLocales$1.exports;
  hasRequiredMomentWithLocales = 1;
  (function(module, exports) {
    (function(global, factory) {
      module.exports = factory();
    })(momentWithLocales, function() {
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject2(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map2(arr, fn) {
        var res = [], i, arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend2(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format2, locale3, strict) {
        return createLocalOrUTC(input, format2, locale3, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m2) {
        if (m2._pf == null) {
          m2._pf = defaultParsingFlags();
        }
        return m2._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t4 = Object(this), len = t4.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t4 && fun.call(this, t4[i], i, t4)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m2) {
        var flags = null, parsedParts = false, isNowValid = m2._d && !isNaN(m2._d.getTime());
        if (isNowValid) {
          flags = getParsingFlags(m2);
          parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          });
          isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m2._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
        }
        if (Object.isFrozen == null || !Object.isFrozen(m2)) {
          m2._isValid = isNowValid;
        } else {
          return isNowValid;
        }
        return m2._isValid;
      }
      function createInvalid(flags) {
        var m2 = createUTC(NaN);
        if (flags != null) {
          extend2(getParsingFlags(m2), flags);
        } else {
          getParsingFlags(m2).userInvalidated = true;
        }
        return m2;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i = 0; i < momentPropertiesLen; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = /* @__PURE__ */ new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn2(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend2(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key, argLen = arguments.length;
            for (i = 0; i < argLen; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn2(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name2, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name2, msg);
        }
        if (!deprecations[name2]) {
          warn2(msg);
          deprecations[name2] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend2({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject2(parentConfig[prop]) && isObject2(childConfig[prop])) {
              res[prop] = {};
              extend2(res[prop], parentConfig[prop]);
              extend2(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject2(parentConfig[prop])) {
            res[prop] = extend2({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys2;
      if (Object.keys) {
        keys2 = Object.keys;
      } else {
        keys2 = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now2) : output;
      }
      function zeroFill(number2, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number2), zerosToFill = targetLength - absNumber.length, sign2 = number2 >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
          }
          return output;
        };
      }
      function formatMoment(m2, format2) {
        if (!m2.isValid()) {
          return m2.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m2.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m2);
      }
      function expandFormat(format2, locale3) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale3.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number2) {
        return this._ordinal.replace("%d", number2);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number2, withoutSuffix, string2, isFuture) {
        var output = this._relativeTime[string2];
        return isFunction(output) ? output(number2, withoutSuffix, string2, isFuture) : output.replace(/%d/i, number2);
      }
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {
        D: "date",
        dates: "date",
        date: "date",
        d: "day",
        days: "day",
        day: "day",
        e: "weekday",
        weekdays: "weekday",
        weekday: "weekday",
        E: "isoWeekday",
        isoweekdays: "isoWeekday",
        isoweekday: "isoWeekday",
        DDD: "dayOfYear",
        dayofyears: "dayOfYear",
        dayofyear: "dayOfYear",
        h: "hour",
        hours: "hour",
        hour: "hour",
        ms: "millisecond",
        milliseconds: "millisecond",
        millisecond: "millisecond",
        m: "minute",
        minutes: "minute",
        minute: "minute",
        M: "month",
        months: "month",
        month: "month",
        Q: "quarter",
        quarters: "quarter",
        quarter: "quarter",
        s: "second",
        seconds: "second",
        second: "second",
        gg: "weekYear",
        weekyears: "weekYear",
        weekyear: "weekYear",
        GG: "isoWeekYear",
        isoweekyears: "isoWeekYear",
        isoweekyear: "isoWeekYear",
        w: "week",
        weeks: "week",
        week: "week",
        W: "isoWeek",
        isoweeks: "isoWeek",
        isoweek: "isoWeek",
        y: "year",
        years: "year",
        year: "year"
      };
      function normalizeUnits(units2) {
        return typeof units2 === "string" ? aliases[units2] || aliases[units2.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {
        date: 9,
        day: 11,
        weekday: 11,
        isoWeekday: 11,
        dayOfYear: 4,
        hour: 13,
        millisecond: 16,
        minute: 14,
        month: 8,
        quarter: 7,
        second: 15,
        weekYear: 1,
        isoWeekYear: 1,
        week: 5,
        isoWeek: 5,
        year: 1
      };
      function getPrioritizedUnits(unitsObj) {
        var units2 = [], u2;
        for (u2 in unitsObj) {
          if (hasOwnProp(unitsObj, u2)) {
            units2.push({ unit: u2, priority: priorities[u2] });
          }
        }
        units2.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units2;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(
          s.replace("\\", "").replace(
            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
            }
          )
        );
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      function absFloor(number2) {
        if (number2 < 0) {
          return Math.ceil(number2) || 0;
        } else {
          return Math.floor(number2);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i = 0; i < tokenLen; i++) {
          tokens[token2[i]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      var YEAR = 0, MONTH = 1, DATE2 = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      function get(mom, unit) {
        if (!mom.isValid()) {
          return NaN;
        }
        var d = mom._d, isUTC = mom._isUTC;
        switch (unit) {
          case "Milliseconds":
            return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
          case "Seconds":
            return isUTC ? d.getUTCSeconds() : d.getSeconds();
          case "Minutes":
            return isUTC ? d.getUTCMinutes() : d.getMinutes();
          case "Hours":
            return isUTC ? d.getUTCHours() : d.getHours();
          case "Date":
            return isUTC ? d.getUTCDate() : d.getDate();
          case "Day":
            return isUTC ? d.getUTCDay() : d.getDay();
          case "Month":
            return isUTC ? d.getUTCMonth() : d.getMonth();
          case "FullYear":
            return isUTC ? d.getUTCFullYear() : d.getFullYear();
          default:
            return NaN;
        }
      }
      function set$1(mom, unit, value) {
        var d, isUTC, year, month, date;
        if (!mom.isValid() || isNaN(value)) {
          return;
        }
        d = mom._d;
        isUTC = mom._isUTC;
        switch (unit) {
          case "Milliseconds":
            return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
          case "Seconds":
            return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
          case "Minutes":
            return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
          case "Hours":
            return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
          case "Date":
            return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
          // case 'Day': // Not real
          //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
          // case 'Month': // Not used because we need to pass two variables
          //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
          case "FullYear":
            break;
          // See below ...
          default:
            return;
        }
        year = value;
        month = mom.month();
        date = mom.date();
        date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
        void (isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date));
      }
      function stringGet(units2) {
        units2 = normalizeUnits(units2);
        if (isFunction(this[units2])) {
          return this[units2]();
        }
        return this;
      }
      function stringSet(units2, value) {
        if (typeof units2 === "object") {
          units2 = normalizeObjectUnits(units2);
          var prioritized = getPrioritizedUnits(units2), i, prioritizedLen = prioritized.length;
          for (i = 0; i < prioritizedLen; i++) {
            this[prioritized[i].unit](units2[prioritized[i].unit]);
          }
        } else {
          units2 = normalizeUnits(units2);
          if (isFunction(this[units2])) {
            return this[units2](value);
          }
        }
        return this;
      }
      function mod(n, x2) {
        return (n % x2 + x2) % x2;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addRegexToken("M", match1to2, match1to2NoLeadingZero);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale3) {
        return locale3.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale3) {
        return locale3.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m2, format2) {
        if (!m2) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m2.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m2.month()];
      }
      function localeMonthsShort(m2, format2) {
        if (!m2) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m2.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m2.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        var month = value, date = mom.date();
        date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
        void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortP = regexEscape(this.monthsShort(mom, ""));
          longP = regexEscape(this.months(mom, ""));
          shortPieces.push(shortP);
          longPieces.push(longP);
          mixedPieces.push(longP);
          mixedPieces.push(shortP);
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      function createDate(y, m2, d, h2, M2, s, ms2) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m2, d, h2, M2, s, ms2);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m2, d, h2, M2, s, ms2);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week2, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week2 - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week2 = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week2 < 1) {
          resYear = mom.year() - 1;
          resWeek = week2 + weeksInYear(resYear, dow, doy);
        } else if (week2 > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week2 - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week2;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addRegexToken("w", match1to2, match1to2NoLeadingZero);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2, match1to2NoLeadingZero);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(
        ["w", "ww", "W", "WW"],
        function(input, week2, config, token2) {
          week2[token2.substr(0, 1)] = toInt(input);
        }
      );
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week2 = this.localeData().week(this);
        return input == null ? week2 : this.add((input - week2) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week2 = weekOfYear(this, 1, 4).week;
        return input == null ? week2 : this.add((input - week2) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale3) {
        return locale3.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale3) {
        return locale3.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale3) {
        return locale3.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week2, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week2.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week2, config, token2) {
        week2[token2] = toInt(input);
      });
      function parseWeekday(input, locale3) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale3.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale3) {
        if (typeof input === "string") {
          return locale3.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m2, format2) {
        var weekdays2 = isArray(this._weekdays) ? this._weekdays : this._weekdays[m2 && m2 !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m2 === true ? shiftWeekdays(weekdays2, this._week.dow) : m2 ? weekdays2[m2.day()] : weekdays2;
      }
      function localeWeekdaysShort(m2) {
        return m2 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m2 ? this._weekdaysShort[m2.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m2) {
        return m2 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m2 ? this._weekdaysMin[m2.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = get(this, "Day");
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      function matchMeridiem(isStrict, locale3) {
        return locale3._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2, match1to2HasZero);
      addRegexToken("h", match1to2, match1to2NoLeadingZero);
      addRegexToken("k", match1to2, match1to2NoLeadingZero);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale3, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale3 = loadLocale(split.slice(0, j).join("-"));
            if (locale3) {
              return locale3;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name2) {
        return !!(name2 && name2.match("^[^/\\\\]*$"));
      }
      function loadLocale(name2) {
        var oldLocale = null, aliasedRequire;
        if (locales[name2] === void 0 && true && module && module.exports && isLocaleNameSane(name2)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = commonjsRequire;
            aliasedRequire("./locale/" + name2);
            getSetGlobalLocale(oldLocale);
          } catch (e2) {
            locales[name2] = null;
          }
        }
        return locales[name2];
      }
      function getSetGlobalLocale(key, values2) {
        var data;
        if (key) {
          if (isUndefined(values2)) {
            data = getLocale2(key);
          } else {
            data = defineLocale(key, values2);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name2, config) {
        if (config !== null) {
          var locale3, parentConfig = baseConfig;
          config.abbr = name2;
          if (locales[name2] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name2]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale3 = loadLocale(config.parentLocale);
              if (locale3 != null) {
                parentConfig = locale3._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name: name2,
                  config
                });
                return null;
              }
            }
          }
          locales[name2] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name2]) {
            localeFamilies[name2].forEach(function(x2) {
              defineLocale(x2.name, x2.config);
            });
          }
          getSetGlobalLocale(name2);
          return locales[name2];
        } else {
          delete locales[name2];
          return null;
        }
      }
      function updateLocale(name2, config) {
        if (config != null) {
          var locale3, tmpLocale, parentConfig = baseConfig;
          if (locales[name2] != null && locales[name2].parentLocale != null) {
            locales[name2].set(mergeConfigs(locales[name2]._config, config));
          } else {
            tmpLocale = loadLocale(name2);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name2;
            }
            locale3 = new Locale(config);
            locale3.parentLocale = locales[name2];
            locales[name2] = locale3;
          }
          getSetGlobalLocale(name2);
        } else {
          if (locales[name2] != null) {
            if (locales[name2].parentLocale != null) {
              locales[name2] = locales[name2].parentLocale;
              if (name2 === getSetGlobalLocale()) {
                getSetGlobalLocale(name2);
              }
            } else if (locales[name2] != null) {
              delete locales[name2];
            }
          }
        }
        return locales[name2];
      }
      function getLocale2(key) {
        var locale3;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale3 = loadLocale(key);
          if (locale3) {
            return locale3;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys2(locales);
      }
      function checkOverflow(m2) {
        var overflow, a = m2._a;
        if (a && getParsingFlags(m2).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE2] < 1 || a[DATE2] > daysInMonth(a[YEAR], a[MONTH]) ? DATE2 : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m2)._overflowDayOfYear && (overflow < YEAR || overflow > DATE2)) {
            overflow = DATE2;
          }
          if (getParsingFlags(m2)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m2)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m2).overflow = overflow;
        }
        return m2;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string2 = config._i, match = extendedIsoRegex.exec(string2) || basicIsoRegex.exec(string2), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDatesLen; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimesLen; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m2 = hm % 100, h2 = (hm - m2) / 100;
          return h2 * 60 + m2;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = /* @__PURE__ */ new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE2] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE2] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w2, weekYear, week2, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w2 = config._w;
        if (w2.GG != null || w2.W != null || w2.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(
            w2.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week2 = defaults(w2.W, 1);
          weekday = defaults(w2.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w2.gg, config._a[YEAR], curWeek.year);
          week2 = defaults(w2.w, curWeek.week);
          if (w2.d != null) {
            weekday = w2.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w2.e != null) {
            weekday = w2.e + dow;
            if (w2.e < 0 || w2.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week2 < 1 || week2 > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week2, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string2 = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string2.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i = 0; i < tokenLen; i++) {
          token2 = tokens2[i];
          parsedInput = (string2.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string2.substr(0, string2.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string2 = string2.slice(
              string2.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string2.length > 0) {
          getParsingFlags(config).unusedInput.push(string2);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale3, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale3.meridiemHour != null) {
          return locale3.meridiemHour(hour, meridiem2);
        } else if (locale3.isPM != null) {
          isPm = locale3.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = /* @__PURE__ */ new Date(NaN);
          return;
        }
        for (i = 0; i < configfLen; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend2(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map2(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale2(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map2(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject2(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format2, locale3, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale3 === true || locale3 === false) {
          strict = locale3;
          locale3 = void 0;
        }
        if (isObject2(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale3;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format2, locale3, strict) {
        return createLocalOrUTC(input, format2, locale3, strict, false);
      }
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m2) {
        var key, unitHasDecimal = false, i, orderLen = ordering.length;
        for (key in m2) {
          if (hasOwnProp(m2, key) && !(indexOf.call(ordering, key) !== -1 && (m2[key] == null || !isNaN(m2[key])))) {
            return false;
          }
        }
        for (i = 0; i < orderLen; ++i) {
          if (m2[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m2[ordering[i]]) !== toInt(m2[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale2();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number2) {
        if (number2 < 0) {
          return Math.round(-1 * number2) * -1;
        } else {
          return Math.round(number2);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string2) {
        var matches = (string2 || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m2) {
        return -Math.round(m2._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE2]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name2) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name2,
              "moment()." + name2 + "(period, number) is deprecated. Please use moment()." + name2 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property, propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now2))
        );
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units2) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units2 = normalizeUnits(units2) || "millisecond";
        if (units2 === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units2).valueOf();
        }
      }
      function isBefore(input, units2) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units2 = normalizeUnits(units2) || "millisecond";
        if (units2 === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units2).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units2, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units2) : !this.isBefore(localFrom, units2)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units2) : !this.isAfter(localTo, units2));
      }
      function isSame(input, units2) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units2 = normalizeUnits(units2) || "millisecond";
        if (units2 === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units2).valueOf() <= inputMs && inputMs <= this.clone().endOf(units2).valueOf();
        }
      }
      function isSameOrAfter(input, units2) {
        return this.isSame(input, units2) || this.isAfter(input, units2);
      }
      function isSameOrBefore(input, units2) {
        return this.isSame(input, units2) || this.isBefore(input, units2);
      }
      function diff(input, units2, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units2 = normalizeUnits(units2);
        switch (units2) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          // 1000
          case "minute":
            output = (this - that) / 6e4;
            break;
          // 1000 * 60
          case "hour":
            output = (this - that) / 36e5;
            break;
          // 1000 * 60 * 60
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          // 1000 * 60 * 60 * 24, negate dst
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          // 1000 * 60 * 60 * 24 * 7, negate dst
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString2() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m2 = utc ? this.clone().utc() : this;
        if (m2.year() < 0 || m2.year() > 9999) {
          return formatMoment(
            m2,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m2, "Z"));
          }
        }
        return formatMoment(
          m2,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale2(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale2(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m2, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m2, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m2, d).valueOf();
        }
      }
      function utcStartOfDate(y, m2, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m2, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m2, d);
        }
      }
      function startOf(units2) {
        var time, startOfDate;
        units2 = normalizeUnits(units2);
        if (units2 === void 0 || units2 === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units2) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units2) {
        var time, startOfDate;
        units2 = normalizeUnits(units2);
        if (units2 === void 0 || units2 === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units2) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray2() {
        var m2 = this;
        return [
          m2.year(),
          m2.month(),
          m2.date(),
          m2.hour(),
          m2.minute(),
          m2.second(),
          m2.millisecond()
        ];
      }
      function toObject() {
        var m2 = this;
        return {
          years: m2.year(),
          months: m2.month(),
          date: m2.date(),
          hours: m2.hours(),
          minutes: m2.minutes(),
          seconds: m2.seconds(),
          milliseconds: m2.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend2({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(
        ["N", "NN", "NNN", "NNNN", "NNNNN"],
        function(input, array, config, token2) {
          var era = config._locale.erasParse(input, token2, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        }
      );
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m2, format2) {
        var i, l, date, eras = this._eras || getLocale2("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format2, strict) {
        var i, l, eras = this.eras(), name2, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name2 = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name2 === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name2, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale3) {
        return locale3.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale3) {
        return locale3.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale3) {
        return locale3.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale3) {
        return locale3._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          erasName = regexEscape(eras[i].name);
          erasAbbr = regexEscape(eras[i].abbr);
          erasNarrow = regexEscape(eras[i].narrow);
          namePieces.push(erasName);
          abbrPieces.push(erasAbbr);
          narrowPieces.push(erasNarrow);
          mixedPieces.push(erasName);
          mixedPieces.push(erasAbbr);
          mixedPieces.push(erasNarrow);
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(
        ["gggg", "ggggg", "GGGG", "GGGGG"],
        function(input, week2, config, token2) {
          week2[token2.substr(0, 2)] = toInt(input);
        }
      );
      addWeekParseToken(["gg", "GG"], function(input, week2, config, token2) {
        week2[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday() + this.localeData()._week.dow,
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week2, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week2 > weeksTarget) {
            week2 = weeksTarget;
          }
          return setWeekAll.call(this, input, week2, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week2, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week2, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addRegexToken("D", match1to2, match1to2NoLeadingZero);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale3) {
        return isStrict ? locale3._dayOfMonthOrdinalParse || locale3._ordinalParse : locale3._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE2);
      addParseToken("Do", function(input, array) {
        array[DATE2] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addRegexToken("m", match1to2, match1to2HasZero);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addRegexToken("s", match1to2, match1to2HasZero);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale2;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray2;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString2;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string2) {
        return string2;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index2, field, setter) {
        var locale3 = getLocale2(), utc = createUTC().set(setter, index2);
        return locale3[field](utc, format2);
      }
      function listMonthsImpl(format2, index2, field) {
        if (isNumber(format2)) {
          index2 = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index2 != null) {
          return get$1(format2, index2, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index2, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format2)) {
            index2 = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index2 = format2;
          localeSorted = false;
          if (isNumber(format2)) {
            index2 = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale3 = getLocale2(), shift = localeSorted ? locale3._week.dow : 0, i, out = [];
        if (index2 != null) {
          return get$1(format2, (index2 + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index2) {
        return listMonthsImpl(format2, index2, "months");
      }
      function listMonthsShort(format2, index2) {
        return listMonthsImpl(format2, index2, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index2) {
        return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index2) {
        return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index2) {
        return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number2) {
          var b = number2 % 10, output = toInt(number2 % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number2 + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale2
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number2) {
        if (number2 < 0) {
          return Math.floor(number2);
        } else {
          return Math.ceil(number2);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units2) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units2 = normalizeUnits(units2);
        if (units2 === "month" || units2 === "quarter" || units2 === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units2) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units2) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            // Math.floor prevents floating point math errors here
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units2);
          }
        }
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units2) {
        units2 = normalizeUnits(units2);
        return this.isValid() ? this[units2 + "s"]() : NaN;
      }
      function makeGetter(name2) {
        return function() {
          return this.isValid() ? this._data[name2] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string2, number2, withoutSuffix, isFuture, locale3) {
        return locale3.relativeTime(number2 || 1, !!withoutSuffix, string2, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale3) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale3;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale3, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale3 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale3);
        if (withSuffix) {
          output = locale3.pastFuture(+this, output);
        }
        return locale3.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x2) {
        return (x2 > 0) - (x2 < 0) || +x2;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale2;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      //! moment.js
      hooks.version = "2.30.1";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale2;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      //! moment.js locale configuration
      hooks.defineLocale("af", {
        months: "Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split(
          "_"
        ),
        monthsShort: "Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"),
        weekdays: "Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split(
          "_"
        ),
        weekdaysShort: "Son_Maa_Din_Woe_Don_Vry_Sat".split("_"),
        weekdaysMin: "So_Ma_Di_Wo_Do_Vr_Sa".split("_"),
        meridiemParse: /vm|nm/i,
        isPM: function(input) {
          return /^nm$/i.test(input);
        },
        meridiem: function(hours2, minutes2, isLower) {
          if (hours2 < 12) {
            return isLower ? "vm" : "VM";
          } else {
            return isLower ? "nm" : "NM";
          }
        },
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Vandag om] LT",
          nextDay: "[MÃ´re om] LT",
          nextWeek: "dddd [om] LT",
          lastDay: "[Gister om] LT",
          lastWeek: "[Laas] dddd [om] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "oor %s",
          past: "%s gelede",
          s: "'n paar sekondes",
          ss: "%d sekondes",
          m: "'n minuut",
          mm: "%d minute",
          h: "'n uur",
          hh: "%d ure",
          d: "'n dag",
          dd: "%d dae",
          M: "'n maand",
          MM: "%d maande",
          y: "'n jaar",
          yy: "%d jaar"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function(number2) {
          return number2 + (number2 === 1 || number2 === 8 || number2 >= 20 ? "ste" : "de");
        },
        week: {
          dow: 1,
          // Maandag is die eerste dag van die week.
          doy: 4
          // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
        }
      });
      //! moment.js locale configuration
      var pluralForm = function(n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
      }, plurals = {
        s: [
          "Ø£Ù‚Ù„ Ù…Ù† Ø«Ø§Ù†ÙŠØ©",
          "Ø«Ø§Ù†ÙŠØ© ÙˆØ§Ø­Ø¯Ø©",
          ["Ø«Ø§Ù†ÙŠØªØ§Ù†", "Ø«Ø§Ù†ÙŠØªÙŠÙ†"],
          "%d Ø«ÙˆØ§Ù†",
          "%d Ø«Ø§Ù†ÙŠØ©",
          "%d Ø«Ø§Ù†ÙŠØ©"
        ],
        m: [
          "Ø£Ù‚Ù„ Ù…Ù† Ø¯Ù‚ÙŠÙ‚Ø©",
          "Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ø­Ø¯Ø©",
          ["Ø¯Ù‚ÙŠÙ‚ØªØ§Ù†", "Ø¯Ù‚ÙŠÙ‚ØªÙŠÙ†"],
          "%d Ø¯Ù‚Ø§Ø¦Ù‚",
          "%d Ø¯Ù‚ÙŠÙ‚Ø©",
          "%d Ø¯Ù‚ÙŠÙ‚Ø©"
        ],
        h: [
          "Ø£Ù‚Ù„ Ù…Ù† Ø³Ø§Ø¹Ø©",
          "Ø³Ø§Ø¹Ø© ÙˆØ§Ø­Ø¯Ø©",
          ["Ø³Ø§Ø¹ØªØ§Ù†", "Ø³Ø§Ø¹ØªÙŠÙ†"],
          "%d Ø³Ø§Ø¹Ø§Øª",
          "%d Ø³Ø§Ø¹Ø©",
          "%d Ø³Ø§Ø¹Ø©"
        ],
        d: [
          "Ø£Ù‚Ù„ Ù…Ù† ÙŠÙˆÙ…",
          "ÙŠÙˆÙ… ÙˆØ§Ø­Ø¯",
          ["ÙŠÙˆÙ…Ø§Ù†", "ÙŠÙˆÙ…ÙŠÙ†"],
          "%d Ø£ÙŠØ§Ù…",
          "%d ÙŠÙˆÙ…Ù‹Ø§",
          "%d ÙŠÙˆÙ…"
        ],
        M: [
          "Ø£Ù‚Ù„ Ù…Ù† Ø´Ù‡Ø±",
          "Ø´Ù‡Ø± ÙˆØ§Ø­Ø¯",
          ["Ø´Ù‡Ø±Ø§Ù†", "Ø´Ù‡Ø±ÙŠÙ†"],
          "%d Ø£Ø´Ù‡Ø±",
          "%d Ø´Ù‡Ø±Ø§",
          "%d Ø´Ù‡Ø±"
        ],
        y: [
          "Ø£Ù‚Ù„ Ù…Ù† Ø¹Ø§Ù…",
          "Ø¹Ø§Ù… ÙˆØ§Ø­Ø¯",
          ["Ø¹Ø§Ù…Ø§Ù†", "Ø¹Ø§Ù…ÙŠÙ†"],
          "%d Ø£Ø¹ÙˆØ§Ù…",
          "%d Ø¹Ø§Ù…Ù‹Ø§",
          "%d Ø¹Ø§Ù…"
        ]
      }, pluralize = function(u2) {
        return function(number2, withoutSuffix, string2, isFuture) {
          var f2 = pluralForm(number2), str = plurals[u2][pluralForm(number2)];
          if (f2 === 2) {
            str = str[withoutSuffix ? 0 : 1];
          }
          return str.replace(/%d/i, number2);
        };
      }, months$1 = [
        "Ø¬Ø§Ù†ÙÙŠ",
        "ÙÙŠÙØ±ÙŠ",
        "Ù…Ø§Ø±Ø³",
        "Ø£ÙØ±ÙŠÙ„",
        "Ù…Ø§ÙŠ",
        "Ø¬ÙˆØ§Ù†",
        "Ø¬ÙˆÙŠÙ„ÙŠØ©",
        "Ø£ÙˆØª",
        "Ø³Ø¨ØªÙ…Ø¨Ø±",
        "Ø£ÙƒØªÙˆØ¨Ø±",
        "Ù†ÙˆÙÙ…Ø¨Ø±",
        "Ø¯ÙŠØ³Ù…Ø¨Ø±"
      ];
      hooks.defineLocale("ar-dz", {
        months: months$1,
        monthsShort: months$1,
        weekdays: "Ø§Ù„Ø£Ø­Ø¯_Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†_Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡_Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø§Ù„Ø®Ù…ÙŠØ³_Ø§Ù„Ø¬Ù…Ø¹Ø©_Ø§Ù„Ø³Ø¨Øª".split("_"),
        weekdaysShort: "Ø£Ø­Ø¯_Ø¥Ø«Ù†ÙŠÙ†_Ø«Ù„Ø§Ø«Ø§Ø¡_Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø®Ù…ÙŠØ³_Ø¬Ù…Ø¹Ø©_Ø³Ø¨Øª".split("_"),
        weekdaysMin: "Ø­_Ù†_Ø«_Ø±_Ø®_Ø¬_Ø³".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "D/â€M/â€YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /Øµ|Ù…/,
        isPM: function(input) {
          return "Ù…" === input;
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 12) {
            return "Øµ";
          } else {
            return "Ù…";
          }
        },
        calendar: {
          sameDay: "[Ø§Ù„ÙŠÙˆÙ… Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          nextDay: "[ØºØ¯Ù‹Ø§ Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          nextWeek: "dddd [Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          lastDay: "[Ø£Ù…Ø³ Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          lastWeek: "dddd [Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "Ø¨Ø¹Ø¯ %s",
          past: "Ù…Ù†Ø° %s",
          s: pluralize("s"),
          ss: pluralize("s"),
          m: pluralize("m"),
          mm: pluralize("m"),
          h: pluralize("h"),
          hh: pluralize("h"),
          d: pluralize("d"),
          dd: pluralize("d"),
          M: pluralize("M"),
          MM: pluralize("M"),
          y: pluralize("y"),
          yy: pluralize("y")
        },
        postformat: function(string2) {
          return string2.replace(/,/g, "ØŒ");
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("ar-kw", {
        months: "ÙŠÙ†Ø§ÙŠØ±_ÙØ¨Ø±Ø§ÙŠØ±_Ù…Ø§Ø±Ø³_Ø£Ø¨Ø±ÙŠÙ„_Ù…Ø§ÙŠ_ÙŠÙˆÙ†ÙŠÙˆ_ÙŠÙˆÙ„ÙŠÙˆØ²_ØºØ´Øª_Ø´ØªÙ†Ø¨Ø±_Ø£ÙƒØªÙˆØ¨Ø±_Ù†ÙˆÙ†Ø¨Ø±_Ø¯Ø¬Ù†Ø¨Ø±".split(
          "_"
        ),
        monthsShort: "ÙŠÙ†Ø§ÙŠØ±_ÙØ¨Ø±Ø§ÙŠØ±_Ù…Ø§Ø±Ø³_Ø£Ø¨Ø±ÙŠÙ„_Ù…Ø§ÙŠ_ÙŠÙˆÙ†ÙŠÙˆ_ÙŠÙˆÙ„ÙŠÙˆØ²_ØºØ´Øª_Ø´ØªÙ†Ø¨Ø±_Ø£ÙƒØªÙˆØ¨Ø±_Ù†ÙˆÙ†Ø¨Ø±_Ø¯Ø¬Ù†Ø¨Ø±".split(
          "_"
        ),
        weekdays: "Ø§Ù„Ø£Ø­Ø¯_Ø§Ù„Ø¥ØªÙ†ÙŠÙ†_Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡_Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø§Ù„Ø®Ù…ÙŠØ³_Ø§Ù„Ø¬Ù…Ø¹Ø©_Ø§Ù„Ø³Ø¨Øª".split("_"),
        weekdaysShort: "Ø§Ø­Ø¯_Ø§ØªÙ†ÙŠÙ†_Ø«Ù„Ø§Ø«Ø§Ø¡_Ø§Ø±Ø¨Ø¹Ø§Ø¡_Ø®Ù…ÙŠØ³_Ø¬Ù…Ø¹Ø©_Ø³Ø¨Øª".split("_"),
        weekdaysMin: "Ø­_Ù†_Ø«_Ø±_Ø®_Ø¬_Ø³".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Ø§Ù„ÙŠÙˆÙ… Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          nextDay: "[ØºØ¯Ø§ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          nextWeek: "dddd [Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          lastDay: "[Ø£Ù…Ø³ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          lastWeek: "dddd [Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "ÙÙŠ %s",
          past: "Ù…Ù†Ø° %s",
          s: "Ø«ÙˆØ§Ù†",
          ss: "%d Ø«Ø§Ù†ÙŠØ©",
          m: "Ø¯Ù‚ÙŠÙ‚Ø©",
          mm: "%d Ø¯Ù‚Ø§Ø¦Ù‚",
          h: "Ø³Ø§Ø¹Ø©",
          hh: "%d Ø³Ø§Ø¹Ø§Øª",
          d: "ÙŠÙˆÙ…",
          dd: "%d Ø£ÙŠØ§Ù…",
          M: "Ø´Ù‡Ø±",
          MM: "%d Ø£Ø´Ù‡Ø±",
          y: "Ø³Ù†Ø©",
          yy: "%d Ø³Ù†ÙˆØ§Øª"
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 12
          // The week that contains Jan 12th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var symbolMap = {
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        0: "0"
      }, pluralForm$1 = function(n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
      }, plurals$1 = {
        s: [
          "Ø£Ù‚Ù„ Ù…Ù† Ø«Ø§Ù†ÙŠØ©",
          "Ø«Ø§Ù†ÙŠØ© ÙˆØ§Ø­Ø¯Ø©",
          ["Ø«Ø§Ù†ÙŠØªØ§Ù†", "Ø«Ø§Ù†ÙŠØªÙŠÙ†"],
          "%d Ø«ÙˆØ§Ù†",
          "%d Ø«Ø§Ù†ÙŠØ©",
          "%d Ø«Ø§Ù†ÙŠØ©"
        ],
        m: [
          "Ø£Ù‚Ù„ Ù…Ù† Ø¯Ù‚ÙŠÙ‚Ø©",
          "Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ø­Ø¯Ø©",
          ["Ø¯Ù‚ÙŠÙ‚ØªØ§Ù†", "Ø¯Ù‚ÙŠÙ‚ØªÙŠÙ†"],
          "%d Ø¯Ù‚Ø§Ø¦Ù‚",
          "%d Ø¯Ù‚ÙŠÙ‚Ø©",
          "%d Ø¯Ù‚ÙŠÙ‚Ø©"
        ],
        h: [
          "Ø£Ù‚Ù„ Ù…Ù† Ø³Ø§Ø¹Ø©",
          "Ø³Ø§Ø¹Ø© ÙˆØ§Ø­Ø¯Ø©",
          ["Ø³Ø§Ø¹ØªØ§Ù†", "Ø³Ø§Ø¹ØªÙŠÙ†"],
          "%d Ø³Ø§Ø¹Ø§Øª",
          "%d Ø³Ø§Ø¹Ø©",
          "%d Ø³Ø§Ø¹Ø©"
        ],
        d: [
          "Ø£Ù‚Ù„ Ù…Ù† ÙŠÙˆÙ…",
          "ÙŠÙˆÙ… ÙˆØ§Ø­Ø¯",
          ["ÙŠÙˆÙ…Ø§Ù†", "ÙŠÙˆÙ…ÙŠÙ†"],
          "%d Ø£ÙŠØ§Ù…",
          "%d ÙŠÙˆÙ…Ù‹Ø§",
          "%d ÙŠÙˆÙ…"
        ],
        M: [
          "Ø£Ù‚Ù„ Ù…Ù† Ø´Ù‡Ø±",
          "Ø´Ù‡Ø± ÙˆØ§Ø­Ø¯",
          ["Ø´Ù‡Ø±Ø§Ù†", "Ø´Ù‡Ø±ÙŠÙ†"],
          "%d Ø£Ø´Ù‡Ø±",
          "%d Ø´Ù‡Ø±Ø§",
          "%d Ø´Ù‡Ø±"
        ],
        y: [
          "Ø£Ù‚Ù„ Ù…Ù† Ø¹Ø§Ù…",
          "Ø¹Ø§Ù… ÙˆØ§Ø­Ø¯",
          ["Ø¹Ø§Ù…Ø§Ù†", "Ø¹Ø§Ù…ÙŠÙ†"],
          "%d Ø£Ø¹ÙˆØ§Ù…",
          "%d Ø¹Ø§Ù…Ù‹Ø§",
          "%d Ø¹Ø§Ù…"
        ]
      }, pluralize$1 = function(u2) {
        return function(number2, withoutSuffix, string2, isFuture) {
          var f2 = pluralForm$1(number2), str = plurals$1[u2][pluralForm$1(number2)];
          if (f2 === 2) {
            str = str[withoutSuffix ? 0 : 1];
          }
          return str.replace(/%d/i, number2);
        };
      }, months$2 = [
        "ÙŠÙ†Ø§ÙŠØ±",
        "ÙØ¨Ø±Ø§ÙŠØ±",
        "Ù…Ø§Ø±Ø³",
        "Ø£Ø¨Ø±ÙŠÙ„",
        "Ù…Ø§ÙŠÙˆ",
        "ÙŠÙˆÙ†ÙŠÙˆ",
        "ÙŠÙˆÙ„ÙŠÙˆ",
        "Ø£ØºØ³Ø·Ø³",
        "Ø³Ø¨ØªÙ…Ø¨Ø±",
        "Ø£ÙƒØªÙˆØ¨Ø±",
        "Ù†ÙˆÙÙ…Ø¨Ø±",
        "Ø¯ÙŠØ³Ù…Ø¨Ø±"
      ];
      hooks.defineLocale("ar-ly", {
        months: months$2,
        monthsShort: months$2,
        weekdays: "Ø§Ù„Ø£Ø­Ø¯_Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†_Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡_Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø§Ù„Ø®Ù…ÙŠØ³_Ø§Ù„Ø¬Ù…Ø¹Ø©_Ø§Ù„Ø³Ø¨Øª".split("_"),
        weekdaysShort: "Ø£Ø­Ø¯_Ø¥Ø«Ù†ÙŠÙ†_Ø«Ù„Ø§Ø«Ø§Ø¡_Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø®Ù…ÙŠØ³_Ø¬Ù…Ø¹Ø©_Ø³Ø¨Øª".split("_"),
        weekdaysMin: "Ø­_Ù†_Ø«_Ø±_Ø®_Ø¬_Ø³".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "D/â€M/â€YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /Øµ|Ù…/,
        isPM: function(input) {
          return "Ù…" === input;
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 12) {
            return "Øµ";
          } else {
            return "Ù…";
          }
        },
        calendar: {
          sameDay: "[Ø§Ù„ÙŠÙˆÙ… Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          nextDay: "[ØºØ¯Ù‹Ø§ Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          nextWeek: "dddd [Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          lastDay: "[Ø£Ù…Ø³ Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          lastWeek: "dddd [Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "Ø¨Ø¹Ø¯ %s",
          past: "Ù…Ù†Ø° %s",
          s: pluralize$1("s"),
          ss: pluralize$1("s"),
          m: pluralize$1("m"),
          mm: pluralize$1("m"),
          h: pluralize$1("h"),
          hh: pluralize$1("h"),
          d: pluralize$1("d"),
          dd: pluralize$1("d"),
          M: pluralize$1("M"),
          MM: pluralize$1("M"),
          y: pluralize$1("y"),
          yy: pluralize$1("y")
        },
        preparse: function(string2) {
          return string2.replace(/ØŒ/g, ",");
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap[match];
          }).replace(/,/g, "ØŒ");
        },
        week: {
          dow: 6,
          // Saturday is the first day of the week.
          doy: 12
          // The week that contains Jan 12th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("ar-ma", {
        months: "ÙŠÙ†Ø§ÙŠØ±_ÙØ¨Ø±Ø§ÙŠØ±_Ù…Ø§Ø±Ø³_Ø£Ø¨Ø±ÙŠÙ„_Ù…Ø§ÙŠ_ÙŠÙˆÙ†ÙŠÙˆ_ÙŠÙˆÙ„ÙŠÙˆØ²_ØºØ´Øª_Ø´ØªÙ†Ø¨Ø±_Ø£ÙƒØªÙˆØ¨Ø±_Ù†ÙˆÙ†Ø¨Ø±_Ø¯Ø¬Ù†Ø¨Ø±".split(
          "_"
        ),
        monthsShort: "ÙŠÙ†Ø§ÙŠØ±_ÙØ¨Ø±Ø§ÙŠØ±_Ù…Ø§Ø±Ø³_Ø£Ø¨Ø±ÙŠÙ„_Ù…Ø§ÙŠ_ÙŠÙˆÙ†ÙŠÙˆ_ÙŠÙˆÙ„ÙŠÙˆØ²_ØºØ´Øª_Ø´ØªÙ†Ø¨Ø±_Ø£ÙƒØªÙˆØ¨Ø±_Ù†ÙˆÙ†Ø¨Ø±_Ø¯Ø¬Ù†Ø¨Ø±".split(
          "_"
        ),
        weekdays: "Ø§Ù„Ø£Ø­Ø¯_Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†_Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡_Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø§Ù„Ø®Ù…ÙŠØ³_Ø§Ù„Ø¬Ù…Ø¹Ø©_Ø§Ù„Ø³Ø¨Øª".split("_"),
        weekdaysShort: "Ø§Ø­Ø¯_Ø§Ø«Ù†ÙŠÙ†_Ø«Ù„Ø§Ø«Ø§Ø¡_Ø§Ø±Ø¨Ø¹Ø§Ø¡_Ø®Ù…ÙŠØ³_Ø¬Ù…Ø¹Ø©_Ø³Ø¨Øª".split("_"),
        weekdaysMin: "Ø­_Ù†_Ø«_Ø±_Ø®_Ø¬_Ø³".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Ø§Ù„ÙŠÙˆÙ… Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          nextDay: "[ØºØ¯Ø§ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          nextWeek: "dddd [Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          lastDay: "[Ø£Ù…Ø³ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          lastWeek: "dddd [Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "ÙÙŠ %s",
          past: "Ù…Ù†Ø° %s",
          s: "Ø«ÙˆØ§Ù†",
          ss: "%d Ø«Ø§Ù†ÙŠØ©",
          m: "Ø¯Ù‚ÙŠÙ‚Ø©",
          mm: "%d Ø¯Ù‚Ø§Ø¦Ù‚",
          h: "Ø³Ø§Ø¹Ø©",
          hh: "%d Ø³Ø§Ø¹Ø§Øª",
          d: "ÙŠÙˆÙ…",
          dd: "%d Ø£ÙŠØ§Ù…",
          M: "Ø´Ù‡Ø±",
          MM: "%d Ø£Ø´Ù‡Ø±",
          y: "Ø³Ù†Ø©",
          yy: "%d Ø³Ù†ÙˆØ§Øª"
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var symbolMap$1 = {
        1: "Ù¡",
        2: "Ù¢",
        3: "Ù£",
        4: "Ù¤",
        5: "Ù¥",
        6: "Ù¦",
        7: "Ù§",
        8: "Ù¨",
        9: "Ù©",
        0: "Ù "
      }, numberMap = {
        "Ù¡": "1",
        "Ù¢": "2",
        "Ù£": "3",
        "Ù¤": "4",
        "Ù¥": "5",
        "Ù¦": "6",
        "Ù§": "7",
        "Ù¨": "8",
        "Ù©": "9",
        "Ù ": "0"
      };
      hooks.defineLocale("ar-ps", {
        months: "ÙƒØ§Ù†ÙˆÙ† Ø§Ù„Ø«Ø§Ù†ÙŠ_Ø´Ø¨Ø§Ø·_Ø¢Ø°Ø§Ø±_Ù†ÙŠØ³Ø§Ù†_Ø£ÙŠÙ‘Ø§Ø±_Ø­Ø²ÙŠØ±Ø§Ù†_ØªÙ…Ù‘ÙˆØ²_Ø¢Ø¨_Ø£ÙŠÙ„ÙˆÙ„_ØªØ´Ø±ÙŠ Ø§Ù„Ø£ÙˆÙ‘Ù„_ØªØ´Ø±ÙŠÙ† Ø§Ù„Ø«Ø§Ù†ÙŠ_ÙƒØ§Ù†ÙˆÙ† Ø§Ù„Ø£ÙˆÙ‘Ù„".split(
          "_"
        ),
        monthsShort: "ÙƒÙ¢_Ø´Ø¨Ø§Ø·_Ø¢Ø°Ø§Ø±_Ù†ÙŠØ³Ø§Ù†_Ø£ÙŠÙ‘Ø§Ø±_Ø­Ø²ÙŠØ±Ø§Ù†_ØªÙ…Ù‘ÙˆØ²_Ø¢Ø¨_Ø£ÙŠÙ„ÙˆÙ„_ØªÙ¡_ØªÙ¢_ÙƒÙ¡".split("_"),
        weekdays: "Ø§Ù„Ø£Ø­Ø¯_Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†_Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡_Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø§Ù„Ø®Ù…ÙŠØ³_Ø§Ù„Ø¬Ù…Ø¹Ø©_Ø§Ù„Ø³Ø¨Øª".split("_"),
        weekdaysShort: "Ø£Ø­Ø¯_Ø¥Ø«Ù†ÙŠÙ†_Ø«Ù„Ø§Ø«Ø§Ø¡_Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø®Ù…ÙŠØ³_Ø¬Ù…Ø¹Ø©_Ø³Ø¨Øª".split("_"),
        weekdaysMin: "Ø­_Ù†_Ø«_Ø±_Ø®_Ø¬_Ø³".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /Øµ|Ù…/,
        isPM: function(input) {
          return "Ù…" === input;
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 12) {
            return "Øµ";
          } else {
            return "Ù…";
          }
        },
        calendar: {
          sameDay: "[Ø§Ù„ÙŠÙˆÙ… Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          nextDay: "[ØºØ¯Ø§ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          nextWeek: "dddd [Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          lastDay: "[Ø£Ù…Ø³ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          lastWeek: "dddd [Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "ÙÙŠ %s",
          past: "Ù…Ù†Ø° %s",
          s: "Ø«ÙˆØ§Ù†",
          ss: "%d Ø«Ø§Ù†ÙŠØ©",
          m: "Ø¯Ù‚ÙŠÙ‚Ø©",
          mm: "%d Ø¯Ù‚Ø§Ø¦Ù‚",
          h: "Ø³Ø§Ø¹Ø©",
          hh: "%d Ø³Ø§Ø¹Ø§Øª",
          d: "ÙŠÙˆÙ…",
          dd: "%d Ø£ÙŠØ§Ù…",
          M: "Ø´Ù‡Ø±",
          MM: "%d Ø£Ø´Ù‡Ø±",
          y: "Ø³Ù†Ø©",
          yy: "%d Ø³Ù†ÙˆØ§Øª"
        },
        preparse: function(string2) {
          return string2.replace(/[Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©Ù ]/g, function(match) {
            return numberMap[match];
          }).split("").reverse().join("").replace(/[Ù¡Ù¢](?![\u062a\u0643])/g, function(match) {
            return numberMap[match];
          }).split("").reverse().join("").replace(/ØŒ/g, ",");
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap$1[match];
          }).replace(/,/g, "ØŒ");
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var symbolMap$2 = {
        1: "Ù¡",
        2: "Ù¢",
        3: "Ù£",
        4: "Ù¤",
        5: "Ù¥",
        6: "Ù¦",
        7: "Ù§",
        8: "Ù¨",
        9: "Ù©",
        0: "Ù "
      }, numberMap$1 = {
        "Ù¡": "1",
        "Ù¢": "2",
        "Ù£": "3",
        "Ù¤": "4",
        "Ù¥": "5",
        "Ù¦": "6",
        "Ù§": "7",
        "Ù¨": "8",
        "Ù©": "9",
        "Ù ": "0"
      };
      hooks.defineLocale("ar-sa", {
        months: "ÙŠÙ†Ø§ÙŠØ±_ÙØ¨Ø±Ø§ÙŠØ±_Ù…Ø§Ø±Ø³_Ø£Ø¨Ø±ÙŠÙ„_Ù…Ø§ÙŠÙˆ_ÙŠÙˆÙ†ÙŠÙˆ_ÙŠÙˆÙ„ÙŠÙˆ_Ø£ØºØ³Ø·Ø³_Ø³Ø¨ØªÙ…Ø¨Ø±_Ø£ÙƒØªÙˆØ¨Ø±_Ù†ÙˆÙÙ…Ø¨Ø±_Ø¯ÙŠØ³Ù…Ø¨Ø±".split(
          "_"
        ),
        monthsShort: "ÙŠÙ†Ø§ÙŠØ±_ÙØ¨Ø±Ø§ÙŠØ±_Ù…Ø§Ø±Ø³_Ø£Ø¨Ø±ÙŠÙ„_Ù…Ø§ÙŠÙˆ_ÙŠÙˆÙ†ÙŠÙˆ_ÙŠÙˆÙ„ÙŠÙˆ_Ø£ØºØ³Ø·Ø³_Ø³Ø¨ØªÙ…Ø¨Ø±_Ø£ÙƒØªÙˆØ¨Ø±_Ù†ÙˆÙÙ…Ø¨Ø±_Ø¯ÙŠØ³Ù…Ø¨Ø±".split(
          "_"
        ),
        weekdays: "Ø§Ù„Ø£Ø­Ø¯_Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†_Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡_Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø§Ù„Ø®Ù…ÙŠØ³_Ø§Ù„Ø¬Ù…Ø¹Ø©_Ø§Ù„Ø³Ø¨Øª".split("_"),
        weekdaysShort: "Ø£Ø­Ø¯_Ø¥Ø«Ù†ÙŠÙ†_Ø«Ù„Ø§Ø«Ø§Ø¡_Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø®Ù…ÙŠØ³_Ø¬Ù…Ø¹Ø©_Ø³Ø¨Øª".split("_"),
        weekdaysMin: "Ø­_Ù†_Ø«_Ø±_Ø®_Ø¬_Ø³".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /Øµ|Ù…/,
        isPM: function(input) {
          return "Ù…" === input;
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 12) {
            return "Øµ";
          } else {
            return "Ù…";
          }
        },
        calendar: {
          sameDay: "[Ø§Ù„ÙŠÙˆÙ… Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          nextDay: "[ØºØ¯Ø§ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          nextWeek: "dddd [Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          lastDay: "[Ø£Ù…Ø³ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          lastWeek: "dddd [Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "ÙÙŠ %s",
          past: "Ù…Ù†Ø° %s",
          s: "Ø«ÙˆØ§Ù†",
          ss: "%d Ø«Ø§Ù†ÙŠØ©",
          m: "Ø¯Ù‚ÙŠÙ‚Ø©",
          mm: "%d Ø¯Ù‚Ø§Ø¦Ù‚",
          h: "Ø³Ø§Ø¹Ø©",
          hh: "%d Ø³Ø§Ø¹Ø§Øª",
          d: "ÙŠÙˆÙ…",
          dd: "%d Ø£ÙŠØ§Ù…",
          M: "Ø´Ù‡Ø±",
          MM: "%d Ø£Ø´Ù‡Ø±",
          y: "Ø³Ù†Ø©",
          yy: "%d Ø³Ù†ÙˆØ§Øª"
        },
        preparse: function(string2) {
          return string2.replace(/[Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©Ù ]/g, function(match) {
            return numberMap$1[match];
          }).replace(/ØŒ/g, ",");
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap$2[match];
          }).replace(/,/g, "ØŒ");
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("ar-tn", {
        months: "Ø¬Ø§Ù†ÙÙŠ_ÙÙŠÙØ±ÙŠ_Ù…Ø§Ø±Ø³_Ø£ÙØ±ÙŠÙ„_Ù…Ø§ÙŠ_Ø¬ÙˆØ§Ù†_Ø¬ÙˆÙŠÙ„ÙŠØ©_Ø£ÙˆØª_Ø³Ø¨ØªÙ…Ø¨Ø±_Ø£ÙƒØªÙˆØ¨Ø±_Ù†ÙˆÙÙ…Ø¨Ø±_Ø¯ÙŠØ³Ù…Ø¨Ø±".split(
          "_"
        ),
        monthsShort: "Ø¬Ø§Ù†ÙÙŠ_ÙÙŠÙØ±ÙŠ_Ù…Ø§Ø±Ø³_Ø£ÙØ±ÙŠÙ„_Ù…Ø§ÙŠ_Ø¬ÙˆØ§Ù†_Ø¬ÙˆÙŠÙ„ÙŠØ©_Ø£ÙˆØª_Ø³Ø¨ØªÙ…Ø¨Ø±_Ø£ÙƒØªÙˆØ¨Ø±_Ù†ÙˆÙÙ…Ø¨Ø±_Ø¯ÙŠØ³Ù…Ø¨Ø±".split(
          "_"
        ),
        weekdays: "Ø§Ù„Ø£Ø­Ø¯_Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†_Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡_Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø§Ù„Ø®Ù…ÙŠØ³_Ø§Ù„Ø¬Ù…Ø¹Ø©_Ø§Ù„Ø³Ø¨Øª".split("_"),
        weekdaysShort: "Ø£Ø­Ø¯_Ø¥Ø«Ù†ÙŠÙ†_Ø«Ù„Ø§Ø«Ø§Ø¡_Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø®Ù…ÙŠØ³_Ø¬Ù…Ø¹Ø©_Ø³Ø¨Øª".split("_"),
        weekdaysMin: "Ø­_Ù†_Ø«_Ø±_Ø®_Ø¬_Ø³".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Ø§Ù„ÙŠÙˆÙ… Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          nextDay: "[ØºØ¯Ø§ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          nextWeek: "dddd [Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          lastDay: "[Ø£Ù…Ø³ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          lastWeek: "dddd [Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "ÙÙŠ %s",
          past: "Ù…Ù†Ø° %s",
          s: "Ø«ÙˆØ§Ù†",
          ss: "%d Ø«Ø§Ù†ÙŠØ©",
          m: "Ø¯Ù‚ÙŠÙ‚Ø©",
          mm: "%d Ø¯Ù‚Ø§Ø¦Ù‚",
          h: "Ø³Ø§Ø¹Ø©",
          hh: "%d Ø³Ø§Ø¹Ø§Øª",
          d: "ÙŠÙˆÙ…",
          dd: "%d Ø£ÙŠØ§Ù…",
          M: "Ø´Ù‡Ø±",
          MM: "%d Ø£Ø´Ù‡Ø±",
          y: "Ø³Ù†Ø©",
          yy: "%d Ø³Ù†ÙˆØ§Øª"
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var symbolMap$3 = {
        1: "Ù¡",
        2: "Ù¢",
        3: "Ù£",
        4: "Ù¤",
        5: "Ù¥",
        6: "Ù¦",
        7: "Ù§",
        8: "Ù¨",
        9: "Ù©",
        0: "Ù "
      }, numberMap$2 = {
        "Ù¡": "1",
        "Ù¢": "2",
        "Ù£": "3",
        "Ù¤": "4",
        "Ù¥": "5",
        "Ù¦": "6",
        "Ù§": "7",
        "Ù¨": "8",
        "Ù©": "9",
        "Ù ": "0"
      }, pluralForm$2 = function(n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
      }, plurals$2 = {
        s: [
          "Ø£Ù‚Ù„ Ù…Ù† Ø«Ø§Ù†ÙŠØ©",
          "Ø«Ø§Ù†ÙŠØ© ÙˆØ§Ø­Ø¯Ø©",
          ["Ø«Ø§Ù†ÙŠØªØ§Ù†", "Ø«Ø§Ù†ÙŠØªÙŠÙ†"],
          "%d Ø«ÙˆØ§Ù†",
          "%d Ø«Ø§Ù†ÙŠØ©",
          "%d Ø«Ø§Ù†ÙŠØ©"
        ],
        m: [
          "Ø£Ù‚Ù„ Ù…Ù† Ø¯Ù‚ÙŠÙ‚Ø©",
          "Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ø­Ø¯Ø©",
          ["Ø¯Ù‚ÙŠÙ‚ØªØ§Ù†", "Ø¯Ù‚ÙŠÙ‚ØªÙŠÙ†"],
          "%d Ø¯Ù‚Ø§Ø¦Ù‚",
          "%d Ø¯Ù‚ÙŠÙ‚Ø©",
          "%d Ø¯Ù‚ÙŠÙ‚Ø©"
        ],
        h: [
          "Ø£Ù‚Ù„ Ù…Ù† Ø³Ø§Ø¹Ø©",
          "Ø³Ø§Ø¹Ø© ÙˆØ§Ø­Ø¯Ø©",
          ["Ø³Ø§Ø¹ØªØ§Ù†", "Ø³Ø§Ø¹ØªÙŠÙ†"],
          "%d Ø³Ø§Ø¹Ø§Øª",
          "%d Ø³Ø§Ø¹Ø©",
          "%d Ø³Ø§Ø¹Ø©"
        ],
        d: [
          "Ø£Ù‚Ù„ Ù…Ù† ÙŠÙˆÙ…",
          "ÙŠÙˆÙ… ÙˆØ§Ø­Ø¯",
          ["ÙŠÙˆÙ…Ø§Ù†", "ÙŠÙˆÙ…ÙŠÙ†"],
          "%d Ø£ÙŠØ§Ù…",
          "%d ÙŠÙˆÙ…Ù‹Ø§",
          "%d ÙŠÙˆÙ…"
        ],
        M: [
          "Ø£Ù‚Ù„ Ù…Ù† Ø´Ù‡Ø±",
          "Ø´Ù‡Ø± ÙˆØ§Ø­Ø¯",
          ["Ø´Ù‡Ø±Ø§Ù†", "Ø´Ù‡Ø±ÙŠÙ†"],
          "%d Ø£Ø´Ù‡Ø±",
          "%d Ø´Ù‡Ø±Ø§",
          "%d Ø´Ù‡Ø±"
        ],
        y: [
          "Ø£Ù‚Ù„ Ù…Ù† Ø¹Ø§Ù…",
          "Ø¹Ø§Ù… ÙˆØ§Ø­Ø¯",
          ["Ø¹Ø§Ù…Ø§Ù†", "Ø¹Ø§Ù…ÙŠÙ†"],
          "%d Ø£Ø¹ÙˆØ§Ù…",
          "%d Ø¹Ø§Ù…Ù‹Ø§",
          "%d Ø¹Ø§Ù…"
        ]
      }, pluralize$2 = function(u2) {
        return function(number2, withoutSuffix, string2, isFuture) {
          var f2 = pluralForm$2(number2), str = plurals$2[u2][pluralForm$2(number2)];
          if (f2 === 2) {
            str = str[withoutSuffix ? 0 : 1];
          }
          return str.replace(/%d/i, number2);
        };
      }, months$3 = [
        "ÙŠÙ†Ø§ÙŠØ±",
        "ÙØ¨Ø±Ø§ÙŠØ±",
        "Ù…Ø§Ø±Ø³",
        "Ø£Ø¨Ø±ÙŠÙ„",
        "Ù…Ø§ÙŠÙˆ",
        "ÙŠÙˆÙ†ÙŠÙˆ",
        "ÙŠÙˆÙ„ÙŠÙˆ",
        "Ø£ØºØ³Ø·Ø³",
        "Ø³Ø¨ØªÙ…Ø¨Ø±",
        "Ø£ÙƒØªÙˆØ¨Ø±",
        "Ù†ÙˆÙÙ…Ø¨Ø±",
        "Ø¯ÙŠØ³Ù…Ø¨Ø±"
      ];
      hooks.defineLocale("ar", {
        months: months$3,
        monthsShort: months$3,
        weekdays: "Ø§Ù„Ø£Ø­Ø¯_Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†_Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡_Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø§Ù„Ø®Ù…ÙŠØ³_Ø§Ù„Ø¬Ù…Ø¹Ø©_Ø§Ù„Ø³Ø¨Øª".split("_"),
        weekdaysShort: "Ø£Ø­Ø¯_Ø¥Ø«Ù†ÙŠÙ†_Ø«Ù„Ø§Ø«Ø§Ø¡_Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø®Ù…ÙŠØ³_Ø¬Ù…Ø¹Ø©_Ø³Ø¨Øª".split("_"),
        weekdaysMin: "Ø­_Ù†_Ø«_Ø±_Ø®_Ø¬_Ø³".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "D/â€M/â€YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /Øµ|Ù…/,
        isPM: function(input) {
          return "Ù…" === input;
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 12) {
            return "Øµ";
          } else {
            return "Ù…";
          }
        },
        calendar: {
          sameDay: "[Ø§Ù„ÙŠÙˆÙ… Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          nextDay: "[ØºØ¯Ù‹Ø§ Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          nextWeek: "dddd [Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          lastDay: "[Ø£Ù…Ø³ Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          lastWeek: "dddd [Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø©] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "Ø¨Ø¹Ø¯ %s",
          past: "Ù…Ù†Ø° %s",
          s: pluralize$2("s"),
          ss: pluralize$2("s"),
          m: pluralize$2("m"),
          mm: pluralize$2("m"),
          h: pluralize$2("h"),
          hh: pluralize$2("h"),
          d: pluralize$2("d"),
          dd: pluralize$2("d"),
          M: pluralize$2("M"),
          MM: pluralize$2("M"),
          y: pluralize$2("y"),
          yy: pluralize$2("y")
        },
        preparse: function(string2) {
          return string2.replace(/[Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©Ù ]/g, function(match) {
            return numberMap$2[match];
          }).replace(/ØŒ/g, ",");
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap$3[match];
          }).replace(/,/g, "ØŒ");
        },
        week: {
          dow: 6,
          // Saturday is the first day of the week.
          doy: 12
          // The week that contains Jan 12th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var suffixes = {
        1: "-inci",
        5: "-inci",
        8: "-inci",
        70: "-inci",
        80: "-inci",
        2: "-nci",
        7: "-nci",
        20: "-nci",
        50: "-nci",
        3: "-Ã¼ncÃ¼",
        4: "-Ã¼ncÃ¼",
        100: "-Ã¼ncÃ¼",
        6: "-ncÄ±",
        9: "-uncu",
        10: "-uncu",
        30: "-uncu",
        60: "-Ä±ncÄ±",
        90: "-Ä±ncÄ±"
      };
      hooks.defineLocale("az", {
        months: "yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split(
          "_"
        ),
        monthsShort: "yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"),
        weekdays: "Bazar_Bazar ertÉ™si_Ã‡É™rÅŸÉ™nbÉ™ axÅŸamÄ±_Ã‡É™rÅŸÉ™nbÉ™_CÃ¼mÉ™ axÅŸamÄ±_CÃ¼mÉ™_ÅžÉ™nbÉ™".split(
          "_"
        ),
        weekdaysShort: "Baz_BzE_Ã‡Ax_Ã‡É™r_CAx_CÃ¼m_ÅžÉ™n".split("_"),
        weekdaysMin: "Bz_BE_Ã‡A_Ã‡É™_CA_CÃ¼_ÅžÉ™".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[bugÃ¼n saat] LT",
          nextDay: "[sabah saat] LT",
          nextWeek: "[gÉ™lÉ™n hÉ™ftÉ™] dddd [saat] LT",
          lastDay: "[dÃ¼nÉ™n] LT",
          lastWeek: "[keÃ§É™n hÉ™ftÉ™] dddd [saat] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s sonra",
          past: "%s É™vvÉ™l",
          s: "bir neÃ§É™ saniyÉ™",
          ss: "%d saniyÉ™",
          m: "bir dÉ™qiqÉ™",
          mm: "%d dÉ™qiqÉ™",
          h: "bir saat",
          hh: "%d saat",
          d: "bir gÃ¼n",
          dd: "%d gÃ¼n",
          M: "bir ay",
          MM: "%d ay",
          y: "bir il",
          yy: "%d il"
        },
        meridiemParse: /gecÉ™|sÉ™hÉ™r|gÃ¼ndÃ¼z|axÅŸam/,
        isPM: function(input) {
          return /^(gÃ¼ndÃ¼z|axÅŸam)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "gecÉ™";
          } else if (hour < 12) {
            return "sÉ™hÉ™r";
          } else if (hour < 17) {
            return "gÃ¼ndÃ¼z";
          } else {
            return "axÅŸam";
          }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(Ä±ncÄ±|inci|nci|Ã¼ncÃ¼|ncÄ±|uncu)/,
        ordinal: function(number2) {
          if (number2 === 0) {
            return number2 + "-Ä±ncÄ±";
          }
          var a = number2 % 10, b = number2 % 100 - a, c = number2 >= 100 ? 100 : null;
          return number2 + (suffixes[a] || suffixes[b] || suffixes[c]);
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      function plural(word, num) {
        var forms2 = word.split("_");
        return num % 10 === 1 && num % 100 !== 11 ? forms2[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms2[1] : forms2[2];
      }
      function relativeTimeWithPlural(number2, withoutSuffix, key) {
        var format2 = {
          ss: withoutSuffix ? "ÑÐµÐºÑƒÐ½Ð´Ð°_ÑÐµÐºÑƒÐ½Ð´Ñ‹_ÑÐµÐºÑƒÐ½Ð´" : "ÑÐµÐºÑƒÐ½Ð´Ñƒ_ÑÐµÐºÑƒÐ½Ð´Ñ‹_ÑÐµÐºÑƒÐ½Ð´",
          mm: withoutSuffix ? "Ñ…Ð²Ñ–Ð»Ñ–Ð½Ð°_Ñ…Ð²Ñ–Ð»Ñ–Ð½Ñ‹_Ñ…Ð²Ñ–Ð»Ñ–Ð½" : "Ñ…Ð²Ñ–Ð»Ñ–Ð½Ñƒ_Ñ…Ð²Ñ–Ð»Ñ–Ð½Ñ‹_Ñ…Ð²Ñ–Ð»Ñ–Ð½",
          hh: withoutSuffix ? "Ð³Ð°Ð´Ð·Ñ–Ð½Ð°_Ð³Ð°Ð´Ð·Ñ–Ð½Ñ‹_Ð³Ð°Ð´Ð·Ñ–Ð½" : "Ð³Ð°Ð´Ð·Ñ–Ð½Ñƒ_Ð³Ð°Ð´Ð·Ñ–Ð½Ñ‹_Ð³Ð°Ð´Ð·Ñ–Ð½",
          dd: "Ð´Ð·ÐµÐ½ÑŒ_Ð´Ð½Ñ–_Ð´Ð·Ñ‘Ð½",
          MM: "Ð¼ÐµÑÑÑ†_Ð¼ÐµÑÑÑ†Ñ‹_Ð¼ÐµÑÑÑ†Ð°Ñž",
          yy: "Ð³Ð¾Ð´_Ð³Ð°Ð´Ñ‹_Ð³Ð°Ð´Ð¾Ñž"
        };
        if (key === "m") {
          return withoutSuffix ? "Ñ…Ð²Ñ–Ð»Ñ–Ð½Ð°" : "Ñ…Ð²Ñ–Ð»Ñ–Ð½Ñƒ";
        } else if (key === "h") {
          return withoutSuffix ? "Ð³Ð°Ð´Ð·Ñ–Ð½Ð°" : "Ð³Ð°Ð´Ð·Ñ–Ð½Ñƒ";
        } else {
          return number2 + " " + plural(format2[key], +number2);
        }
      }
      hooks.defineLocale("be", {
        months: {
          format: "ÑÑ‚ÑƒÐ´Ð·ÐµÐ½Ñ_Ð»ÑŽÑ‚Ð°Ð³Ð°_ÑÐ°ÐºÐ°Ð²Ñ–ÐºÐ°_ÐºÑ€Ð°ÑÐ°Ð²Ñ–ÐºÐ°_Ñ‚Ñ€Ð°ÑžÐ½Ñ_Ñ‡ÑÑ€Ð²ÐµÐ½Ñ_Ð»Ñ–Ð¿ÐµÐ½Ñ_Ð¶Ð½Ñ–ÑžÐ½Ñ_Ð²ÐµÑ€Ð°ÑÐ½Ñ_ÐºÐ°ÑÑ‚Ñ€Ñ‹Ñ‡Ð½Ñ–ÐºÐ°_Ð»Ñ–ÑÑ‚Ð°Ð¿Ð°Ð´Ð°_ÑÐ½ÐµÐ¶Ð½Ñ".split(
            "_"
          ),
          standalone: "ÑÑ‚ÑƒÐ´Ð·ÐµÐ½ÑŒ_Ð»ÑŽÑ‚Ñ‹_ÑÐ°ÐºÐ°Ð²Ñ–Ðº_ÐºÑ€Ð°ÑÐ°Ð²Ñ–Ðº_Ñ‚Ñ€Ð°Ð²ÐµÐ½ÑŒ_Ñ‡ÑÑ€Ð²ÐµÐ½ÑŒ_Ð»Ñ–Ð¿ÐµÐ½ÑŒ_Ð¶Ð½Ñ–Ð²ÐµÐ½ÑŒ_Ð²ÐµÑ€Ð°ÑÐµÐ½ÑŒ_ÐºÐ°ÑÑ‚Ñ€Ñ‹Ñ‡Ð½Ñ–Ðº_Ð»Ñ–ÑÑ‚Ð°Ð¿Ð°Ð´_ÑÐ½ÐµÐ¶Ð°Ð½ÑŒ".split(
            "_"
          )
        },
        monthsShort: "ÑÑ‚ÑƒÐ´_Ð»ÑŽÑ‚_ÑÐ°Ðº_ÐºÑ€Ð°Ñ_Ñ‚Ñ€Ð°Ð²_Ñ‡ÑÑ€Ð²_Ð»Ñ–Ð¿_Ð¶Ð½Ñ–Ð²_Ð²ÐµÑ€_ÐºÐ°ÑÑ‚_Ð»Ñ–ÑÑ‚_ÑÐ½ÐµÐ¶".split("_"),
        weekdays: {
          format: "Ð½ÑÐ´Ð·ÐµÐ»ÑŽ_Ð¿Ð°Ð½ÑÐ´Ð·ÐµÐ»Ð°Ðº_Ð°ÑžÑ‚Ð¾Ñ€Ð°Ðº_ÑÐµÑ€Ð°Ð´Ñƒ_Ñ‡Ð°Ñ†Ð²ÐµÑ€_Ð¿ÑÑ‚Ð½Ñ–Ñ†Ñƒ_ÑÑƒÐ±Ð¾Ñ‚Ñƒ".split(
            "_"
          ),
          standalone: "Ð½ÑÐ´Ð·ÐµÐ»Ñ_Ð¿Ð°Ð½ÑÐ´Ð·ÐµÐ»Ð°Ðº_Ð°ÑžÑ‚Ð¾Ñ€Ð°Ðº_ÑÐµÑ€Ð°Ð´Ð°_Ñ‡Ð°Ñ†Ð²ÐµÑ€_Ð¿ÑÑ‚Ð½Ñ–Ñ†Ð°_ÑÑƒÐ±Ð¾Ñ‚Ð°".split(
            "_"
          ),
          isFormat: /\[ ?[Ð£ÑƒÑž] ?(?:Ð¼Ñ–Ð½ÑƒÐ»ÑƒÑŽ|Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½ÑƒÑŽ)? ?\] ?dddd/
        },
        weekdaysShort: "Ð½Ð´_Ð¿Ð½_Ð°Ñ‚_ÑÑ€_Ñ‡Ñ†_Ð¿Ñ‚_ÑÐ±".split("_"),
        weekdaysMin: "Ð½Ð´_Ð¿Ð½_Ð°Ñ‚_ÑÑ€_Ñ‡Ñ†_Ð¿Ñ‚_ÑÐ±".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY Ð³.",
          LLL: "D MMMM YYYY Ð³., HH:mm",
          LLLL: "dddd, D MMMM YYYY Ð³., HH:mm"
        },
        calendar: {
          sameDay: "[Ð¡Ñ‘Ð½Ð½Ñ Ñž] LT",
          nextDay: "[Ð—Ð°ÑžÑ‚Ñ€Ð° Ñž] LT",
          lastDay: "[Ð£Ñ‡Ð¾Ñ€Ð° Ñž] LT",
          nextWeek: function() {
            return "[Ð£] dddd [Ñž] LT";
          },
          lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
              case 5:
              case 6:
                return "[Ð£ Ð¼Ñ–Ð½ÑƒÐ»ÑƒÑŽ] dddd [Ñž] LT";
              case 1:
              case 2:
              case 4:
                return "[Ð£ Ð¼Ñ–Ð½ÑƒÐ»Ñ‹] dddd [Ñž] LT";
            }
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "Ð¿Ñ€Ð°Ð· %s",
          past: "%s Ñ‚Ð°Ð¼Ñƒ",
          s: "Ð½ÐµÐºÐ°Ð»ÑŒÐºÑ– ÑÐµÐºÑƒÐ½Ð´",
          m: relativeTimeWithPlural,
          mm: relativeTimeWithPlural,
          h: relativeTimeWithPlural,
          hh: relativeTimeWithPlural,
          d: "Ð´Ð·ÐµÐ½ÑŒ",
          dd: relativeTimeWithPlural,
          M: "Ð¼ÐµÑÑÑ†",
          MM: relativeTimeWithPlural,
          y: "Ð³Ð¾Ð´",
          yy: relativeTimeWithPlural
        },
        meridiemParse: /Ð½Ð¾Ñ‡Ñ‹|Ñ€Ð°Ð½Ñ–Ñ†Ñ‹|Ð´Ð½Ñ|Ð²ÐµÑ‡Ð°Ñ€Ð°/,
        isPM: function(input) {
          return /^(Ð´Ð½Ñ|Ð²ÐµÑ‡Ð°Ñ€Ð°)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "Ð½Ð¾Ñ‡Ñ‹";
          } else if (hour < 12) {
            return "Ñ€Ð°Ð½Ñ–Ñ†Ñ‹";
          } else if (hour < 17) {
            return "Ð´Ð½Ñ";
          } else {
            return "Ð²ÐµÑ‡Ð°Ñ€Ð°";
          }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(Ñ–|Ñ‹|Ð³Ð°)/,
        ordinal: function(number2, period) {
          switch (period) {
            case "M":
            case "d":
            case "DDD":
            case "w":
            case "W":
              return (number2 % 10 === 2 || number2 % 10 === 3) && number2 % 100 !== 12 && number2 % 100 !== 13 ? number2 + "-Ñ–" : number2 + "-Ñ‹";
            case "D":
              return number2 + "-Ð³Ð°";
            default:
              return number2;
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("bg", {
        months: "ÑÐ½ÑƒÐ°Ñ€Ð¸_Ñ„ÐµÐ²Ñ€ÑƒÐ°Ñ€Ð¸_Ð¼Ð°Ñ€Ñ‚_Ð°Ð¿Ñ€Ð¸Ð»_Ð¼Ð°Ð¹_ÑŽÐ½Ð¸_ÑŽÐ»Ð¸_Ð°Ð²Ð³ÑƒÑÑ‚_ÑÐµÐ¿Ñ‚ÐµÐ¼Ð²Ñ€Ð¸_Ð¾ÐºÑ‚Ð¾Ð¼Ð²Ñ€Ð¸_Ð½Ð¾ÐµÐ¼Ð²Ñ€Ð¸_Ð´ÐµÐºÐµÐ¼Ð²Ñ€Ð¸".split(
          "_"
        ),
        monthsShort: "ÑÐ½Ñƒ_Ñ„ÐµÐ²_Ð¼Ð°Ñ€_Ð°Ð¿Ñ€_Ð¼Ð°Ð¹_ÑŽÐ½Ð¸_ÑŽÐ»Ð¸_Ð°Ð²Ð³_ÑÐµÐ¿_Ð¾ÐºÑ‚_Ð½Ð¾Ðµ_Ð´ÐµÐº".split("_"),
        weekdays: "Ð½ÐµÐ´ÐµÐ»Ñ_Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»Ð½Ð¸Ðº_Ð²Ñ‚Ð¾Ñ€Ð½Ð¸Ðº_ÑÑ€ÑÐ´Ð°_Ñ‡ÐµÑ‚Ð²ÑŠÑ€Ñ‚ÑŠÐº_Ð¿ÐµÑ‚ÑŠÐº_ÑÑŠÐ±Ð¾Ñ‚Ð°".split(
          "_"
        ),
        weekdaysShort: "Ð½ÐµÐ´_Ð¿Ð¾Ð½_Ð²Ñ‚Ð¾_ÑÑ€Ñ_Ñ‡ÐµÑ‚_Ð¿ÐµÑ‚_ÑÑŠÐ±".split("_"),
        weekdaysMin: "Ð½Ð´_Ð¿Ð½_Ð²Ñ‚_ÑÑ€_Ñ‡Ñ‚_Ð¿Ñ‚_ÑÐ±".split("_"),
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "D.MM.YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY H:mm",
          LLLL: "dddd, D MMMM YYYY H:mm"
        },
        calendar: {
          sameDay: "[Ð”Ð½ÐµÑ Ð²] LT",
          nextDay: "[Ð£Ñ‚Ñ€Ðµ Ð²] LT",
          nextWeek: "dddd [Ð²] LT",
          lastDay: "[Ð’Ñ‡ÐµÑ€Ð° Ð²] LT",
          lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
              case 6:
                return "[ÐœÐ¸Ð½Ð°Ð»Ð°Ñ‚Ð°] dddd [Ð²] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[ÐœÐ¸Ð½Ð°Ð»Ð¸Ñ] dddd [Ð²] LT";
            }
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "ÑÐ»ÐµÐ´ %s",
          past: "Ð¿Ñ€ÐµÐ´Ð¸ %s",
          s: "Ð½ÑÐºÐ¾Ð»ÐºÐ¾ ÑÐµÐºÑƒÐ½Ð´Ð¸",
          ss: "%d ÑÐµÐºÑƒÐ½Ð´Ð¸",
          m: "Ð¼Ð¸Ð½ÑƒÑ‚Ð°",
          mm: "%d Ð¼Ð¸Ð½ÑƒÑ‚Ð¸",
          h: "Ñ‡Ð°Ñ",
          hh: "%d Ñ‡Ð°ÑÐ°",
          d: "Ð´ÐµÐ½",
          dd: "%d Ð´ÐµÐ½Ð°",
          w: "ÑÐµÐ´Ð¼Ð¸Ñ†Ð°",
          ww: "%d ÑÐµÐ´Ð¼Ð¸Ñ†Ð¸",
          M: "Ð¼ÐµÑÐµÑ†",
          MM: "%d Ð¼ÐµÑÐµÑ†Ð°",
          y: "Ð³Ð¾Ð´Ð¸Ð½Ð°",
          yy: "%d Ð³Ð¾Ð´Ð¸Ð½Ð¸"
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ÐµÐ²|ÐµÐ½|Ñ‚Ð¸|Ð²Ð¸|Ñ€Ð¸|Ð¼Ð¸)/,
        ordinal: function(number2) {
          var lastDigit = number2 % 10, last2Digits = number2 % 100;
          if (number2 === 0) {
            return number2 + "-ÐµÐ²";
          } else if (last2Digits === 0) {
            return number2 + "-ÐµÐ½";
          } else if (last2Digits > 10 && last2Digits < 20) {
            return number2 + "-Ñ‚Ð¸";
          } else if (lastDigit === 1) {
            return number2 + "-Ð²Ð¸";
          } else if (lastDigit === 2) {
            return number2 + "-Ñ€Ð¸";
          } else if (lastDigit === 7 || lastDigit === 8) {
            return number2 + "-Ð¼Ð¸";
          } else {
            return number2 + "-Ñ‚Ð¸";
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("bm", {
        months: "Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_MÉ›kalo_ZuwÉ›nkalo_Zuluyekalo_Utikalo_SÉ›tanburukalo_É”kutÉ”burukalo_Nowanburukalo_Desanburukalo".split(
          "_"
        ),
        monthsShort: "Zan_Few_Mar_Awi_MÉ›_Zuw_Zul_Uti_SÉ›t_É”ku_Now_Des".split("_"),
        weekdays: "Kari_NtÉ›nÉ›n_Tarata_Araba_Alamisa_Juma_Sibiri".split("_"),
        weekdaysShort: "Kar_NtÉ›_Tar_Ara_Ala_Jum_Sib".split("_"),
        weekdaysMin: "Ka_Nt_Ta_Ar_Al_Ju_Si".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "MMMM [tile] D [san] YYYY",
          LLL: "MMMM [tile] D [san] YYYY [lÉ›rÉ›] HH:mm",
          LLLL: "dddd MMMM [tile] D [san] YYYY [lÉ›rÉ›] HH:mm"
        },
        calendar: {
          sameDay: "[Bi lÉ›rÉ›] LT",
          nextDay: "[Sini lÉ›rÉ›] LT",
          nextWeek: "dddd [don lÉ›rÉ›] LT",
          lastDay: "[Kunu lÉ›rÉ›] LT",
          lastWeek: "dddd [tÉ›mÉ›nen lÉ›rÉ›] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s kÉ”nÉ”",
          past: "a bÉ› %s bÉ”",
          s: "sanga dama dama",
          ss: "sekondi %d",
          m: "miniti kelen",
          mm: "miniti %d",
          h: "lÉ›rÉ› kelen",
          hh: "lÉ›rÉ› %d",
          d: "tile kelen",
          dd: "tile %d",
          M: "kalo kelen",
          MM: "kalo %d",
          y: "san kelen",
          yy: "san %d"
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var symbolMap$4 = {
        1: "à§§",
        2: "à§¨",
        3: "à§©",
        4: "à§ª",
        5: "à§«",
        6: "à§¬",
        7: "à§­",
        8: "à§®",
        9: "à§¯",
        0: "à§¦"
      }, numberMap$3 = {
        "à§§": "1",
        "à§¨": "2",
        "à§©": "3",
        "à§ª": "4",
        "à§«": "5",
        "à§¬": "6",
        "à§­": "7",
        "à§®": "8",
        "à§¯": "9",
        "à§¦": "0"
      };
      hooks.defineLocale("bn-bd", {
        months: "à¦œà¦¾à¦¨à§à§Ÿà¦¾à¦°à¦¿_à¦«à§‡à¦¬à§à¦°à§à§Ÿà¦¾à¦°à¦¿_à¦®à¦¾à¦°à§à¦š_à¦à¦ªà§à¦°à¦¿à¦²_à¦®à§‡_à¦œà§à¦¨_à¦œà§à¦²à¦¾à¦‡_à¦†à¦—à¦¸à§à¦Ÿ_à¦¸à§‡à¦ªà§à¦Ÿà§‡à¦®à§à¦¬à¦°_à¦…à¦•à§à¦Ÿà§‹à¦¬à¦°_à¦¨à¦­à§‡à¦®à§à¦¬à¦°_à¦¡à¦¿à¦¸à§‡à¦®à§à¦¬à¦°".split(
          "_"
        ),
        monthsShort: "à¦œà¦¾à¦¨à§_à¦«à§‡à¦¬à§à¦°à§_à¦®à¦¾à¦°à§à¦š_à¦à¦ªà§à¦°à¦¿à¦²_à¦®à§‡_à¦œà§à¦¨_à¦œà§à¦²à¦¾à¦‡_à¦†à¦—à¦¸à§à¦Ÿ_à¦¸à§‡à¦ªà§à¦Ÿ_à¦…à¦•à§à¦Ÿà§‹_à¦¨à¦­à§‡_à¦¡à¦¿à¦¸à§‡".split(
          "_"
        ),
        weekdays: "à¦°à¦¬à¦¿à¦¬à¦¾à¦°_à¦¸à§‹à¦®à¦¬à¦¾à¦°_à¦®à¦™à§à¦—à¦²à¦¬à¦¾à¦°_à¦¬à§à¦§à¦¬à¦¾à¦°_à¦¬à§ƒà¦¹à¦¸à§à¦ªà¦¤à¦¿à¦¬à¦¾à¦°_à¦¶à§à¦•à§à¦°à¦¬à¦¾à¦°_à¦¶à¦¨à¦¿à¦¬à¦¾à¦°".split(
          "_"
        ),
        weekdaysShort: "à¦°à¦¬à¦¿_à¦¸à§‹à¦®_à¦®à¦™à§à¦—à¦²_à¦¬à§à¦§_à¦¬à§ƒà¦¹à¦¸à§à¦ªà¦¤à¦¿_à¦¶à§à¦•à§à¦°_à¦¶à¦¨à¦¿".split("_"),
        weekdaysMin: "à¦°à¦¬à¦¿_à¦¸à§‹à¦®_à¦®à¦™à§à¦—à¦²_à¦¬à§à¦§_à¦¬à§ƒà¦¹_à¦¶à§à¦•à§à¦°_à¦¶à¦¨à¦¿".split("_"),
        longDateFormat: {
          LT: "A h:mm à¦¸à¦®à§Ÿ",
          LTS: "A h:mm:ss à¦¸à¦®à§Ÿ",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY, A h:mm à¦¸à¦®à§Ÿ",
          LLLL: "dddd, D MMMM YYYY, A h:mm à¦¸à¦®à§Ÿ"
        },
        calendar: {
          sameDay: "[à¦†à¦œ] LT",
          nextDay: "[à¦†à¦—à¦¾à¦®à§€à¦•à¦¾à¦²] LT",
          nextWeek: "dddd, LT",
          lastDay: "[à¦—à¦¤à¦•à¦¾à¦²] LT",
          lastWeek: "[à¦—à¦¤] dddd, LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s à¦ªà¦°à§‡",
          past: "%s à¦†à¦—à§‡",
          s: "à¦•à§Ÿà§‡à¦• à¦¸à§‡à¦•à§‡à¦¨à§à¦¡",
          ss: "%d à¦¸à§‡à¦•à§‡à¦¨à§à¦¡",
          m: "à¦à¦• à¦®à¦¿à¦¨à¦¿à¦Ÿ",
          mm: "%d à¦®à¦¿à¦¨à¦¿à¦Ÿ",
          h: "à¦à¦• à¦˜à¦¨à§à¦Ÿà¦¾",
          hh: "%d à¦˜à¦¨à§à¦Ÿà¦¾",
          d: "à¦à¦• à¦¦à¦¿à¦¨",
          dd: "%d à¦¦à¦¿à¦¨",
          M: "à¦à¦• à¦®à¦¾à¦¸",
          MM: "%d à¦®à¦¾à¦¸",
          y: "à¦à¦• à¦¬à¦›à¦°",
          yy: "%d à¦¬à¦›à¦°"
        },
        preparse: function(string2) {
          return string2.replace(/[à§§à§¨à§©à§ªà§«à§¬à§­à§®à§¯à§¦]/g, function(match) {
            return numberMap$3[match];
          });
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap$4[match];
          });
        },
        meridiemParse: /à¦°à¦¾à¦¤|à¦­à§‹à¦°|à¦¸à¦•à¦¾à¦²|à¦¦à§à¦ªà§à¦°|à¦¬à¦¿à¦•à¦¾à¦²|à¦¸à¦¨à§à¦§à§à¦¯à¦¾|à¦°à¦¾à¦¤/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "à¦°à¦¾à¦¤") {
            return hour < 4 ? hour : hour + 12;
          } else if (meridiem2 === "à¦­à§‹à¦°") {
            return hour;
          } else if (meridiem2 === "à¦¸à¦•à¦¾à¦²") {
            return hour;
          } else if (meridiem2 === "à¦¦à§à¦ªà§à¦°") {
            return hour >= 3 ? hour : hour + 12;
          } else if (meridiem2 === "à¦¬à¦¿à¦•à¦¾à¦²") {
            return hour + 12;
          } else if (meridiem2 === "à¦¸à¦¨à§à¦§à§à¦¯à¦¾") {
            return hour + 12;
          }
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "à¦°à¦¾à¦¤";
          } else if (hour < 6) {
            return "à¦­à§‹à¦°";
          } else if (hour < 12) {
            return "à¦¸à¦•à¦¾à¦²";
          } else if (hour < 15) {
            return "à¦¦à§à¦ªà§à¦°";
          } else if (hour < 18) {
            return "à¦¬à¦¿à¦•à¦¾à¦²";
          } else if (hour < 20) {
            return "à¦¸à¦¨à§à¦§à§à¦¯à¦¾";
          } else {
            return "à¦°à¦¾à¦¤";
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var symbolMap$5 = {
        1: "à§§",
        2: "à§¨",
        3: "à§©",
        4: "à§ª",
        5: "à§«",
        6: "à§¬",
        7: "à§­",
        8: "à§®",
        9: "à§¯",
        0: "à§¦"
      }, numberMap$4 = {
        "à§§": "1",
        "à§¨": "2",
        "à§©": "3",
        "à§ª": "4",
        "à§«": "5",
        "à§¬": "6",
        "à§­": "7",
        "à§®": "8",
        "à§¯": "9",
        "à§¦": "0"
      };
      hooks.defineLocale("bn", {
        months: "à¦œà¦¾à¦¨à§à§Ÿà¦¾à¦°à¦¿_à¦«à§‡à¦¬à§à¦°à§à§Ÿà¦¾à¦°à¦¿_à¦®à¦¾à¦°à§à¦š_à¦à¦ªà§à¦°à¦¿à¦²_à¦®à§‡_à¦œà§à¦¨_à¦œà§à¦²à¦¾à¦‡_à¦†à¦—à¦¸à§à¦Ÿ_à¦¸à§‡à¦ªà§à¦Ÿà§‡à¦®à§à¦¬à¦°_à¦…à¦•à§à¦Ÿà§‹à¦¬à¦°_à¦¨à¦­à§‡à¦®à§à¦¬à¦°_à¦¡à¦¿à¦¸à§‡à¦®à§à¦¬à¦°".split(
          "_"
        ),
        monthsShort: "à¦œà¦¾à¦¨à§_à¦«à§‡à¦¬à§à¦°à§_à¦®à¦¾à¦°à§à¦š_à¦à¦ªà§à¦°à¦¿à¦²_à¦®à§‡_à¦œà§à¦¨_à¦œà§à¦²à¦¾à¦‡_à¦†à¦—à¦¸à§à¦Ÿ_à¦¸à§‡à¦ªà§à¦Ÿ_à¦…à¦•à§à¦Ÿà§‹_à¦¨à¦­à§‡_à¦¡à¦¿à¦¸à§‡".split(
          "_"
        ),
        weekdays: "à¦°à¦¬à¦¿à¦¬à¦¾à¦°_à¦¸à§‹à¦®à¦¬à¦¾à¦°_à¦®à¦™à§à¦—à¦²à¦¬à¦¾à¦°_à¦¬à§à¦§à¦¬à¦¾à¦°_à¦¬à§ƒà¦¹à¦¸à§à¦ªà¦¤à¦¿à¦¬à¦¾à¦°_à¦¶à§à¦•à§à¦°à¦¬à¦¾à¦°_à¦¶à¦¨à¦¿à¦¬à¦¾à¦°".split(
          "_"
        ),
        weekdaysShort: "à¦°à¦¬à¦¿_à¦¸à§‹à¦®_à¦®à¦™à§à¦—à¦²_à¦¬à§à¦§_à¦¬à§ƒà¦¹à¦¸à§à¦ªà¦¤à¦¿_à¦¶à§à¦•à§à¦°_à¦¶à¦¨à¦¿".split("_"),
        weekdaysMin: "à¦°à¦¬à¦¿_à¦¸à§‹à¦®_à¦®à¦™à§à¦—à¦²_à¦¬à§à¦§_à¦¬à§ƒà¦¹_à¦¶à§à¦•à§à¦°_à¦¶à¦¨à¦¿".split("_"),
        longDateFormat: {
          LT: "A h:mm à¦¸à¦®à§Ÿ",
          LTS: "A h:mm:ss à¦¸à¦®à§Ÿ",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY, A h:mm à¦¸à¦®à§Ÿ",
          LLLL: "dddd, D MMMM YYYY, A h:mm à¦¸à¦®à§Ÿ"
        },
        calendar: {
          sameDay: "[à¦†à¦œ] LT",
          nextDay: "[à¦†à¦—à¦¾à¦®à§€à¦•à¦¾à¦²] LT",
          nextWeek: "dddd, LT",
          lastDay: "[à¦—à¦¤à¦•à¦¾à¦²] LT",
          lastWeek: "[à¦—à¦¤] dddd, LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s à¦ªà¦°à§‡",
          past: "%s à¦†à¦—à§‡",
          s: "à¦•à§Ÿà§‡à¦• à¦¸à§‡à¦•à§‡à¦¨à§à¦¡",
          ss: "%d à¦¸à§‡à¦•à§‡à¦¨à§à¦¡",
          m: "à¦à¦• à¦®à¦¿à¦¨à¦¿à¦Ÿ",
          mm: "%d à¦®à¦¿à¦¨à¦¿à¦Ÿ",
          h: "à¦à¦• à¦˜à¦¨à§à¦Ÿà¦¾",
          hh: "%d à¦˜à¦¨à§à¦Ÿà¦¾",
          d: "à¦à¦• à¦¦à¦¿à¦¨",
          dd: "%d à¦¦à¦¿à¦¨",
          M: "à¦à¦• à¦®à¦¾à¦¸",
          MM: "%d à¦®à¦¾à¦¸",
          y: "à¦à¦• à¦¬à¦›à¦°",
          yy: "%d à¦¬à¦›à¦°"
        },
        preparse: function(string2) {
          return string2.replace(/[à§§à§¨à§©à§ªà§«à§¬à§­à§®à§¯à§¦]/g, function(match) {
            return numberMap$4[match];
          });
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap$5[match];
          });
        },
        meridiemParse: /à¦°à¦¾à¦¤|à¦¸à¦•à¦¾à¦²|à¦¦à§à¦ªà§à¦°|à¦¬à¦¿à¦•à¦¾à¦²|à¦°à¦¾à¦¤/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "à¦°à¦¾à¦¤" && hour >= 4 || meridiem2 === "à¦¦à§à¦ªà§à¦°" && hour < 5 || meridiem2 === "à¦¬à¦¿à¦•à¦¾à¦²") {
            return hour + 12;
          } else {
            return hour;
          }
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "à¦°à¦¾à¦¤";
          } else if (hour < 10) {
            return "à¦¸à¦•à¦¾à¦²";
          } else if (hour < 17) {
            return "à¦¦à§à¦ªà§à¦°";
          } else if (hour < 20) {
            return "à¦¬à¦¿à¦•à¦¾à¦²";
          } else {
            return "à¦°à¦¾à¦¤";
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var symbolMap$6 = {
        1: "à¼¡",
        2: "à¼¢",
        3: "à¼£",
        4: "à¼¤",
        5: "à¼¥",
        6: "à¼¦",
        7: "à¼§",
        8: "à¼¨",
        9: "à¼©",
        0: "à¼ "
      }, numberMap$5 = {
        "à¼¡": "1",
        "à¼¢": "2",
        "à¼£": "3",
        "à¼¤": "4",
        "à¼¥": "5",
        "à¼¦": "6",
        "à¼§": "7",
        "à¼¨": "8",
        "à¼©": "9",
        "à¼ ": "0"
      };
      hooks.defineLocale("bo", {
        months: "à½Ÿà¾³à¼‹à½–à¼‹à½‘à½„à¼‹à½”à½¼_à½Ÿà¾³à¼‹à½–à¼‹à½‚à½‰à½²à½¦à¼‹à½”_à½Ÿà¾³à¼‹à½–à¼‹à½‚à½¦à½´à½˜à¼‹à½”_à½Ÿà¾³à¼‹à½–à¼‹à½–à½žà½²à¼‹à½”_à½Ÿà¾³à¼‹à½–à¼‹à½£à¾”à¼‹à½”_à½Ÿà¾³à¼‹à½–à¼‹à½‘à¾²à½´à½‚à¼‹à½”_à½Ÿà¾³à¼‹à½–à¼‹à½–à½‘à½´à½“à¼‹à½”_à½Ÿà¾³à¼‹à½–à¼‹à½–à½¢à¾’à¾±à½‘à¼‹à½”_à½Ÿà¾³à¼‹à½–à¼‹à½‘à½‚à½´à¼‹à½”_à½Ÿà¾³à¼‹à½–à¼‹à½–à½…à½´à¼‹à½”_à½Ÿà¾³à¼‹à½–à¼‹à½–à½…à½´à¼‹à½‚à½…à½²à½‚à¼‹à½”_à½Ÿà¾³à¼‹à½–à¼‹à½–à½…à½´à¼‹à½‚à½‰à½²à½¦à¼‹à½”".split(
          "_"
        ),
        monthsShort: "à½Ÿà¾³à¼‹1_à½Ÿà¾³à¼‹2_à½Ÿà¾³à¼‹3_à½Ÿà¾³à¼‹4_à½Ÿà¾³à¼‹5_à½Ÿà¾³à¼‹6_à½Ÿà¾³à¼‹7_à½Ÿà¾³à¼‹8_à½Ÿà¾³à¼‹9_à½Ÿà¾³à¼‹10_à½Ÿà¾³à¼‹11_à½Ÿà¾³à¼‹12".split(
          "_"
        ),
        monthsShortRegex: /^(à½Ÿà¾³à¼‹\d{1,2})/,
        monthsParseExact: true,
        weekdays: "à½‚à½Ÿà½ à¼‹à½‰à½²à¼‹à½˜à¼‹_à½‚à½Ÿà½ à¼‹à½Ÿà¾³à¼‹à½–à¼‹_à½‚à½Ÿà½ à¼‹à½˜à½²à½‚à¼‹à½‘à½˜à½¢à¼‹_à½‚à½Ÿà½ à¼‹à½£à¾·à½‚à¼‹à½”à¼‹_à½‚à½Ÿà½ à¼‹à½•à½´à½¢à¼‹à½–à½´_à½‚à½Ÿà½ à¼‹à½”à¼‹à½¦à½„à½¦à¼‹_à½‚à½Ÿà½ à¼‹à½¦à¾¤à½ºà½“à¼‹à½”à¼‹".split(
          "_"
        ),
        weekdaysShort: "à½‰à½²à¼‹à½˜à¼‹_à½Ÿà¾³à¼‹à½–à¼‹_à½˜à½²à½‚à¼‹à½‘à½˜à½¢à¼‹_à½£à¾·à½‚à¼‹à½”à¼‹_à½•à½´à½¢à¼‹à½–à½´_à½”à¼‹à½¦à½„à½¦à¼‹_à½¦à¾¤à½ºà½“à¼‹à½”à¼‹".split(
          "_"
        ),
        weekdaysMin: "à½‰à½²_à½Ÿà¾³_à½˜à½²à½‚_à½£à¾·à½‚_à½•à½´à½¢_à½¦à½„à½¦_à½¦à¾¤à½ºà½“".split("_"),
        longDateFormat: {
          LT: "A h:mm",
          LTS: "A h:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY, A h:mm",
          LLLL: "dddd, D MMMM YYYY, A h:mm"
        },
        calendar: {
          sameDay: "[à½‘à½²à¼‹à½¢à½²à½„] LT",
          nextDay: "[à½¦à½„à¼‹à½‰à½²à½“] LT",
          nextWeek: "[à½–à½‘à½´à½“à¼‹à½•à¾²à½‚à¼‹à½¢à¾—à½ºà½¦à¼‹à½˜], LT",
          lastDay: "[à½à¼‹à½¦à½„] LT",
          lastWeek: "[à½–à½‘à½´à½“à¼‹à½•à¾²à½‚à¼‹à½˜à½à½ à¼‹à½˜] dddd, LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s à½£à¼‹",
          past: "%s à½¦à¾”à½“à¼‹à½£",
          s: "à½£à½˜à¼‹à½¦à½„",
          ss: "%d à½¦à¾à½¢à¼‹à½†à¼",
          m: "à½¦à¾à½¢à¼‹à½˜à¼‹à½‚à½…à½²à½‚",
          mm: "%d à½¦à¾à½¢à¼‹à½˜",
          h: "à½†à½´à¼‹à½šà½¼à½‘à¼‹à½‚à½…à½²à½‚",
          hh: "%d à½†à½´à¼‹à½šà½¼à½‘",
          d: "à½‰à½²à½“à¼‹à½‚à½…à½²à½‚",
          dd: "%d à½‰à½²à½“à¼‹",
          M: "à½Ÿà¾³à¼‹à½–à¼‹à½‚à½…à½²à½‚",
          MM: "%d à½Ÿà¾³à¼‹à½–",
          y: "à½£à½¼à¼‹à½‚à½…à½²à½‚",
          yy: "%d à½£à½¼"
        },
        preparse: function(string2) {
          return string2.replace(/[à¼¡à¼¢à¼£à¼¤à¼¥à¼¦à¼§à¼¨à¼©à¼ ]/g, function(match) {
            return numberMap$5[match];
          });
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap$6[match];
          });
        },
        meridiemParse: /à½˜à½šà½“à¼‹à½˜à½¼|à½žà½¼à½‚à½¦à¼‹à½€à½¦|à½‰à½²à½“à¼‹à½‚à½´à½„|à½‘à½‚à½¼à½„à¼‹à½‘à½‚|à½˜à½šà½“à¼‹à½˜à½¼/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "à½˜à½šà½“à¼‹à½˜à½¼" && hour >= 4 || meridiem2 === "à½‰à½²à½“à¼‹à½‚à½´à½„" && hour < 5 || meridiem2 === "à½‘à½‚à½¼à½„à¼‹à½‘à½‚") {
            return hour + 12;
          } else {
            return hour;
          }
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "à½˜à½šà½“à¼‹à½˜à½¼";
          } else if (hour < 10) {
            return "à½žà½¼à½‚à½¦à¼‹à½€à½¦";
          } else if (hour < 17) {
            return "à½‰à½²à½“à¼‹à½‚à½´à½„";
          } else if (hour < 20) {
            return "à½‘à½‚à½¼à½„à¼‹à½‘à½‚";
          } else {
            return "à½˜à½šà½“à¼‹à½˜à½¼";
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      function relativeTimeWithMutation(number2, withoutSuffix, key) {
        var format2 = {
          mm: "munutenn",
          MM: "miz",
          dd: "devezh"
        };
        return number2 + " " + mutation(format2[key], number2);
      }
      function specialMutationForYears(number2) {
        switch (lastNumber(number2)) {
          case 1:
          case 3:
          case 4:
          case 5:
          case 9:
            return number2 + " bloaz";
          default:
            return number2 + " vloaz";
        }
      }
      function lastNumber(number2) {
        if (number2 > 9) {
          return lastNumber(number2 % 10);
        }
        return number2;
      }
      function mutation(text2, number2) {
        if (number2 === 2) {
          return softMutation(text2);
        }
        return text2;
      }
      function softMutation(text2) {
        var mutationTable = {
          m: "v",
          b: "v",
          d: "z"
        };
        if (mutationTable[text2.charAt(0)] === void 0) {
          return text2;
        }
        return mutationTable[text2.charAt(0)] + text2.substring(1);
      }
      var monthsParse = [
        /^gen/i,
        /^c[Ê¼\']hwe/i,
        /^meu/i,
        /^ebr/i,
        /^mae/i,
        /^(mez|eve)/i,
        /^gou/i,
        /^eos/i,
        /^gwe/i,
        /^her/i,
        /^du/i,
        /^ker/i
      ], monthsRegex$1 = /^(genver|c[Ê¼\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[Ê¼\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i, monthsStrictRegex = /^(genver|c[Ê¼\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i, monthsShortStrictRegex = /^(gen|c[Ê¼\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i, fullWeekdaysParse = [
        /^sul/i,
        /^lun/i,
        /^meurzh/i,
        /^merc[Ê¼\']her/i,
        /^yaou/i,
        /^gwener/i,
        /^sadorn/i
      ], shortWeekdaysParse = [
        /^Sul/i,
        /^Lun/i,
        /^Meu/i,
        /^Mer/i,
        /^Yao/i,
        /^Gwe/i,
        /^Sad/i
      ], minWeekdaysParse = [
        /^Su/i,
        /^Lu/i,
        /^Me([^r]|$)/i,
        /^Mer/i,
        /^Ya/i,
        /^Gw/i,
        /^Sa/i
      ];
      hooks.defineLocale("br", {
        months: "Genver_CÊ¼hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split(
          "_"
        ),
        monthsShort: "Gen_CÊ¼hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"),
        weekdays: "Sul_Lun_Meurzh_MercÊ¼her_Yaou_Gwener_Sadorn".split("_"),
        weekdaysShort: "Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"),
        weekdaysMin: "Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"),
        weekdaysParse: minWeekdaysParse,
        fullWeekdaysParse,
        shortWeekdaysParse,
        minWeekdaysParse,
        monthsRegex: monthsRegex$1,
        monthsShortRegex: monthsRegex$1,
        monthsStrictRegex,
        monthsShortStrictRegex,
        monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D [a viz] MMMM YYYY",
          LLL: "D [a viz] MMMM YYYY HH:mm",
          LLLL: "dddd, D [a viz] MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Hiziv da] LT",
          nextDay: "[WarcÊ¼hoazh da] LT",
          nextWeek: "dddd [da] LT",
          lastDay: "[DecÊ¼h da] LT",
          lastWeek: "dddd [paset da] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "a-benn %s",
          past: "%s Ê¼zo",
          s: "un nebeud segondennoÃ¹",
          ss: "%d eilenn",
          m: "ur vunutenn",
          mm: relativeTimeWithMutation,
          h: "un eur",
          hh: "%d eur",
          d: "un devezh",
          dd: relativeTimeWithMutation,
          M: "ur miz",
          MM: relativeTimeWithMutation,
          y: "ur bloaz",
          yy: specialMutationForYears
        },
        dayOfMonthOrdinalParse: /\d{1,2}(aÃ±|vet)/,
        ordinal: function(number2) {
          var output = number2 === 1 ? "aÃ±" : "vet";
          return number2 + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        },
        meridiemParse: /a.m.|g.m./,
        // goude merenn | a-raok merenn
        isPM: function(token2) {
          return token2 === "g.m.";
        },
        meridiem: function(hour, minute, isLower) {
          return hour < 12 ? "a.m." : "g.m.";
        }
      });
      //! moment.js locale configuration
      function processRelativeTime(number2, withoutSuffix, key, isFuture) {
        switch (key) {
          case "m":
            return withoutSuffix ? "jedna minuta" : isFuture ? "jednu minutu" : "jedne minute";
        }
      }
      function translate2(number2, withoutSuffix, key) {
        var result = number2 + " ";
        switch (key) {
          case "ss":
            if (number2 === 1) {
              result += "sekunda";
            } else if (number2 === 2 || number2 === 3 || number2 === 4) {
              result += "sekunde";
            } else {
              result += "sekundi";
            }
            return result;
          case "mm":
            if (number2 === 1) {
              result += "minuta";
            } else if (number2 === 2 || number2 === 3 || number2 === 4) {
              result += "minute";
            } else {
              result += "minuta";
            }
            return result;
          case "h":
            return withoutSuffix ? "jedan sat" : "jedan sat";
          case "hh":
            if (number2 === 1) {
              result += "sat";
            } else if (number2 === 2 || number2 === 3 || number2 === 4) {
              result += "sata";
            } else {
              result += "sati";
            }
            return result;
          case "dd":
            if (number2 === 1) {
              result += "dan";
            } else {
              result += "dana";
            }
            return result;
          case "MM":
            if (number2 === 1) {
              result += "mjesec";
            } else if (number2 === 2 || number2 === 3 || number2 === 4) {
              result += "mjeseca";
            } else {
              result += "mjeseci";
            }
            return result;
          case "yy":
            if (number2 === 1) {
              result += "godina";
            } else if (number2 === 2 || number2 === 3 || number2 === 4) {
              result += "godine";
            } else {
              result += "godina";
            }
            return result;
        }
      }
      hooks.defineLocale("bs", {
        months: "januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split(
          "_"
        ),
        monthsShort: "jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "nedjelja_ponedjeljak_utorak_srijeda_Äetvrtak_petak_subota".split(
          "_"
        ),
        weekdaysShort: "ned._pon._uto._sri._Äet._pet._sub.".split("_"),
        weekdaysMin: "ne_po_ut_sr_Äe_pe_su".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D. MMMM YYYY",
          LLL: "D. MMMM YYYY H:mm",
          LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
          sameDay: "[danas u] LT",
          nextDay: "[sutra u] LT",
          nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[u] [nedjelju] [u] LT";
              case 3:
                return "[u] [srijedu] [u] LT";
              case 6:
                return "[u] [subotu] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[u] dddd [u] LT";
            }
          },
          lastDay: "[juÄer u] LT",
          lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
                return "[proÅ¡lu] dddd [u] LT";
              case 6:
                return "[proÅ¡le] [subote] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[proÅ¡li] dddd [u] LT";
            }
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "za %s",
          past: "prije %s",
          s: "par sekundi",
          ss: translate2,
          m: processRelativeTime,
          mm: translate2,
          h: translate2,
          hh: translate2,
          d: "dan",
          dd: translate2,
          M: "mjesec",
          MM: translate2,
          y: "godinu",
          yy: translate2
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("ca", {
        months: {
          standalone: "gener_febrer_marÃ§_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split(
            "_"
          ),
          format: "de gener_de febrer_de marÃ§_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split(
            "_"
          ),
          isFormat: /D[oD]?(\s)+MMMM/
        },
        monthsShort: "gen._febr._marÃ§_abr._maig_juny_jul._ag._set._oct._nov._des.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split(
          "_"
        ),
        weekdaysShort: "dg._dl._dt._dc._dj._dv._ds.".split("_"),
        weekdaysMin: "dg_dl_dt_dc_dj_dv_ds".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM [de] YYYY",
          ll: "D MMM YYYY",
          LLL: "D MMMM [de] YYYY [a les] H:mm",
          lll: "D MMM YYYY, H:mm",
          LLLL: "dddd D MMMM [de] YYYY [a les] H:mm",
          llll: "ddd D MMM YYYY, H:mm"
        },
        calendar: {
          sameDay: function() {
            return "[avui a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
          },
          nextDay: function() {
            return "[demÃ  a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
          },
          nextWeek: function() {
            return "dddd [a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
          },
          lastDay: function() {
            return "[ahir a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
          },
          lastWeek: function() {
            return "[el] dddd [passat a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "d'aquÃ­ %s",
          past: "fa %s",
          s: "uns segons",
          ss: "%d segons",
          m: "un minut",
          mm: "%d minuts",
          h: "una hora",
          hh: "%d hores",
          d: "un dia",
          dd: "%d dies",
          M: "un mes",
          MM: "%d mesos",
          y: "un any",
          yy: "%d anys"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|Ã¨|a)/,
        ordinal: function(number2, period) {
          var output = number2 === 1 ? "r" : number2 === 2 ? "n" : number2 === 3 ? "r" : number2 === 4 ? "t" : "Ã¨";
          if (period === "w" || period === "W") {
            output = "a";
          }
          return number2 + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var months$4 = {
        standalone: "leden_Ãºnor_bÅ™ezen_duben_kvÄ›ten_Äerven_Äervenec_srpen_zÃ¡Å™Ã­_Å™Ã­jen_listopad_prosinec".split(
          "_"
        ),
        format: "ledna_Ãºnora_bÅ™ezna_dubna_kvÄ›tna_Äervna_Äervence_srpna_zÃ¡Å™Ã­_Å™Ã­jna_listopadu_prosince".split(
          "_"
        ),
        isFormat: /DD?[o.]?(\[[^\[\]]*\]|\s)+MMMM/
      }, monthsShort = "led_Ãºno_bÅ™e_dub_kvÄ›_Ävn_Ävc_srp_zÃ¡Å™_Å™Ã­j_lis_pro".split("_"), monthsParse$1 = [
        /^led/i,
        /^Ãºno/i,
        /^bÅ™e/i,
        /^dub/i,
        /^kvÄ›/i,
        /^(Ävn|Äerven$|Äervna)/i,
        /^(Ävc|Äervenec|Äervence)/i,
        /^srp/i,
        /^zÃ¡Å™/i,
        /^Å™Ã­j/i,
        /^lis/i,
        /^pro/i
      ], monthsRegex$2 = /^(leden|Ãºnor|bÅ™ezen|duben|kvÄ›ten|Äervenec|Äervence|Äerven|Äervna|srpen|zÃ¡Å™Ã­|Å™Ã­jen|listopad|prosinec|led|Ãºno|bÅ™e|dub|kvÄ›|Ävn|Ävc|srp|zÃ¡Å™|Å™Ã­j|lis|pro)/i;
      function plural$1(n) {
        return n > 1 && n < 5 && ~~(n / 10) !== 1;
      }
      function translate$1(number2, withoutSuffix, key, isFuture) {
        var result = number2 + " ";
        switch (key) {
          case "s":
            return withoutSuffix || isFuture ? "pÃ¡r sekund" : "pÃ¡r sekundami";
          case "ss":
            if (withoutSuffix || isFuture) {
              return result + (plural$1(number2) ? "sekundy" : "sekund");
            } else {
              return result + "sekundami";
            }
          case "m":
            return withoutSuffix ? "minuta" : isFuture ? "minutu" : "minutou";
          case "mm":
            if (withoutSuffix || isFuture) {
              return result + (plural$1(number2) ? "minuty" : "minut");
            } else {
              return result + "minutami";
            }
          case "h":
            return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";
          case "hh":
            if (withoutSuffix || isFuture) {
              return result + (plural$1(number2) ? "hodiny" : "hodin");
            } else {
              return result + "hodinami";
            }
          case "d":
            return withoutSuffix || isFuture ? "den" : "dnem";
          case "dd":
            if (withoutSuffix || isFuture) {
              return result + (plural$1(number2) ? "dny" : "dnÃ­");
            } else {
              return result + "dny";
            }
          case "M":
            return withoutSuffix || isFuture ? "mÄ›sÃ­c" : "mÄ›sÃ­cem";
          case "MM":
            if (withoutSuffix || isFuture) {
              return result + (plural$1(number2) ? "mÄ›sÃ­ce" : "mÄ›sÃ­cÅ¯");
            } else {
              return result + "mÄ›sÃ­ci";
            }
          case "y":
            return withoutSuffix || isFuture ? "rok" : "rokem";
          case "yy":
            if (withoutSuffix || isFuture) {
              return result + (plural$1(number2) ? "roky" : "let");
            } else {
              return result + "lety";
            }
        }
      }
      hooks.defineLocale("cs", {
        months: months$4,
        monthsShort,
        monthsRegex: monthsRegex$2,
        monthsShortRegex: monthsRegex$2,
        // NOTE: 'Äerven' is substring of 'Äervenec'; therefore 'Äervenec' must precede 'Äerven' in the regex to be fully matched.
        // Otherwise parser matches '1. Äervenec' as '1. Äerven' + 'ec'.
        monthsStrictRegex: /^(leden|ledna|Ãºnora|Ãºnor|bÅ™ezen|bÅ™ezna|duben|dubna|kvÄ›ten|kvÄ›tna|Äervenec|Äervence|Äerven|Äervna|srpen|srpna|zÃ¡Å™Ã­|Å™Ã­jen|Å™Ã­jna|listopadu|listopad|prosinec|prosince)/i,
        monthsShortStrictRegex: /^(led|Ãºno|bÅ™e|dub|kvÄ›|Ävn|Ävc|srp|zÃ¡Å™|Å™Ã­j|lis|pro)/i,
        monthsParse: monthsParse$1,
        longMonthsParse: monthsParse$1,
        shortMonthsParse: monthsParse$1,
        weekdays: "nedÄ›le_pondÄ›lÃ­_ÃºterÃ½_stÅ™eda_Ätvrtek_pÃ¡tek_sobota".split("_"),
        weekdaysShort: "ne_po_Ãºt_st_Ät_pÃ¡_so".split("_"),
        weekdaysMin: "ne_po_Ãºt_st_Ät_pÃ¡_so".split("_"),
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D. MMMM YYYY",
          LLL: "D. MMMM YYYY H:mm",
          LLLL: "dddd D. MMMM YYYY H:mm",
          l: "D. M. YYYY"
        },
        calendar: {
          sameDay: "[dnes v] LT",
          nextDay: "[zÃ­tra v] LT",
          nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[v nedÄ›li v] LT";
              case 1:
              case 2:
                return "[v] dddd [v] LT";
              case 3:
                return "[ve stÅ™edu v] LT";
              case 4:
                return "[ve Ätvrtek v] LT";
              case 5:
                return "[v pÃ¡tek v] LT";
              case 6:
                return "[v sobotu v] LT";
            }
          },
          lastDay: "[vÄera v] LT",
          lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[minulou nedÄ›li v] LT";
              case 1:
              case 2:
                return "[minulÃ©] dddd [v] LT";
              case 3:
                return "[minulou stÅ™edu v] LT";
              case 4:
              case 5:
                return "[minulÃ½] dddd [v] LT";
              case 6:
                return "[minulou sobotu v] LT";
            }
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "za %s",
          past: "pÅ™ed %s",
          s: translate$1,
          ss: translate$1,
          m: translate$1,
          mm: translate$1,
          h: translate$1,
          hh: translate$1,
          d: translate$1,
          dd: translate$1,
          M: translate$1,
          MM: translate$1,
          y: translate$1,
          yy: translate$1
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("cv", {
        months: "ÐºÓ‘Ñ€Ð»Ð°Ñ‡_Ð½Ð°Ñ€Ó‘Ñ_Ð¿ÑƒÑˆ_Ð°ÐºÐ°_Ð¼Ð°Ð¹_Ò«Ó—Ñ€Ñ‚Ð¼Ðµ_ÑƒÑ‚Ó‘_Ò«ÑƒÑ€Ð»Ð°_Ð°Ð²Ó‘Ð½_ÑŽÐ¿Ð°_Ñ‡Ó³Ðº_Ñ€Ð°ÑˆÑ‚Ð°Ð²".split(
          "_"
        ),
        monthsShort: "ÐºÓ‘Ñ€_Ð½Ð°Ñ€_Ð¿ÑƒÑˆ_Ð°ÐºÐ°_Ð¼Ð°Ð¹_Ò«Ó—Ñ€_ÑƒÑ‚Ó‘_Ò«ÑƒÑ€_Ð°Ð²Ð½_ÑŽÐ¿Ð°_Ñ‡Ó³Ðº_Ñ€Ð°Ñˆ".split("_"),
        weekdays: "Ð²Ñ‹Ñ€ÑÐ°Ñ€Ð½Ð¸ÐºÑƒÐ½_Ñ‚ÑƒÐ½Ñ‚Ð¸ÐºÑƒÐ½_Ñ‹Ñ‚Ð»Ð°Ñ€Ð¸ÐºÑƒÐ½_ÑŽÐ½ÐºÑƒÐ½_ÐºÓ—Ò«Ð½ÐµÑ€Ð½Ð¸ÐºÑƒÐ½_ÑÑ€Ð½ÐµÐºÑƒÐ½_ÑˆÓ‘Ð¼Ð°Ñ‚ÐºÑƒÐ½".split(
          "_"
        ),
        weekdaysShort: "Ð²Ñ‹Ñ€_Ñ‚ÑƒÐ½_Ñ‹Ñ‚Ð»_ÑŽÐ½_ÐºÓ—Ò«_ÑÑ€Ð½_ÑˆÓ‘Ð¼".split("_"),
        weekdaysMin: "Ð²Ñ€_Ñ‚Ð½_Ñ‹Ñ‚_ÑŽÐ½_ÐºÒ«_ÑÑ€_ÑˆÐ¼".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD-MM-YYYY",
          LL: "YYYY [Ò«ÑƒÐ»Ñ…Ð¸] MMMM [ÑƒÐ¹Ó‘Ñ…Ó—Ð½] D[-Ð¼Ó—ÑˆÓ—]",
          LLL: "YYYY [Ò«ÑƒÐ»Ñ…Ð¸] MMMM [ÑƒÐ¹Ó‘Ñ…Ó—Ð½] D[-Ð¼Ó—ÑˆÓ—], HH:mm",
          LLLL: "dddd, YYYY [Ò«ÑƒÐ»Ñ…Ð¸] MMMM [ÑƒÐ¹Ó‘Ñ…Ó—Ð½] D[-Ð¼Ó—ÑˆÓ—], HH:mm"
        },
        calendar: {
          sameDay: "[ÐŸÐ°ÑÐ½] LT [ÑÐµÑ…ÐµÑ‚Ñ€Ðµ]",
          nextDay: "[Ð«Ñ€Ð°Ð½] LT [ÑÐµÑ…ÐµÑ‚Ñ€Ðµ]",
          lastDay: "[Ó–Ð½ÐµÑ€] LT [ÑÐµÑ…ÐµÑ‚Ñ€Ðµ]",
          nextWeek: "[ÒªÐ¸Ñ‚ÐµÑ] dddd LT [ÑÐµÑ…ÐµÑ‚Ñ€Ðµ]",
          lastWeek: "[Ð˜Ñ€Ñ‚Ð½Ó—] dddd LT [ÑÐµÑ…ÐµÑ‚Ñ€Ðµ]",
          sameElse: "L"
        },
        relativeTime: {
          future: function(output) {
            var affix = /ÑÐµÑ…ÐµÑ‚$/i.exec(output) ? "Ñ€ÐµÐ½" : /Ò«ÑƒÐ»$/i.exec(output) ? "Ñ‚Ð°Ð½" : "Ñ€Ð°Ð½";
            return output + affix;
          },
          past: "%s ÐºÐ°ÑÐ»Ð»Ð°",
          s: "Ð¿Ó—Ñ€-Ð¸Ðº Ò«ÐµÐºÐºÑƒÐ½Ñ‚",
          ss: "%d Ò«ÐµÐºÐºÑƒÐ½Ñ‚",
          m: "Ð¿Ó—Ñ€ Ð¼Ð¸Ð½ÑƒÑ‚",
          mm: "%d Ð¼Ð¸Ð½ÑƒÑ‚",
          h: "Ð¿Ó—Ñ€ ÑÐµÑ…ÐµÑ‚",
          hh: "%d ÑÐµÑ…ÐµÑ‚",
          d: "Ð¿Ó—Ñ€ ÐºÑƒÐ½",
          dd: "%d ÐºÑƒÐ½",
          M: "Ð¿Ó—Ñ€ ÑƒÐ¹Ó‘Ñ…",
          MM: "%d ÑƒÐ¹Ó‘Ñ…",
          y: "Ð¿Ó—Ñ€ Ò«ÑƒÐ»",
          yy: "%d Ò«ÑƒÐ»"
        },
        dayOfMonthOrdinalParse: /\d{1,2}-Ð¼Ó—Ñˆ/,
        ordinal: "%d-Ð¼Ó—Ñˆ",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("cy", {
        months: "Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split(
          "_"
        ),
        monthsShort: "Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split(
          "_"
        ),
        weekdays: "Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split(
          "_"
        ),
        weekdaysShort: "Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"),
        weekdaysMin: "Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"),
        weekdaysParseExact: true,
        // time formats are the same as en-gb
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Heddiw am] LT",
          nextDay: "[Yfory am] LT",
          nextWeek: "dddd [am] LT",
          lastDay: "[Ddoe am] LT",
          lastWeek: "dddd [diwethaf am] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "mewn %s",
          past: "%s yn Ã´l",
          s: "ychydig eiliadau",
          ss: "%d eiliad",
          m: "munud",
          mm: "%d munud",
          h: "awr",
          hh: "%d awr",
          d: "diwrnod",
          dd: "%d diwrnod",
          M: "mis",
          MM: "%d mis",
          y: "blwyddyn",
          yy: "%d flynedd"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
        ordinal: function(number2) {
          var b = number2, output = "", lookup = [
            "",
            "af",
            "il",
            "ydd",
            "ydd",
            "ed",
            "ed",
            "ed",
            "fed",
            "fed",
            "fed",
            // 1af to 10fed
            "eg",
            "fed",
            "eg",
            "eg",
            "fed",
            "eg",
            "eg",
            "fed",
            "eg",
            "fed"
            // 11eg to 20fed
          ];
          if (b > 20) {
            if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
              output = "fed";
            } else {
              output = "ain";
            }
          } else if (b > 0) {
            output = lookup[b];
          }
          return number2 + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("da", {
        months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split(
          "_"
        ),
        monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
        weekdays: "sÃ¸ndag_mandag_tirsdag_onsdag_torsdag_fredag_lÃ¸rdag".split("_"),
        weekdaysShort: "sÃ¸n_man_tir_ons_tor_fre_lÃ¸r".split("_"),
        weekdaysMin: "sÃ¸_ma_ti_on_to_fr_lÃ¸".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D. MMMM YYYY",
          LLL: "D. MMMM YYYY HH:mm",
          LLLL: "dddd [d.] D. MMMM YYYY [kl.] HH:mm"
        },
        calendar: {
          sameDay: "[i dag kl.] LT",
          nextDay: "[i morgen kl.] LT",
          nextWeek: "pÃ¥ dddd [kl.] LT",
          lastDay: "[i gÃ¥r kl.] LT",
          lastWeek: "[i] dddd[s kl.] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "om %s",
          past: "%s siden",
          s: "fÃ¥ sekunder",
          ss: "%d sekunder",
          m: "et minut",
          mm: "%d minutter",
          h: "en time",
          hh: "%d timer",
          d: "en dag",
          dd: "%d dage",
          M: "en mÃ¥ned",
          MM: "%d mÃ¥neder",
          y: "et Ã¥r",
          yy: "%d Ã¥r"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      function processRelativeTime$1(number2, withoutSuffix, key, isFuture) {
        var format2 = {
          m: ["eine Minute", "einer Minute"],
          h: ["eine Stunde", "einer Stunde"],
          d: ["ein Tag", "einem Tag"],
          dd: [number2 + " Tage", number2 + " Tagen"],
          w: ["eine Woche", "einer Woche"],
          M: ["ein Monat", "einem Monat"],
          MM: [number2 + " Monate", number2 + " Monaten"],
          y: ["ein Jahr", "einem Jahr"],
          yy: [number2 + " Jahre", number2 + " Jahren"]
        };
        return withoutSuffix ? format2[key][0] : format2[key][1];
      }
      hooks.defineLocale("de-at", {
        months: "JÃ¤nner_Februar_MÃ¤rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split(
          "_"
        ),
        monthsShort: "JÃ¤n._Feb._MÃ¤rz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
        monthsParseExact: true,
        weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split(
          "_"
        ),
        weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
        weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D. MMMM YYYY",
          LLL: "D. MMMM YYYY HH:mm",
          LLLL: "dddd, D. MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[heute um] LT [Uhr]",
          sameElse: "L",
          nextDay: "[morgen um] LT [Uhr]",
          nextWeek: "dddd [um] LT [Uhr]",
          lastDay: "[gestern um] LT [Uhr]",
          lastWeek: "[letzten] dddd [um] LT [Uhr]"
        },
        relativeTime: {
          future: "in %s",
          past: "vor %s",
          s: "ein paar Sekunden",
          ss: "%d Sekunden",
          m: processRelativeTime$1,
          mm: "%d Minuten",
          h: processRelativeTime$1,
          hh: "%d Stunden",
          d: processRelativeTime$1,
          dd: processRelativeTime$1,
          w: processRelativeTime$1,
          ww: "%d Wochen",
          M: processRelativeTime$1,
          MM: processRelativeTime$1,
          y: processRelativeTime$1,
          yy: processRelativeTime$1
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      function processRelativeTime$2(number2, withoutSuffix, key, isFuture) {
        var format2 = {
          m: ["eine Minute", "einer Minute"],
          h: ["eine Stunde", "einer Stunde"],
          d: ["ein Tag", "einem Tag"],
          dd: [number2 + " Tage", number2 + " Tagen"],
          w: ["eine Woche", "einer Woche"],
          M: ["ein Monat", "einem Monat"],
          MM: [number2 + " Monate", number2 + " Monaten"],
          y: ["ein Jahr", "einem Jahr"],
          yy: [number2 + " Jahre", number2 + " Jahren"]
        };
        return withoutSuffix ? format2[key][0] : format2[key][1];
      }
      hooks.defineLocale("de-ch", {
        months: "Januar_Februar_MÃ¤rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split(
          "_"
        ),
        monthsShort: "Jan._Feb._MÃ¤rz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
        monthsParseExact: true,
        weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split(
          "_"
        ),
        weekdaysShort: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
        weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D. MMMM YYYY",
          LLL: "D. MMMM YYYY HH:mm",
          LLLL: "dddd, D. MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[heute um] LT [Uhr]",
          sameElse: "L",
          nextDay: "[morgen um] LT [Uhr]",
          nextWeek: "dddd [um] LT [Uhr]",
          lastDay: "[gestern um] LT [Uhr]",
          lastWeek: "[letzten] dddd [um] LT [Uhr]"
        },
        relativeTime: {
          future: "in %s",
          past: "vor %s",
          s: "ein paar Sekunden",
          ss: "%d Sekunden",
          m: processRelativeTime$2,
          mm: "%d Minuten",
          h: processRelativeTime$2,
          hh: "%d Stunden",
          d: processRelativeTime$2,
          dd: processRelativeTime$2,
          w: processRelativeTime$2,
          ww: "%d Wochen",
          M: processRelativeTime$2,
          MM: processRelativeTime$2,
          y: processRelativeTime$2,
          yy: processRelativeTime$2
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      function processRelativeTime$3(number2, withoutSuffix, key, isFuture) {
        var format2 = {
          m: ["eine Minute", "einer Minute"],
          h: ["eine Stunde", "einer Stunde"],
          d: ["ein Tag", "einem Tag"],
          dd: [number2 + " Tage", number2 + " Tagen"],
          w: ["eine Woche", "einer Woche"],
          M: ["ein Monat", "einem Monat"],
          MM: [number2 + " Monate", number2 + " Monaten"],
          y: ["ein Jahr", "einem Jahr"],
          yy: [number2 + " Jahre", number2 + " Jahren"]
        };
        return withoutSuffix ? format2[key][0] : format2[key][1];
      }
      hooks.defineLocale("de", {
        months: "Januar_Februar_MÃ¤rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split(
          "_"
        ),
        monthsShort: "Jan._Feb._MÃ¤rz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
        monthsParseExact: true,
        weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split(
          "_"
        ),
        weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
        weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D. MMMM YYYY",
          LLL: "D. MMMM YYYY HH:mm",
          LLLL: "dddd, D. MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[heute um] LT [Uhr]",
          sameElse: "L",
          nextDay: "[morgen um] LT [Uhr]",
          nextWeek: "dddd [um] LT [Uhr]",
          lastDay: "[gestern um] LT [Uhr]",
          lastWeek: "[letzten] dddd [um] LT [Uhr]"
        },
        relativeTime: {
          future: "in %s",
          past: "vor %s",
          s: "ein paar Sekunden",
          ss: "%d Sekunden",
          m: processRelativeTime$3,
          mm: "%d Minuten",
          h: processRelativeTime$3,
          hh: "%d Stunden",
          d: processRelativeTime$3,
          dd: processRelativeTime$3,
          w: processRelativeTime$3,
          ww: "%d Wochen",
          M: processRelativeTime$3,
          MM: processRelativeTime$3,
          y: processRelativeTime$3,
          yy: processRelativeTime$3
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var months$5 = [
        "Þ–Þ¬Þ‚ÞªÞ‡Þ¦ÞƒÞ©",
        "ÞŠÞ¬Þ„Þ°ÞƒÞªÞ‡Þ¦ÞƒÞ©",
        "Þ‰Þ§ÞƒÞ¨Þ—Þª",
        "Þ‡Þ­Þ•Þ°ÞƒÞ©ÞÞª",
        "Þ‰Þ­",
        "Þ–Þ«Þ‚Þ°",
        "Þ–ÞªÞÞ¦Þ‡Þ¨",
        "Þ‡Þ¯ÞŽÞ¦ÞÞ°Þ“Þª",
        "ÞÞ¬Þ•Þ°Þ“Þ¬Þ‰Þ°Þ„Þ¦ÞƒÞª",
        "Þ‡Þ®Þ†Þ°Þ“Þ¯Þ„Þ¦ÞƒÞª",
        "Þ‚Þ®ÞˆÞ¬Þ‰Þ°Þ„Þ¦ÞƒÞª",
        "Þ‘Þ¨ÞÞ¬Þ‰Þ°Þ„Þ¦ÞƒÞª"
      ], weekdays = [
        "Þ‡Þ§Þ‹Þ¨Þ‡Þ°ÞŒÞ¦",
        "Þ€Þ¯Þ‰Þ¦",
        "Þ‡Þ¦Þ‚Þ°ÞŽÞ§ÞƒÞ¦",
        "Þ„ÞªÞ‹Þ¦",
        "Þ„ÞªÞƒÞ§ÞÞ°ÞŠÞ¦ÞŒÞ¨",
        "Þ€ÞªÞ†ÞªÞƒÞª",
        "Þ€Þ®Þ‚Þ¨Þ€Þ¨ÞƒÞª"
      ];
      hooks.defineLocale("dv", {
        months: months$5,
        monthsShort: months$5,
        weekdays,
        weekdaysShort: weekdays,
        weekdaysMin: "Þ‡Þ§Þ‹Þ¨_Þ€Þ¯Þ‰Þ¦_Þ‡Þ¦Þ‚Þ°_Þ„ÞªÞ‹Þ¦_Þ„ÞªÞƒÞ§_Þ€ÞªÞ†Þª_Þ€Þ®Þ‚Þ¨".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "D/M/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /Þ‰Þ†|Þ‰ÞŠ/,
        isPM: function(input) {
          return "Þ‰ÞŠ" === input;
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 12) {
            return "Þ‰Þ†";
          } else {
            return "Þ‰ÞŠ";
          }
        },
        calendar: {
          sameDay: "[Þ‰Þ¨Þ‡Þ¦Þ‹Þª] LT",
          nextDay: "[Þ‰Þ§Þ‹Þ¦Þ‰Þ§] LT",
          nextWeek: "dddd LT",
          lastDay: "[Þ‡Þ¨Þ‡Þ°Þ”Þ¬] LT",
          lastWeek: "[ÞŠÞ§Þ‡Þ¨ÞŒÞªÞˆÞ¨] dddd LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "ÞŒÞ¬ÞƒÞ­ÞŽÞ¦Þ‡Þ¨ %s",
          past: "Þ†ÞªÞƒÞ¨Þ‚Þ° %s",
          s: "ÞÞ¨Þ†ÞªÞ‚Þ°ÞŒÞªÞ†Þ®Þ…Þ¬Þ‡Þ°",
          ss: "d% ÞÞ¨Þ†ÞªÞ‚Þ°ÞŒÞª",
          m: "Þ‰Þ¨Þ‚Þ¨Þ“Þ¬Þ‡Þ°",
          mm: "Þ‰Þ¨Þ‚Þ¨Þ“Þª %d",
          h: "ÞŽÞ¦Þ‘Þ¨Þ‡Þ¨ÞƒÞ¬Þ‡Þ°",
          hh: "ÞŽÞ¦Þ‘Þ¨Þ‡Þ¨ÞƒÞª %d",
          d: "Þ‹ÞªÞˆÞ¦Þ€Þ¬Þ‡Þ°",
          dd: "Þ‹ÞªÞˆÞ¦ÞÞ° %d",
          M: "Þ‰Þ¦Þ€Þ¬Þ‡Þ°",
          MM: "Þ‰Þ¦ÞÞ° %d",
          y: "Þ‡Þ¦Þ€Þ¦ÞƒÞ¬Þ‡Þ°",
          yy: "Þ‡Þ¦Þ€Þ¦ÞƒÞª %d"
        },
        preparse: function(string2) {
          return string2.replace(/ØŒ/g, ",");
        },
        postformat: function(string2) {
          return string2.replace(/,/g, "ØŒ");
        },
        week: {
          dow: 7,
          // Sunday is the first day of the week.
          doy: 12
          // The week that contains Jan 12th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      function isFunction$1(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      hooks.defineLocale("el", {
        monthsNominativeEl: "Î™Î±Î½Î¿Ï…Î¬ÏÎ¹Î¿Ï‚_Î¦ÎµÎ²ÏÎ¿Ï…Î¬ÏÎ¹Î¿Ï‚_ÎœÎ¬ÏÏ„Î¹Î¿Ï‚_Î‘Ï€ÏÎ¯Î»Î¹Î¿Ï‚_ÎœÎ¬Î¹Î¿Ï‚_Î™Î¿ÏÎ½Î¹Î¿Ï‚_Î™Î¿ÏÎ»Î¹Î¿Ï‚_Î‘ÏÎ³Î¿Ï…ÏƒÏ„Î¿Ï‚_Î£ÎµÏ€Ï„Î­Î¼Î²ÏÎ¹Î¿Ï‚_ÎŸÎºÏ„ÏŽÎ²ÏÎ¹Î¿Ï‚_ÎÎ¿Î­Î¼Î²ÏÎ¹Î¿Ï‚_Î”ÎµÎºÎ­Î¼Î²ÏÎ¹Î¿Ï‚".split(
          "_"
        ),
        monthsGenitiveEl: "Î™Î±Î½Î¿Ï…Î±ÏÎ¯Î¿Ï…_Î¦ÎµÎ²ÏÎ¿Ï…Î±ÏÎ¯Î¿Ï…_ÎœÎ±ÏÏ„Î¯Î¿Ï…_Î‘Ï€ÏÎ¹Î»Î¯Î¿Ï…_ÎœÎ±ÎÎ¿Ï…_Î™Î¿Ï…Î½Î¯Î¿Ï…_Î™Î¿Ï…Î»Î¯Î¿Ï…_Î‘Ï…Î³Î¿ÏÏƒÏ„Î¿Ï…_Î£ÎµÏ€Ï„ÎµÎ¼Î²ÏÎ¯Î¿Ï…_ÎŸÎºÏ„Ï‰Î²ÏÎ¯Î¿Ï…_ÎÎ¿ÎµÎ¼Î²ÏÎ¯Î¿Ï…_Î”ÎµÎºÎµÎ¼Î²ÏÎ¯Î¿Ï…".split(
          "_"
        ),
        months: function(momentToFormat, format2) {
          if (!momentToFormat) {
            return this._monthsNominativeEl;
          } else if (typeof format2 === "string" && /D/.test(format2.substring(0, format2.indexOf("MMMM")))) {
            return this._monthsGenitiveEl[momentToFormat.month()];
          } else {
            return this._monthsNominativeEl[momentToFormat.month()];
          }
        },
        monthsShort: "Î™Î±Î½_Î¦ÎµÎ²_ÎœÎ±Ï_Î‘Ï€Ï_ÎœÎ±ÏŠ_Î™Î¿Ï…Î½_Î™Î¿Ï…Î»_Î‘Ï…Î³_Î£ÎµÏ€_ÎŸÎºÏ„_ÎÎ¿Îµ_Î”ÎµÎº".split("_"),
        weekdays: "ÎšÏ…ÏÎ¹Î±ÎºÎ®_Î”ÎµÏ…Ï„Î­ÏÎ±_Î¤ÏÎ¯Ï„Î·_Î¤ÎµÏ„Î¬ÏÏ„Î·_Î Î­Î¼Ï€Ï„Î·_Î Î±ÏÎ±ÏƒÎºÎµÏ…Î®_Î£Î¬Î²Î²Î±Ï„Î¿".split(
          "_"
        ),
        weekdaysShort: "ÎšÏ…Ï_Î”ÎµÏ…_Î¤ÏÎ¹_Î¤ÎµÏ„_Î ÎµÎ¼_Î Î±Ï_Î£Î±Î²".split("_"),
        weekdaysMin: "ÎšÏ…_Î”Îµ_Î¤Ï_Î¤Îµ_Î Îµ_Î Î±_Î£Î±".split("_"),
        meridiem: function(hours2, minutes2, isLower) {
          if (hours2 > 11) {
            return isLower ? "Î¼Î¼" : "ÎœÎœ";
          } else {
            return isLower ? "Ï€Î¼" : "Î Îœ";
          }
        },
        isPM: function(input) {
          return (input + "").toLowerCase()[0] === "Î¼";
        },
        meridiemParse: /[Î Îœ]\.?Îœ?\.?/i,
        longDateFormat: {
          LT: "h:mm A",
          LTS: "h:mm:ss A",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY h:mm A",
          LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendarEl: {
          sameDay: "[Î£Î®Î¼ÎµÏÎ± {}] LT",
          nextDay: "[Î‘ÏÏÎ¹Î¿ {}] LT",
          nextWeek: "dddd [{}] LT",
          lastDay: "[Î§Î¸ÎµÏ‚ {}] LT",
          lastWeek: function() {
            switch (this.day()) {
              case 6:
                return "[Ï„Î¿ Ï€ÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î¿] dddd [{}] LT";
              default:
                return "[Ï„Î·Î½ Ï€ÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î·] dddd [{}] LT";
            }
          },
          sameElse: "L"
        },
        calendar: function(key, mom) {
          var output = this._calendarEl[key], hours2 = mom && mom.hours();
          if (isFunction$1(output)) {
            output = output.apply(mom);
          }
          return output.replace("{}", hours2 % 12 === 1 ? "ÏƒÏ„Î·" : "ÏƒÏ„Î¹Ï‚");
        },
        relativeTime: {
          future: "ÏƒÎµ %s",
          past: "%s Ï€ÏÎ¹Î½",
          s: "Î»Î¯Î³Î± Î´ÎµÏ…Ï„ÎµÏÏŒÎ»ÎµÏ€Ï„Î±",
          ss: "%d Î´ÎµÏ…Ï„ÎµÏÏŒÎ»ÎµÏ€Ï„Î±",
          m: "Î­Î½Î± Î»ÎµÏ€Ï„ÏŒ",
          mm: "%d Î»ÎµÏ€Ï„Î¬",
          h: "Î¼Î¯Î± ÏŽÏÎ±",
          hh: "%d ÏŽÏÎµÏ‚",
          d: "Î¼Î¯Î± Î¼Î­ÏÎ±",
          dd: "%d Î¼Î­ÏÎµÏ‚",
          M: "Î­Î½Î±Ï‚ Î¼Î®Î½Î±Ï‚",
          MM: "%d Î¼Î®Î½ÎµÏ‚",
          y: "Î­Î½Î±Ï‚ Ï‡ÏÏŒÎ½Î¿Ï‚",
          yy: "%d Ï‡ÏÏŒÎ½Î¹Î±"
        },
        dayOfMonthOrdinalParse: /\d{1,2}Î·/,
        ordinal: "%dÎ·",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4st is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("en-au", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split(
          "_"
        ),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
          "_"
        ),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
          LT: "h:mm A",
          LTS: "h:mm:ss A",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY h:mm A",
          LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendar: {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number2) {
          var b = number2 % 10, output = ~~(number2 % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number2 + output;
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("en-ca", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split(
          "_"
        ),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
          "_"
        ),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
          LT: "h:mm A",
          LTS: "h:mm:ss A",
          L: "YYYY-MM-DD",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY h:mm A",
          LLLL: "dddd, MMMM D, YYYY h:mm A"
        },
        calendar: {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number2) {
          var b = number2 % 10, output = ~~(number2 % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number2 + output;
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("en-gb", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split(
          "_"
        ),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
          "_"
        ),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number2) {
          var b = number2 % 10, output = ~~(number2 % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number2 + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("en-ie", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split(
          "_"
        ),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
          "_"
        ),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number2) {
          var b = number2 % 10, output = ~~(number2 % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number2 + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("en-il", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split(
          "_"
        ),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
          "_"
        ),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number2) {
          var b = number2 % 10, output = ~~(number2 % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number2 + output;
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("en-in", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split(
          "_"
        ),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
          "_"
        ),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
          LT: "h:mm A",
          LTS: "h:mm:ss A",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY h:mm A",
          LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendar: {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number2) {
          var b = number2 % 10, output = ~~(number2 % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number2 + output;
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 1st is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("en-nz", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split(
          "_"
        ),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
          "_"
        ),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
          LT: "h:mm A",
          LTS: "h:mm:ss A",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY h:mm A",
          LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendar: {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number2) {
          var b = number2 % 10, output = ~~(number2 % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number2 + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("en-sg", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split(
          "_"
        ),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
          "_"
        ),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number2) {
          var b = number2 % 10, output = ~~(number2 % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number2 + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("eo", {
        months: "januaro_februaro_marto_aprilo_majo_junio_julio_aÅ­gusto_septembro_oktobro_novembro_decembro".split(
          "_"
        ),
        monthsShort: "jan_feb_mart_apr_maj_jun_jul_aÅ­g_sept_okt_nov_dec".split("_"),
        weekdays: "dimanÄ‰o_lundo_mardo_merkredo_ÄµaÅ­do_vendredo_sabato".split("_"),
        weekdaysShort: "dim_lun_mard_merk_ÄµaÅ­_ven_sab".split("_"),
        weekdaysMin: "di_lu_ma_me_Äµa_ve_sa".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "YYYY-MM-DD",
          LL: "[la] D[-an de] MMMM, YYYY",
          LLL: "[la] D[-an de] MMMM, YYYY HH:mm",
          LLLL: "dddd[n], [la] D[-an de] MMMM, YYYY HH:mm",
          llll: "ddd, [la] D[-an de] MMM, YYYY HH:mm"
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function(input) {
          return input.charAt(0).toLowerCase() === "p";
        },
        meridiem: function(hours2, minutes2, isLower) {
          if (hours2 > 11) {
            return isLower ? "p.t.m." : "P.T.M.";
          } else {
            return isLower ? "a.t.m." : "A.T.M.";
          }
        },
        calendar: {
          sameDay: "[HodiaÅ­ je] LT",
          nextDay: "[MorgaÅ­ je] LT",
          nextWeek: "dddd[n je] LT",
          lastDay: "[HieraÅ­ je] LT",
          lastWeek: "[pasintan] dddd[n je] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "post %s",
          past: "antaÅ­ %s",
          s: "kelkaj sekundoj",
          ss: "%d sekundoj",
          m: "unu minuto",
          mm: "%d minutoj",
          h: "unu horo",
          hh: "%d horoj",
          d: "unu tago",
          //ne 'diurno', Ä‰ar estas uzita por proksimumo
          dd: "%d tagoj",
          M: "unu monato",
          MM: "%d monatoj",
          y: "unu jaro",
          yy: "%d jaroj"
        },
        dayOfMonthOrdinalParse: /\d{1,2}a/,
        ordinal: "%da",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split(
        "_"
      ), monthsShort$1 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse$2 = [
        /^ene/i,
        /^feb/i,
        /^mar/i,
        /^abr/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^ago/i,
        /^sep/i,
        /^oct/i,
        /^nov/i,
        /^dic/i
      ], monthsRegex$3 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
      hooks.defineLocale("es-do", {
        months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split(
          "_"
        ),
        monthsShort: function(m2, format2) {
          if (!m2) {
            return monthsShortDot;
          } else if (/-MMM-/.test(format2)) {
            return monthsShort$1[m2.month()];
          } else {
            return monthsShortDot[m2.month()];
          }
        },
        monthsRegex: monthsRegex$3,
        monthsShortRegex: monthsRegex$3,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse$2,
        longMonthsParse: monthsParse$2,
        shortMonthsParse: monthsParse$2,
        weekdays: "domingo_lunes_martes_miÃ©rcoles_jueves_viernes_sÃ¡bado".split("_"),
        weekdaysShort: "dom._lun._mar._miÃ©._jue._vie._sÃ¡b.".split("_"),
        weekdaysMin: "do_lu_ma_mi_ju_vi_sÃ¡".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "h:mm A",
          LTS: "h:mm:ss A",
          L: "DD/MM/YYYY",
          LL: "D [de] MMMM [de] YYYY",
          LLL: "D [de] MMMM [de] YYYY h:mm A",
          LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A"
        },
        calendar: {
          sameDay: function() {
            return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          nextDay: function() {
            return "[maÃ±ana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          nextWeek: function() {
            return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          lastDay: function() {
            return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          lastWeek: function() {
            return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "en %s",
          past: "hace %s",
          s: "unos segundos",
          ss: "%d segundos",
          m: "un minuto",
          mm: "%d minutos",
          h: "una hora",
          hh: "%d horas",
          d: "un dÃ­a",
          dd: "%d dÃ­as",
          w: "una semana",
          ww: "%d semanas",
          M: "un mes",
          MM: "%d meses",
          y: "un aÃ±o",
          yy: "%d aÃ±os"
        },
        dayOfMonthOrdinalParse: /\d{1,2}Âº/,
        ordinal: "%dÂº",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var monthsShortDot$1 = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split(
        "_"
      ), monthsShort$2 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse$3 = [
        /^ene/i,
        /^feb/i,
        /^mar/i,
        /^abr/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^ago/i,
        /^sep/i,
        /^oct/i,
        /^nov/i,
        /^dic/i
      ], monthsRegex$4 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
      hooks.defineLocale("es-mx", {
        months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split(
          "_"
        ),
        monthsShort: function(m2, format2) {
          if (!m2) {
            return monthsShortDot$1;
          } else if (/-MMM-/.test(format2)) {
            return monthsShort$2[m2.month()];
          } else {
            return monthsShortDot$1[m2.month()];
          }
        },
        monthsRegex: monthsRegex$4,
        monthsShortRegex: monthsRegex$4,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse$3,
        longMonthsParse: monthsParse$3,
        shortMonthsParse: monthsParse$3,
        weekdays: "domingo_lunes_martes_miÃ©rcoles_jueves_viernes_sÃ¡bado".split("_"),
        weekdaysShort: "dom._lun._mar._miÃ©._jue._vie._sÃ¡b.".split("_"),
        weekdaysMin: "do_lu_ma_mi_ju_vi_sÃ¡".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D [de] MMMM [de] YYYY",
          LLL: "D [de] MMMM [de] YYYY H:mm",
          LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
        },
        calendar: {
          sameDay: function() {
            return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          nextDay: function() {
            return "[maÃ±ana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          nextWeek: function() {
            return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          lastDay: function() {
            return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          lastWeek: function() {
            return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "en %s",
          past: "hace %s",
          s: "unos segundos",
          ss: "%d segundos",
          m: "un minuto",
          mm: "%d minutos",
          h: "una hora",
          hh: "%d horas",
          d: "un dÃ­a",
          dd: "%d dÃ­as",
          w: "una semana",
          ww: "%d semanas",
          M: "un mes",
          MM: "%d meses",
          y: "un aÃ±o",
          yy: "%d aÃ±os"
        },
        dayOfMonthOrdinalParse: /\d{1,2}Âº/,
        ordinal: "%dÂº",
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        },
        invalidDate: "Fecha invÃ¡lida"
      });
      //! moment.js locale configuration
      var monthsShortDot$2 = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split(
        "_"
      ), monthsShort$3 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse$4 = [
        /^ene/i,
        /^feb/i,
        /^mar/i,
        /^abr/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^ago/i,
        /^sep/i,
        /^oct/i,
        /^nov/i,
        /^dic/i
      ], monthsRegex$5 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
      hooks.defineLocale("es-us", {
        months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split(
          "_"
        ),
        monthsShort: function(m2, format2) {
          if (!m2) {
            return monthsShortDot$2;
          } else if (/-MMM-/.test(format2)) {
            return monthsShort$3[m2.month()];
          } else {
            return monthsShortDot$2[m2.month()];
          }
        },
        monthsRegex: monthsRegex$5,
        monthsShortRegex: monthsRegex$5,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse$4,
        longMonthsParse: monthsParse$4,
        shortMonthsParse: monthsParse$4,
        weekdays: "domingo_lunes_martes_miÃ©rcoles_jueves_viernes_sÃ¡bado".split("_"),
        weekdaysShort: "dom._lun._mar._miÃ©._jue._vie._sÃ¡b.".split("_"),
        weekdaysMin: "do_lu_ma_mi_ju_vi_sÃ¡".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "h:mm A",
          LTS: "h:mm:ss A",
          L: "MM/DD/YYYY",
          LL: "D [de] MMMM [de] YYYY",
          LLL: "D [de] MMMM [de] YYYY h:mm A",
          LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A"
        },
        calendar: {
          sameDay: function() {
            return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          nextDay: function() {
            return "[maÃ±ana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          nextWeek: function() {
            return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          lastDay: function() {
            return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          lastWeek: function() {
            return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "en %s",
          past: "hace %s",
          s: "unos segundos",
          ss: "%d segundos",
          m: "un minuto",
          mm: "%d minutos",
          h: "una hora",
          hh: "%d horas",
          d: "un dÃ­a",
          dd: "%d dÃ­as",
          w: "una semana",
          ww: "%d semanas",
          M: "un mes",
          MM: "%d meses",
          y: "un aÃ±o",
          yy: "%d aÃ±os"
        },
        dayOfMonthOrdinalParse: /\d{1,2}Âº/,
        ordinal: "%dÂº",
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var monthsShortDot$3 = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split(
        "_"
      ), monthsShort$4 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse$5 = [
        /^ene/i,
        /^feb/i,
        /^mar/i,
        /^abr/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^ago/i,
        /^sep/i,
        /^oct/i,
        /^nov/i,
        /^dic/i
      ], monthsRegex$6 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
      hooks.defineLocale("es", {
        months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split(
          "_"
        ),
        monthsShort: function(m2, format2) {
          if (!m2) {
            return monthsShortDot$3;
          } else if (/-MMM-/.test(format2)) {
            return monthsShort$4[m2.month()];
          } else {
            return monthsShortDot$3[m2.month()];
          }
        },
        monthsRegex: monthsRegex$6,
        monthsShortRegex: monthsRegex$6,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse$5,
        longMonthsParse: monthsParse$5,
        shortMonthsParse: monthsParse$5,
        weekdays: "domingo_lunes_martes_miÃ©rcoles_jueves_viernes_sÃ¡bado".split("_"),
        weekdaysShort: "dom._lun._mar._miÃ©._jue._vie._sÃ¡b.".split("_"),
        weekdaysMin: "do_lu_ma_mi_ju_vi_sÃ¡".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D [de] MMMM [de] YYYY",
          LLL: "D [de] MMMM [de] YYYY H:mm",
          LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
        },
        calendar: {
          sameDay: function() {
            return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          nextDay: function() {
            return "[maÃ±ana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          nextWeek: function() {
            return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          lastDay: function() {
            return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          lastWeek: function() {
            return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "en %s",
          past: "hace %s",
          s: "unos segundos",
          ss: "%d segundos",
          m: "un minuto",
          mm: "%d minutos",
          h: "una hora",
          hh: "%d horas",
          d: "un dÃ­a",
          dd: "%d dÃ­as",
          w: "una semana",
          ww: "%d semanas",
          M: "un mes",
          MM: "%d meses",
          y: "un aÃ±o",
          yy: "%d aÃ±os"
        },
        dayOfMonthOrdinalParse: /\d{1,2}Âº/,
        ordinal: "%dÂº",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        },
        invalidDate: "Fecha invÃ¡lida"
      });
      //! moment.js locale configuration
      function processRelativeTime$4(number2, withoutSuffix, key, isFuture) {
        var format2 = {
          s: ["mÃµne sekundi", "mÃµni sekund", "paar sekundit"],
          ss: [number2 + "sekundi", number2 + "sekundit"],
          m: ["Ã¼he minuti", "Ã¼ks minut"],
          mm: [number2 + " minuti", number2 + " minutit"],
          h: ["Ã¼he tunni", "tund aega", "Ã¼ks tund"],
          hh: [number2 + " tunni", number2 + " tundi"],
          d: ["Ã¼he pÃ¤eva", "Ã¼ks pÃ¤ev"],
          M: ["kuu aja", "kuu aega", "Ã¼ks kuu"],
          MM: [number2 + " kuu", number2 + " kuud"],
          y: ["Ã¼he aasta", "aasta", "Ã¼ks aasta"],
          yy: [number2 + " aasta", number2 + " aastat"]
        };
        if (withoutSuffix) {
          return format2[key][2] ? format2[key][2] : format2[key][1];
        }
        return isFuture ? format2[key][0] : format2[key][1];
      }
      hooks.defineLocale("et", {
        months: "jaanuar_veebruar_mÃ¤rts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split(
          "_"
        ),
        monthsShort: "jaan_veebr_mÃ¤rts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"),
        weekdays: "pÃ¼hapÃ¤ev_esmaspÃ¤ev_teisipÃ¤ev_kolmapÃ¤ev_neljapÃ¤ev_reede_laupÃ¤ev".split(
          "_"
        ),
        weekdaysShort: "P_E_T_K_N_R_L".split("_"),
        weekdaysMin: "P_E_T_K_N_R_L".split("_"),
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D. MMMM YYYY",
          LLL: "D. MMMM YYYY H:mm",
          LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
          sameDay: "[TÃ¤na,] LT",
          nextDay: "[Homme,] LT",
          nextWeek: "[JÃ¤rgmine] dddd LT",
          lastDay: "[Eile,] LT",
          lastWeek: "[Eelmine] dddd LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s pÃ¤rast",
          past: "%s tagasi",
          s: processRelativeTime$4,
          ss: processRelativeTime$4,
          m: processRelativeTime$4,
          mm: processRelativeTime$4,
          h: processRelativeTime$4,
          hh: processRelativeTime$4,
          d: processRelativeTime$4,
          dd: "%d pÃ¤eva",
          M: processRelativeTime$4,
          MM: processRelativeTime$4,
          y: processRelativeTime$4,
          yy: processRelativeTime$4
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("eu", {
        months: "urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split(
          "_"
        ),
        monthsShort: "urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split(
          "_"
        ),
        weekdaysShort: "ig._al._ar._az._og._ol._lr.".split("_"),
        weekdaysMin: "ig_al_ar_az_og_ol_lr".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "YYYY-MM-DD",
          LL: "YYYY[ko] MMMM[ren] D[a]",
          LLL: "YYYY[ko] MMMM[ren] D[a] HH:mm",
          LLLL: "dddd, YYYY[ko] MMMM[ren] D[a] HH:mm",
          l: "YYYY-M-D",
          ll: "YYYY[ko] MMM D[a]",
          lll: "YYYY[ko] MMM D[a] HH:mm",
          llll: "ddd, YYYY[ko] MMM D[a] HH:mm"
        },
        calendar: {
          sameDay: "[gaur] LT[etan]",
          nextDay: "[bihar] LT[etan]",
          nextWeek: "dddd LT[etan]",
          lastDay: "[atzo] LT[etan]",
          lastWeek: "[aurreko] dddd LT[etan]",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s barru",
          past: "duela %s",
          s: "segundo batzuk",
          ss: "%d segundo",
          m: "minutu bat",
          mm: "%d minutu",
          h: "ordu bat",
          hh: "%d ordu",
          d: "egun bat",
          dd: "%d egun",
          M: "hilabete bat",
          MM: "%d hilabete",
          y: "urte bat",
          yy: "%d urte"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var symbolMap$7 = {
        1: "Û±",
        2: "Û²",
        3: "Û³",
        4: "Û´",
        5: "Ûµ",
        6: "Û¶",
        7: "Û·",
        8: "Û¸",
        9: "Û¹",
        0: "Û°"
      }, numberMap$6 = {
        "Û±": "1",
        "Û²": "2",
        "Û³": "3",
        "Û´": "4",
        "Ûµ": "5",
        "Û¶": "6",
        "Û·": "7",
        "Û¸": "8",
        "Û¹": "9",
        "Û°": "0"
      };
      hooks.defineLocale("fa", {
        months: "Ú˜Ø§Ù†ÙˆÛŒÙ‡_ÙÙˆØ±ÛŒÙ‡_Ù…Ø§Ø±Ø³_Ø¢ÙˆØ±ÛŒÙ„_Ù…Ù‡_Ú˜ÙˆØ¦Ù†_Ú˜ÙˆØ¦ÛŒÙ‡_Ø§ÙˆØª_Ø³Ù¾ØªØ§Ù…Ø¨Ø±_Ø§Ú©ØªØ¨Ø±_Ù†ÙˆØ§Ù…Ø¨Ø±_Ø¯Ø³Ø§Ù…Ø¨Ø±".split(
          "_"
        ),
        monthsShort: "Ú˜Ø§Ù†ÙˆÛŒÙ‡_ÙÙˆØ±ÛŒÙ‡_Ù…Ø§Ø±Ø³_Ø¢ÙˆØ±ÛŒÙ„_Ù…Ù‡_Ú˜ÙˆØ¦Ù†_Ú˜ÙˆØ¦ÛŒÙ‡_Ø§ÙˆØª_Ø³Ù¾ØªØ§Ù…Ø¨Ø±_Ø§Ú©ØªØ¨Ø±_Ù†ÙˆØ§Ù…Ø¨Ø±_Ø¯Ø³Ø§Ù…Ø¨Ø±".split(
          "_"
        ),
        weekdays: "ÛŒÚ©â€ŒØ´Ù†Ø¨Ù‡_Ø¯ÙˆØ´Ù†Ø¨Ù‡_Ø³Ù‡â€ŒØ´Ù†Ø¨Ù‡_Ú†Ù‡Ø§Ø±Ø´Ù†Ø¨Ù‡_Ù¾Ù†Ø¬â€ŒØ´Ù†Ø¨Ù‡_Ø¬Ù…Ø¹Ù‡_Ø´Ù†Ø¨Ù‡".split(
          "_"
        ),
        weekdaysShort: "ÛŒÚ©â€ŒØ´Ù†Ø¨Ù‡_Ø¯ÙˆØ´Ù†Ø¨Ù‡_Ø³Ù‡â€ŒØ´Ù†Ø¨Ù‡_Ú†Ù‡Ø§Ø±Ø´Ù†Ø¨Ù‡_Ù¾Ù†Ø¬â€ŒØ´Ù†Ø¨Ù‡_Ø¬Ù…Ø¹Ù‡_Ø´Ù†Ø¨Ù‡".split(
          "_"
        ),
        weekdaysMin: "ÛŒ_Ø¯_Ø³_Ú†_Ù¾_Ø¬_Ø´".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        meridiemParse: /Ù‚Ø¨Ù„ Ø§Ø² Ø¸Ù‡Ø±|Ø¨Ø¹Ø¯ Ø§Ø² Ø¸Ù‡Ø±/,
        isPM: function(input) {
          return /Ø¨Ø¹Ø¯ Ø§Ø² Ø¸Ù‡Ø±/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 12) {
            return "Ù‚Ø¨Ù„ Ø§Ø² Ø¸Ù‡Ø±";
          } else {
            return "Ø¨Ø¹Ø¯ Ø§Ø² Ø¸Ù‡Ø±";
          }
        },
        calendar: {
          sameDay: "[Ø§Ù…Ø±ÙˆØ² Ø³Ø§Ø¹Øª] LT",
          nextDay: "[ÙØ±Ø¯Ø§ Ø³Ø§Ø¹Øª] LT",
          nextWeek: "dddd [Ø³Ø§Ø¹Øª] LT",
          lastDay: "[Ø¯ÛŒØ±ÙˆØ² Ø³Ø§Ø¹Øª] LT",
          lastWeek: "dddd [Ù¾ÛŒØ´] [Ø³Ø§Ø¹Øª] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "Ø¯Ø± %s",
          past: "%s Ù¾ÛŒØ´",
          s: "Ú†Ù†Ø¯ Ø«Ø§Ù†ÛŒÙ‡",
          ss: "%d Ø«Ø§Ù†ÛŒÙ‡",
          m: "ÛŒÚ© Ø¯Ù‚ÛŒÙ‚Ù‡",
          mm: "%d Ø¯Ù‚ÛŒÙ‚Ù‡",
          h: "ÛŒÚ© Ø³Ø§Ø¹Øª",
          hh: "%d Ø³Ø§Ø¹Øª",
          d: "ÛŒÚ© Ø±ÙˆØ²",
          dd: "%d Ø±ÙˆØ²",
          M: "ÛŒÚ© Ù…Ø§Ù‡",
          MM: "%d Ù…Ø§Ù‡",
          y: "ÛŒÚ© Ø³Ø§Ù„",
          yy: "%d Ø³Ø§Ù„"
        },
        preparse: function(string2) {
          return string2.replace(/[Û°-Û¹]/g, function(match) {
            return numberMap$6[match];
          }).replace(/ØŒ/g, ",");
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap$7[match];
          }).replace(/,/g, "ØŒ");
        },
        dayOfMonthOrdinalParse: /\d{1,2}Ù…/,
        ordinal: "%dÙ…",
        week: {
          dow: 6,
          // Saturday is the first day of the week.
          doy: 12
          // The week that contains Jan 12th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var numbersPast = "nolla yksi kaksi kolme neljÃ¤ viisi kuusi seitsemÃ¤n kahdeksan yhdeksÃ¤n".split(
        " "
      ), numbersFuture = [
        "nolla",
        "yhden",
        "kahden",
        "kolmen",
        "neljÃ¤n",
        "viiden",
        "kuuden",
        numbersPast[7],
        numbersPast[8],
        numbersPast[9]
      ];
      function translate$2(number2, withoutSuffix, key, isFuture) {
        var result = "";
        switch (key) {
          case "s":
            return isFuture ? "muutaman sekunnin" : "muutama sekunti";
          case "ss":
            result = isFuture ? "sekunnin" : "sekuntia";
            break;
          case "m":
            return isFuture ? "minuutin" : "minuutti";
          case "mm":
            result = isFuture ? "minuutin" : "minuuttia";
            break;
          case "h":
            return isFuture ? "tunnin" : "tunti";
          case "hh":
            result = isFuture ? "tunnin" : "tuntia";
            break;
          case "d":
            return isFuture ? "pÃ¤ivÃ¤n" : "pÃ¤ivÃ¤";
          case "dd":
            result = isFuture ? "pÃ¤ivÃ¤n" : "pÃ¤ivÃ¤Ã¤";
            break;
          case "M":
            return isFuture ? "kuukauden" : "kuukausi";
          case "MM":
            result = isFuture ? "kuukauden" : "kuukautta";
            break;
          case "y":
            return isFuture ? "vuoden" : "vuosi";
          case "yy":
            result = isFuture ? "vuoden" : "vuotta";
            break;
        }
        result = verbalNumber(number2, isFuture) + " " + result;
        return result;
      }
      function verbalNumber(number2, isFuture) {
        return number2 < 10 ? isFuture ? numbersFuture[number2] : numbersPast[number2] : number2;
      }
      hooks.defineLocale("fi", {
        months: "tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesÃ¤kuu_heinÃ¤kuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split(
          "_"
        ),
        monthsShort: "tammi_helmi_maalis_huhti_touko_kesÃ¤_heinÃ¤_elo_syys_loka_marras_joulu".split(
          "_"
        ),
        weekdays: "sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split(
          "_"
        ),
        weekdaysShort: "su_ma_ti_ke_to_pe_la".split("_"),
        weekdaysMin: "su_ma_ti_ke_to_pe_la".split("_"),
        longDateFormat: {
          LT: "HH.mm",
          LTS: "HH.mm.ss",
          L: "DD.MM.YYYY",
          LL: "Do MMMM[ta] YYYY",
          LLL: "Do MMMM[ta] YYYY, [klo] HH.mm",
          LLLL: "dddd, Do MMMM[ta] YYYY, [klo] HH.mm",
          l: "D.M.YYYY",
          ll: "Do MMM YYYY",
          lll: "Do MMM YYYY, [klo] HH.mm",
          llll: "ddd, Do MMM YYYY, [klo] HH.mm"
        },
        calendar: {
          sameDay: "[tÃ¤nÃ¤Ã¤n] [klo] LT",
          nextDay: "[huomenna] [klo] LT",
          nextWeek: "dddd [klo] LT",
          lastDay: "[eilen] [klo] LT",
          lastWeek: "[viime] dddd[na] [klo] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s pÃ¤Ã¤stÃ¤",
          past: "%s sitten",
          s: translate$2,
          ss: translate$2,
          m: translate$2,
          mm: translate$2,
          h: translate$2,
          hh: translate$2,
          d: translate$2,
          dd: translate$2,
          M: translate$2,
          MM: translate$2,
          y: translate$2,
          yy: translate$2
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("fil", {
        months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split(
          "_"
        ),
        monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
        weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split(
          "_"
        ),
        weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
        weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "MM/D/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY HH:mm",
          LLLL: "dddd, MMMM DD, YYYY HH:mm"
        },
        calendar: {
          sameDay: "LT [ngayong araw]",
          nextDay: "[Bukas ng] LT",
          nextWeek: "LT [sa susunod na] dddd",
          lastDay: "LT [kahapon]",
          lastWeek: "LT [noong nakaraang] dddd",
          sameElse: "L"
        },
        relativeTime: {
          future: "sa loob ng %s",
          past: "%s ang nakalipas",
          s: "ilang segundo",
          ss: "%d segundo",
          m: "isang minuto",
          mm: "%d minuto",
          h: "isang oras",
          hh: "%d oras",
          d: "isang araw",
          dd: "%d araw",
          M: "isang buwan",
          MM: "%d buwan",
          y: "isang taon",
          yy: "%d taon"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function(number2) {
          return number2;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("fo", {
        months: "januar_februar_mars_aprÃ­l_mai_juni_juli_august_september_oktober_november_desember".split(
          "_"
        ),
        monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
        weekdays: "sunnudagur_mÃ¡nadagur_tÃ½sdagur_mikudagur_hÃ³sdagur_frÃ­ggjadagur_leygardagur".split(
          "_"
        ),
        weekdaysShort: "sun_mÃ¡n_tÃ½s_mik_hÃ³s_frÃ­_ley".split("_"),
        weekdaysMin: "su_mÃ¡_tÃ½_mi_hÃ³_fr_le".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D. MMMM, YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Ã dag kl.] LT",
          nextDay: "[Ã morgin kl.] LT",
          nextWeek: "dddd [kl.] LT",
          lastDay: "[Ã gjÃ¡r kl.] LT",
          lastWeek: "[sÃ­Ã°stu] dddd [kl] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "um %s",
          past: "%s sÃ­Ã°ani",
          s: "fÃ¡ sekund",
          ss: "%d sekundir",
          m: "ein minuttur",
          mm: "%d minuttir",
          h: "ein tÃ­mi",
          hh: "%d tÃ­mar",
          d: "ein dagur",
          dd: "%d dagar",
          M: "ein mÃ¡naÃ°ur",
          MM: "%d mÃ¡naÃ°ir",
          y: "eitt Ã¡r",
          yy: "%d Ã¡r"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("fr-ca", {
        months: "janvier_fÃ©vrier_mars_avril_mai_juin_juillet_aoÃ»t_septembre_octobre_novembre_dÃ©cembre".split(
          "_"
        ),
        monthsShort: "janv._fÃ©vr._mars_avr._mai_juin_juil._aoÃ»t_sept._oct._nov._dÃ©c.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
        weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
        weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "YYYY-MM-DD",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Aujourdâ€™hui Ã ] LT",
          nextDay: "[Demain Ã ] LT",
          nextWeek: "dddd [Ã ] LT",
          lastDay: "[Hier Ã ] LT",
          lastWeek: "dddd [dernier Ã ] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "dans %s",
          past: "il y a %s",
          s: "quelques secondes",
          ss: "%d secondes",
          m: "une minute",
          mm: "%d minutes",
          h: "une heure",
          hh: "%d heures",
          d: "un jour",
          dd: "%d jours",
          M: "un mois",
          MM: "%d mois",
          y: "un an",
          yy: "%d ans"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal: function(number2, period) {
          switch (period) {
            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case "M":
            case "Q":
            case "D":
            case "DDD":
            case "d":
              return number2 + (number2 === 1 ? "er" : "e");
            // Words with feminine grammatical gender: semaine
            case "w":
            case "W":
              return number2 + (number2 === 1 ? "re" : "e");
          }
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("fr-ch", {
        months: "janvier_fÃ©vrier_mars_avril_mai_juin_juillet_aoÃ»t_septembre_octobre_novembre_dÃ©cembre".split(
          "_"
        ),
        monthsShort: "janv._fÃ©vr._mars_avr._mai_juin_juil._aoÃ»t_sept._oct._nov._dÃ©c.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
        weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
        weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Aujourdâ€™hui Ã ] LT",
          nextDay: "[Demain Ã ] LT",
          nextWeek: "dddd [Ã ] LT",
          lastDay: "[Hier Ã ] LT",
          lastWeek: "dddd [dernier Ã ] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "dans %s",
          past: "il y a %s",
          s: "quelques secondes",
          ss: "%d secondes",
          m: "une minute",
          mm: "%d minutes",
          h: "une heure",
          hh: "%d heures",
          d: "un jour",
          dd: "%d jours",
          M: "un mois",
          MM: "%d mois",
          y: "un an",
          yy: "%d ans"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal: function(number2, period) {
          switch (period) {
            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case "M":
            case "Q":
            case "D":
            case "DDD":
            case "d":
              return number2 + (number2 === 1 ? "er" : "e");
            // Words with feminine grammatical gender: semaine
            case "w":
            case "W":
              return number2 + (number2 === 1 ? "re" : "e");
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var monthsStrictRegex$1 = /^(janvier|fÃ©vrier|mars|avril|mai|juin|juillet|aoÃ»t|septembre|octobre|novembre|dÃ©cembre)/i, monthsShortStrictRegex$1 = /(janv\.?|fÃ©vr\.?|mars|avr\.?|mai|juin|juil\.?|aoÃ»t|sept\.?|oct\.?|nov\.?|dÃ©c\.?)/i, monthsRegex$7 = /(janv\.?|fÃ©vr\.?|mars|avr\.?|mai|juin|juil\.?|aoÃ»t|sept\.?|oct\.?|nov\.?|dÃ©c\.?|janvier|fÃ©vrier|mars|avril|mai|juin|juillet|aoÃ»t|septembre|octobre|novembre|dÃ©cembre)/i, monthsParse$6 = [
        /^janv/i,
        /^fÃ©vr/i,
        /^mars/i,
        /^avr/i,
        /^mai/i,
        /^juin/i,
        /^juil/i,
        /^aoÃ»t/i,
        /^sept/i,
        /^oct/i,
        /^nov/i,
        /^dÃ©c/i
      ];
      hooks.defineLocale("fr", {
        months: "janvier_fÃ©vrier_mars_avril_mai_juin_juillet_aoÃ»t_septembre_octobre_novembre_dÃ©cembre".split(
          "_"
        ),
        monthsShort: "janv._fÃ©vr._mars_avr._mai_juin_juil._aoÃ»t_sept._oct._nov._dÃ©c.".split(
          "_"
        ),
        monthsRegex: monthsRegex$7,
        monthsShortRegex: monthsRegex$7,
        monthsStrictRegex: monthsStrictRegex$1,
        monthsShortStrictRegex: monthsShortStrictRegex$1,
        monthsParse: monthsParse$6,
        longMonthsParse: monthsParse$6,
        shortMonthsParse: monthsParse$6,
        weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
        weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
        weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Aujourdâ€™hui Ã ] LT",
          nextDay: "[Demain Ã ] LT",
          nextWeek: "dddd [Ã ] LT",
          lastDay: "[Hier Ã ] LT",
          lastWeek: "dddd [dernier Ã ] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "dans %s",
          past: "il y a %s",
          s: "quelques secondes",
          ss: "%d secondes",
          m: "une minute",
          mm: "%d minutes",
          h: "une heure",
          hh: "%d heures",
          d: "un jour",
          dd: "%d jours",
          w: "une semaine",
          ww: "%d semaines",
          M: "un mois",
          MM: "%d mois",
          y: "un an",
          yy: "%d ans"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
        ordinal: function(number2, period) {
          switch (period) {
            // TODO: Return 'e' when day of month > 1. Move this case inside
            // block for masculine words below.
            // See https://github.com/moment/moment/issues/3375
            case "D":
              return number2 + (number2 === 1 ? "er" : "");
            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case "M":
            case "Q":
            case "DDD":
            case "d":
              return number2 + (number2 === 1 ? "er" : "e");
            // Words with feminine grammatical gender: semaine
            case "w":
            case "W":
              return number2 + (number2 === 1 ? "re" : "e");
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var monthsShortWithDots = "jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_"), monthsShortWithoutDots = "jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_");
      hooks.defineLocale("fy", {
        months: "jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split(
          "_"
        ),
        monthsShort: function(m2, format2) {
          if (!m2) {
            return monthsShortWithDots;
          } else if (/-MMM-/.test(format2)) {
            return monthsShortWithoutDots[m2.month()];
          } else {
            return monthsShortWithDots[m2.month()];
          }
        },
        monthsParseExact: true,
        weekdays: "snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split(
          "_"
        ),
        weekdaysShort: "si._mo._ti._wo._to._fr._so.".split("_"),
        weekdaysMin: "Si_Mo_Ti_Wo_To_Fr_So".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD-MM-YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[hjoed om] LT",
          nextDay: "[moarn om] LT",
          nextWeek: "dddd [om] LT",
          lastDay: "[juster om] LT",
          lastWeek: "[Ã´frÃ»ne] dddd [om] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "oer %s",
          past: "%s lyn",
          s: "in pear sekonden",
          ss: "%d sekonden",
          m: "ien minÃºt",
          mm: "%d minuten",
          h: "ien oere",
          hh: "%d oeren",
          d: "ien dei",
          dd: "%d dagen",
          M: "ien moanne",
          MM: "%d moannen",
          y: "ien jier",
          yy: "%d jierren"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function(number2) {
          return number2 + (number2 === 1 || number2 === 8 || number2 >= 20 ? "ste" : "de");
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var months$6 = [
        "EanÃ¡ir",
        "Feabhra",
        "MÃ¡rta",
        "AibreÃ¡n",
        "Bealtaine",
        "Meitheamh",
        "IÃºil",
        "LÃºnasa",
        "MeÃ¡n FÃ³mhair",
        "Deireadh FÃ³mhair",
        "Samhain",
        "Nollaig"
      ], monthsShort$5 = [
        "Ean",
        "Feabh",
        "MÃ¡rt",
        "Aib",
        "Beal",
        "Meith",
        "IÃºil",
        "LÃºn",
        "M.F.",
        "D.F.",
        "Samh",
        "Noll"
      ], weekdays$1 = [
        "DÃ© Domhnaigh",
        "DÃ© Luain",
        "DÃ© MÃ¡irt",
        "DÃ© CÃ©adaoin",
        "DÃ©ardaoin",
        "DÃ© hAoine",
        "DÃ© Sathairn"
      ], weekdaysShort = ["Domh", "Luan", "MÃ¡irt", "CÃ©ad", "DÃ©ar", "Aoine", "Sath"], weekdaysMin = ["Do", "Lu", "MÃ¡", "CÃ©", "DÃ©", "A", "Sa"];
      hooks.defineLocale("ga", {
        months: months$6,
        monthsShort: monthsShort$5,
        monthsParseExact: true,
        weekdays: weekdays$1,
        weekdaysShort,
        weekdaysMin,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Inniu ag] LT",
          nextDay: "[AmÃ¡rach ag] LT",
          nextWeek: "dddd [ag] LT",
          lastDay: "[InnÃ© ag] LT",
          lastWeek: "dddd [seo caite] [ag] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "i %s",
          past: "%s Ã³ shin",
          s: "cÃºpla soicind",
          ss: "%d soicind",
          m: "nÃ³imÃ©ad",
          mm: "%d nÃ³imÃ©ad",
          h: "uair an chloig",
          hh: "%d uair an chloig",
          d: "lÃ¡",
          dd: "%d lÃ¡",
          M: "mÃ­",
          MM: "%d mÃ­onna",
          y: "bliain",
          yy: "%d bliain"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
        ordinal: function(number2) {
          var output = number2 === 1 ? "d" : number2 % 10 === 2 ? "na" : "mh";
          return number2 + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var months$7 = [
        "Am Faoilleach",
        "An Gearran",
        "Am MÃ rt",
        "An Giblean",
        "An CÃ¨itean",
        "An t-Ã’gmhios",
        "An t-Iuchar",
        "An LÃ¹nastal",
        "An t-Sultain",
        "An DÃ mhair",
        "An t-Samhain",
        "An DÃ¹bhlachd"
      ], monthsShort$6 = [
        "Faoi",
        "Gear",
        "MÃ rt",
        "Gibl",
        "CÃ¨it",
        "Ã’gmh",
        "Iuch",
        "LÃ¹n",
        "Sult",
        "DÃ mh",
        "Samh",
        "DÃ¹bh"
      ], weekdays$2 = [
        "DidÃ²mhnaich",
        "Diluain",
        "DimÃ irt",
        "Diciadain",
        "Diardaoin",
        "Dihaoine",
        "Disathairne"
      ], weekdaysShort$1 = ["Did", "Dil", "Dim", "Dic", "Dia", "Dih", "Dis"], weekdaysMin$1 = ["DÃ²", "Lu", "MÃ ", "Ci", "Ar", "Ha", "Sa"];
      hooks.defineLocale("gd", {
        months: months$7,
        monthsShort: monthsShort$6,
        monthsParseExact: true,
        weekdays: weekdays$2,
        weekdaysShort: weekdaysShort$1,
        weekdaysMin: weekdaysMin$1,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[An-diugh aig] LT",
          nextDay: "[A-mÃ ireach aig] LT",
          nextWeek: "dddd [aig] LT",
          lastDay: "[An-dÃ¨ aig] LT",
          lastWeek: "dddd [seo chaidh] [aig] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "ann an %s",
          past: "bho chionn %s",
          s: "beagan diogan",
          ss: "%d diogan",
          m: "mionaid",
          mm: "%d mionaidean",
          h: "uair",
          hh: "%d uairean",
          d: "latha",
          dd: "%d latha",
          M: "mÃ¬os",
          MM: "%d mÃ¬osan",
          y: "bliadhna",
          yy: "%d bliadhna"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
        ordinal: function(number2) {
          var output = number2 === 1 ? "d" : number2 % 10 === 2 ? "na" : "mh";
          return number2 + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("gl", {
        months: "xaneiro_febreiro_marzo_abril_maio_xuÃ±o_xullo_agosto_setembro_outubro_novembro_decembro".split(
          "_"
        ),
        monthsShort: "xan._feb._mar._abr._mai._xuÃ±._xul._ago._set._out._nov._dec.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "domingo_luns_martes_mÃ©rcores_xoves_venres_sÃ¡bado".split("_"),
        weekdaysShort: "dom._lun._mar._mÃ©r._xov._ven._sÃ¡b.".split("_"),
        weekdaysMin: "do_lu_ma_mÃ©_xo_ve_sÃ¡".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D [de] MMMM [de] YYYY",
          LLL: "D [de] MMMM [de] YYYY H:mm",
          LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
        },
        calendar: {
          sameDay: function() {
            return "[hoxe " + (this.hours() !== 1 ? "Ã¡s" : "Ã¡") + "] LT";
          },
          nextDay: function() {
            return "[maÃ±Ã¡ " + (this.hours() !== 1 ? "Ã¡s" : "Ã¡") + "] LT";
          },
          nextWeek: function() {
            return "dddd [" + (this.hours() !== 1 ? "Ã¡s" : "a") + "] LT";
          },
          lastDay: function() {
            return "[onte " + (this.hours() !== 1 ? "Ã¡" : "a") + "] LT";
          },
          lastWeek: function() {
            return "[o] dddd [pasado " + (this.hours() !== 1 ? "Ã¡s" : "a") + "] LT";
          },
          sameElse: "L"
        },
        relativeTime: {
          future: function(str) {
            if (str.indexOf("un") === 0) {
              return "n" + str;
            }
            return "en " + str;
          },
          past: "hai %s",
          s: "uns segundos",
          ss: "%d segundos",
          m: "un minuto",
          mm: "%d minutos",
          h: "unha hora",
          hh: "%d horas",
          d: "un dÃ­a",
          dd: "%d dÃ­as",
          M: "un mes",
          MM: "%d meses",
          y: "un ano",
          yy: "%d anos"
        },
        dayOfMonthOrdinalParse: /\d{1,2}Âº/,
        ordinal: "%dÂº",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      function processRelativeTime$5(number2, withoutSuffix, key, isFuture) {
        var format2 = {
          s: ["à¤¥à¥‹à¤¡à¤¯à¤¾ à¤¸à¥…à¤•à¤‚à¤¡à¤¾à¤‚à¤¨à¥€", "à¤¥à¥‹à¤¡à¥‡ à¤¸à¥…à¤•à¤‚à¤¡"],
          ss: [number2 + " à¤¸à¥…à¤•à¤‚à¤¡à¤¾à¤‚à¤¨à¥€", number2 + " à¤¸à¥…à¤•à¤‚à¤¡"],
          m: ["à¤à¤•à¤¾ à¤®à¤¿à¤£à¤Ÿà¤¾à¤¨", "à¤à¤• à¤®à¤¿à¤¨à¥‚à¤Ÿ"],
          mm: [number2 + " à¤®à¤¿à¤£à¤Ÿà¤¾à¤‚à¤¨à¥€", number2 + " à¤®à¤¿à¤£à¤Ÿà¤¾à¤‚"],
          h: ["à¤à¤•à¤¾ à¤µà¤°à¤¾à¤¨", "à¤à¤• à¤µà¤°"],
          hh: [number2 + " à¤µà¤°à¤¾à¤‚à¤¨à¥€", number2 + " à¤µà¤°à¤¾à¤‚"],
          d: ["à¤à¤•à¤¾ à¤¦à¤¿à¤¸à¤¾à¤¨", "à¤à¤• à¤¦à¥€à¤¸"],
          dd: [number2 + " à¤¦à¤¿à¤¸à¤¾à¤‚à¤¨à¥€", number2 + " à¤¦à¥€à¤¸"],
          M: ["à¤à¤•à¤¾ à¤®à¥à¤¹à¤¯à¤¨à¥à¤¯à¤¾à¤¨", "à¤à¤• à¤®à¥à¤¹à¤¯à¤¨à¥‹"],
          MM: [number2 + " à¤®à¥à¤¹à¤¯à¤¨à¥à¤¯à¤¾à¤¨à¥€", number2 + " à¤®à¥à¤¹à¤¯à¤¨à¥‡"],
          y: ["à¤à¤•à¤¾ à¤µà¤°à¥à¤¸à¤¾à¤¨", "à¤à¤• à¤µà¤°à¥à¤¸"],
          yy: [number2 + " à¤µà¤°à¥à¤¸à¤¾à¤‚à¤¨à¥€", number2 + " à¤µà¤°à¥à¤¸à¤¾à¤‚"]
        };
        return isFuture ? format2[key][0] : format2[key][1];
      }
      hooks.defineLocale("gom-deva", {
        months: {
          standalone: "à¤œà¤¾à¤¨à¥‡à¤µà¤¾à¤°à¥€_à¤«à¥‡à¤¬à¥à¤°à¥à¤µà¤¾à¤°à¥€_à¤®à¤¾à¤°à¥à¤š_à¤à¤ªà¥à¤°à¥€à¤²_à¤®à¥‡_à¤œà¥‚à¤¨_à¤œà¥à¤²à¤¯_à¤‘à¤—à¤¸à¥à¤Ÿ_à¤¸à¤ªà¥à¤Ÿà¥‡à¤‚à¤¬à¤°_à¤‘à¤•à¥à¤Ÿà¥‹à¤¬à¤°_à¤¨à¥‹à¤µà¥à¤¹à¥‡à¤‚à¤¬à¤°_à¤¡à¤¿à¤¸à¥‡à¤‚à¤¬à¤°".split(
            "_"
          ),
          format: "à¤œà¤¾à¤¨à¥‡à¤µà¤¾à¤°à¥€à¤šà¥à¤¯à¤¾_à¤«à¥‡à¤¬à¥à¤°à¥à¤µà¤¾à¤°à¥€à¤šà¥à¤¯à¤¾_à¤®à¤¾à¤°à¥à¤šà¤¾à¤šà¥à¤¯à¤¾_à¤à¤ªà¥à¤°à¥€à¤²à¤¾à¤šà¥à¤¯à¤¾_à¤®à¥‡à¤¯à¤¾à¤šà¥à¤¯à¤¾_à¤œà¥‚à¤¨à¤¾à¤šà¥à¤¯à¤¾_à¤œà¥à¤²à¤¯à¤¾à¤šà¥à¤¯à¤¾_à¤‘à¤—à¤¸à¥à¤Ÿà¤¾à¤šà¥à¤¯à¤¾_à¤¸à¤ªà¥à¤Ÿà¥‡à¤‚à¤¬à¤°à¤¾à¤šà¥à¤¯à¤¾_à¤‘à¤•à¥à¤Ÿà¥‹à¤¬à¤°à¤¾à¤šà¥à¤¯à¤¾_à¤¨à¥‹à¤µà¥à¤¹à¥‡à¤‚à¤¬à¤°à¤¾à¤šà¥à¤¯à¤¾_à¤¡à¤¿à¤¸à¥‡à¤‚à¤¬à¤°à¤¾à¤šà¥à¤¯à¤¾".split(
            "_"
          ),
          isFormat: /MMMM(\s)+D[oD]?/
        },
        monthsShort: "à¤œà¤¾à¤¨à¥‡._à¤«à¥‡à¤¬à¥à¤°à¥._à¤®à¤¾à¤°à¥à¤š_à¤à¤ªà¥à¤°à¥€._à¤®à¥‡_à¤œà¥‚à¤¨_à¤œà¥à¤²._à¤‘à¤—._à¤¸à¤ªà¥à¤Ÿà¥‡à¤‚._à¤‘à¤•à¥à¤Ÿà¥‹._à¤¨à¥‹à¤µà¥à¤¹à¥‡à¤‚._à¤¡à¤¿à¤¸à¥‡à¤‚.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "à¤†à¤¯à¤¤à¤¾à¤°_à¤¸à¥‹à¤®à¤¾à¤°_à¤®à¤‚à¤—à¤³à¤¾à¤°_à¤¬à¥à¤§à¤µà¤¾à¤°_à¤¬à¤¿à¤°à¥‡à¤¸à¥à¤¤à¤¾à¤°_à¤¸à¥à¤•à¥à¤°à¤¾à¤°_à¤¶à¥‡à¤¨à¤µà¤¾à¤°".split("_"),
        weekdaysShort: "à¤†à¤¯à¤¤._à¤¸à¥‹à¤®._à¤®à¤‚à¤—à¤³._à¤¬à¥à¤§._à¤¬à¥à¤°à¥‡à¤¸à¥à¤¤._à¤¸à¥à¤•à¥à¤°._à¤¶à¥‡à¤¨.".split("_"),
        weekdaysMin: "à¤†_à¤¸à¥‹_à¤®à¤‚_à¤¬à¥_à¤¬à¥à¤°à¥‡_à¤¸à¥_à¤¶à¥‡".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "A h:mm [à¤µà¤¾à¤œà¤¤à¤¾à¤‚]",
          LTS: "A h:mm:ss [à¤µà¤¾à¤œà¤¤à¤¾à¤‚]",
          L: "DD-MM-YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY A h:mm [à¤µà¤¾à¤œà¤¤à¤¾à¤‚]",
          LLLL: "dddd, MMMM Do, YYYY, A h:mm [à¤µà¤¾à¤œà¤¤à¤¾à¤‚]",
          llll: "ddd, D MMM YYYY, A h:mm [à¤µà¤¾à¤œà¤¤à¤¾à¤‚]"
        },
        calendar: {
          sameDay: "[à¤†à¤¯à¤œ] LT",
          nextDay: "[à¤«à¤¾à¤²à¥à¤¯à¤¾à¤‚] LT",
          nextWeek: "[à¤«à¥à¤¡à¤²à¥‹] dddd[,] LT",
          lastDay: "[à¤•à¤¾à¤²] LT",
          lastWeek: "[à¤«à¤¾à¤Ÿà¤²à¥‹] dddd[,] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s",
          past: "%s à¤†à¤¦à¥€à¤‚",
          s: processRelativeTime$5,
          ss: processRelativeTime$5,
          m: processRelativeTime$5,
          mm: processRelativeTime$5,
          h: processRelativeTime$5,
          hh: processRelativeTime$5,
          d: processRelativeTime$5,
          dd: processRelativeTime$5,
          M: processRelativeTime$5,
          MM: processRelativeTime$5,
          y: processRelativeTime$5,
          yy: processRelativeTime$5
        },
        dayOfMonthOrdinalParse: /\d{1,2}(à¤µà¥‡à¤°)/,
        ordinal: function(number2, period) {
          switch (period) {
            // the ordinal 'à¤µà¥‡à¤°' only applies to day of the month
            case "D":
              return number2 + "à¤µà¥‡à¤°";
            default:
            case "M":
            case "Q":
            case "DDD":
            case "d":
            case "w":
            case "W":
              return number2;
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week
          doy: 3
          // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)
        },
        meridiemParse: /à¤°à¤¾à¤¤à¥€|à¤¸à¤•à¤¾à¤³à¥€à¤‚|à¤¦à¤¨à¤ªà¤¾à¤°à¤¾à¤‚|à¤¸à¤¾à¤‚à¤œà¥‡/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "à¤°à¤¾à¤¤à¥€") {
            return hour < 4 ? hour : hour + 12;
          } else if (meridiem2 === "à¤¸à¤•à¤¾à¤³à¥€à¤‚") {
            return hour;
          } else if (meridiem2 === "à¤¦à¤¨à¤ªà¤¾à¤°à¤¾à¤‚") {
            return hour > 12 ? hour : hour + 12;
          } else if (meridiem2 === "à¤¸à¤¾à¤‚à¤œà¥‡") {
            return hour + 12;
          }
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "à¤°à¤¾à¤¤à¥€";
          } else if (hour < 12) {
            return "à¤¸à¤•à¤¾à¤³à¥€à¤‚";
          } else if (hour < 16) {
            return "à¤¦à¤¨à¤ªà¤¾à¤°à¤¾à¤‚";
          } else if (hour < 20) {
            return "à¤¸à¤¾à¤‚à¤œà¥‡";
          } else {
            return "à¤°à¤¾à¤¤à¥€";
          }
        }
      });
      //! moment.js locale configuration
      function processRelativeTime$6(number2, withoutSuffix, key, isFuture) {
        var format2 = {
          s: ["thoddea sekondamni", "thodde sekond"],
          ss: [number2 + " sekondamni", number2 + " sekond"],
          m: ["eka mintan", "ek minut"],
          mm: [number2 + " mintamni", number2 + " mintam"],
          h: ["eka voran", "ek vor"],
          hh: [number2 + " voramni", number2 + " voram"],
          d: ["eka disan", "ek dis"],
          dd: [number2 + " disamni", number2 + " dis"],
          M: ["eka mhoinean", "ek mhoino"],
          MM: [number2 + " mhoineamni", number2 + " mhoine"],
          y: ["eka vorsan", "ek voros"],
          yy: [number2 + " vorsamni", number2 + " vorsam"]
        };
        return isFuture ? format2[key][0] : format2[key][1];
      }
      hooks.defineLocale("gom-latn", {
        months: {
          standalone: "Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr".split(
            "_"
          ),
          format: "Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea".split(
            "_"
          ),
          isFormat: /MMMM(\s)+D[oD]?/
        },
        monthsShort: "Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.".split("_"),
        monthsParseExact: true,
        weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split("_"),
        weekdaysShort: "Ait._Som._Mon._Bud._Bre._Suk._Son.".split("_"),
        weekdaysMin: "Ai_Sm_Mo_Bu_Br_Su_Sn".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "A h:mm [vazta]",
          LTS: "A h:mm:ss [vazta]",
          L: "DD-MM-YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY A h:mm [vazta]",
          LLLL: "dddd, MMMM Do, YYYY, A h:mm [vazta]",
          llll: "ddd, D MMM YYYY, A h:mm [vazta]"
        },
        calendar: {
          sameDay: "[Aiz] LT",
          nextDay: "[Faleam] LT",
          nextWeek: "[Fuddlo] dddd[,] LT",
          lastDay: "[Kal] LT",
          lastWeek: "[Fattlo] dddd[,] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s",
          past: "%s adim",
          s: processRelativeTime$6,
          ss: processRelativeTime$6,
          m: processRelativeTime$6,
          mm: processRelativeTime$6,
          h: processRelativeTime$6,
          hh: processRelativeTime$6,
          d: processRelativeTime$6,
          dd: processRelativeTime$6,
          M: processRelativeTime$6,
          MM: processRelativeTime$6,
          y: processRelativeTime$6,
          yy: processRelativeTime$6
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er)/,
        ordinal: function(number2, period) {
          switch (period) {
            // the ordinal 'er' only applies to day of the month
            case "D":
              return number2 + "er";
            default:
            case "M":
            case "Q":
            case "DDD":
            case "d":
            case "w":
            case "W":
              return number2;
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week
          doy: 3
          // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)
        },
        meridiemParse: /rati|sokallim|donparam|sanje/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "rati") {
            return hour < 4 ? hour : hour + 12;
          } else if (meridiem2 === "sokallim") {
            return hour;
          } else if (meridiem2 === "donparam") {
            return hour > 12 ? hour : hour + 12;
          } else if (meridiem2 === "sanje") {
            return hour + 12;
          }
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "rati";
          } else if (hour < 12) {
            return "sokallim";
          } else if (hour < 16) {
            return "donparam";
          } else if (hour < 20) {
            return "sanje";
          } else {
            return "rati";
          }
        }
      });
      //! moment.js locale configuration
      var symbolMap$8 = {
        1: "à«§",
        2: "à«¨",
        3: "à«©",
        4: "à«ª",
        5: "à««",
        6: "à«¬",
        7: "à«­",
        8: "à«®",
        9: "à«¯",
        0: "à«¦"
      }, numberMap$7 = {
        "à«§": "1",
        "à«¨": "2",
        "à«©": "3",
        "à«ª": "4",
        "à««": "5",
        "à«¬": "6",
        "à«­": "7",
        "à«®": "8",
        "à«¯": "9",
        "à«¦": "0"
      };
      hooks.defineLocale("gu", {
        months: "àªœàª¾àª¨à«àª¯à«àª†àª°à«€_àª«à«‡àª¬à«àª°à«àª†àª°à«€_àª®àª¾àª°à«àªš_àªàªªà«àª°àª¿àª²_àª®à«‡_àªœà«‚àª¨_àªœà«àª²àª¾àªˆ_àª‘àª—àª¸à«àªŸ_àª¸àªªà«àªŸà«‡àª®à«àª¬àª°_àª‘àª•à«àªŸà«àª¬àª°_àª¨àªµà«‡àª®à«àª¬àª°_àª¡àª¿àª¸à«‡àª®à«àª¬àª°".split(
          "_"
        ),
        monthsShort: "àªœàª¾àª¨à«àª¯à«._àª«à«‡àª¬à«àª°à«._àª®àª¾àª°à«àªš_àªàªªà«àª°àª¿._àª®à«‡_àªœà«‚àª¨_àªœà«àª²àª¾._àª‘àª—._àª¸àªªà«àªŸà«‡._àª‘àª•à«àªŸà«._àª¨àªµà«‡._àª¡àª¿àª¸à«‡.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "àª°àªµàª¿àªµàª¾àª°_àª¸à«‹àª®àªµàª¾àª°_àª®àª‚àª—àª³àªµàª¾àª°_àª¬à«àª§à«àªµàª¾àª°_àª—à«àª°à«àªµàª¾àª°_àª¶à«àª•à«àª°àªµàª¾àª°_àª¶àª¨àª¿àªµàª¾àª°".split(
          "_"
        ),
        weekdaysShort: "àª°àªµàª¿_àª¸à«‹àª®_àª®àª‚àª—àª³_àª¬à«àª§à«_àª—à«àª°à«_àª¶à«àª•à«àª°_àª¶àª¨àª¿".split("_"),
        weekdaysMin: "àª°_àª¸à«‹_àª®àª‚_àª¬à«_àª—à«_àª¶à«_àª¶".split("_"),
        longDateFormat: {
          LT: "A h:mm àªµàª¾àª—à«àª¯à«‡",
          LTS: "A h:mm:ss àªµàª¾àª—à«àª¯à«‡",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY, A h:mm àªµàª¾àª—à«àª¯à«‡",
          LLLL: "dddd, D MMMM YYYY, A h:mm àªµàª¾àª—à«àª¯à«‡"
        },
        calendar: {
          sameDay: "[àª†àªœ] LT",
          nextDay: "[àª•àª¾àª²à«‡] LT",
          nextWeek: "dddd, LT",
          lastDay: "[àª—àª‡àª•àª¾àª²à«‡] LT",
          lastWeek: "[àªªàª¾àª›àª²àª¾] dddd, LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s àª®àª¾",
          past: "%s àªªàª¹à«‡àª²àª¾",
          s: "àª…àª®à«àª• àªªàª³à«‹",
          ss: "%d àª¸à«‡àª•àª‚àª¡",
          m: "àªàª• àª®àª¿àª¨àª¿àªŸ",
          mm: "%d àª®àª¿àª¨àª¿àªŸ",
          h: "àªàª• àª•àª²àª¾àª•",
          hh: "%d àª•àª²àª¾àª•",
          d: "àªàª• àª¦àª¿àªµàª¸",
          dd: "%d àª¦àª¿àªµàª¸",
          M: "àªàª• àª®àª¹àª¿àª¨à«‹",
          MM: "%d àª®àª¹àª¿àª¨à«‹",
          y: "àªàª• àªµàª°à«àª·",
          yy: "%d àªµàª°à«àª·"
        },
        preparse: function(string2) {
          return string2.replace(/[à«§à«¨à«©à«ªà««à«¬à«­à«®à«¯à«¦]/g, function(match) {
            return numberMap$7[match];
          });
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap$8[match];
          });
        },
        // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
        meridiemParse: /àª°àª¾àª¤|àª¬àªªà«‹àª°|àª¸àªµàª¾àª°|àª¸àª¾àª‚àªœ/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "àª°àª¾àª¤") {
            return hour < 4 ? hour : hour + 12;
          } else if (meridiem2 === "àª¸àªµàª¾àª°") {
            return hour;
          } else if (meridiem2 === "àª¬àªªà«‹àª°") {
            return hour >= 10 ? hour : hour + 12;
          } else if (meridiem2 === "àª¸àª¾àª‚àªœ") {
            return hour + 12;
          }
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "àª°àª¾àª¤";
          } else if (hour < 10) {
            return "àª¸àªµàª¾àª°";
          } else if (hour < 17) {
            return "àª¬àªªà«‹àª°";
          } else if (hour < 20) {
            return "àª¸àª¾àª‚àªœ";
          } else {
            return "àª°àª¾àª¤";
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("he", {
        months: "×™× ×•××¨_×¤×‘×¨×•××¨_×ž×¨×¥_××¤×¨×™×œ_×ž××™_×™×•× ×™_×™×•×œ×™_××•×’×•×¡×˜_×¡×¤×˜×ž×‘×¨_××•×§×˜×•×‘×¨_× ×•×‘×ž×‘×¨_×“×¦×ž×‘×¨".split(
          "_"
        ),
        monthsShort: "×™× ×•×³_×¤×‘×¨×³_×ž×¨×¥_××¤×¨×³_×ž××™_×™×•× ×™_×™×•×œ×™_××•×’×³_×¡×¤×˜×³_××•×§×³_× ×•×‘×³_×“×¦×ž×³".split("_"),
        weekdays: "×¨××©×•×Ÿ_×©× ×™_×©×œ×™×©×™_×¨×‘×™×¢×™_×—×ž×™×©×™_×©×™×©×™_×©×‘×ª".split("_"),
        weekdaysShort: "××³_×‘×³_×’×³_×“×³_×”×³_×•×³_×©×³".split("_"),
        weekdaysMin: "×_×‘_×’_×“_×”_×•_×©".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D [×‘]MMMM YYYY",
          LLL: "D [×‘]MMMM YYYY HH:mm",
          LLLL: "dddd, D [×‘]MMMM YYYY HH:mm",
          l: "D/M/YYYY",
          ll: "D MMM YYYY",
          lll: "D MMM YYYY HH:mm",
          llll: "ddd, D MMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[×”×™×•× ×‘Ö¾]LT",
          nextDay: "[×ž×—×¨ ×‘Ö¾]LT",
          nextWeek: "dddd [×‘×©×¢×”] LT",
          lastDay: "[××ª×ž×•×œ ×‘Ö¾]LT",
          lastWeek: "[×‘×™×•×] dddd [×”××—×¨×•×Ÿ ×‘×©×¢×”] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "×‘×¢×•×“ %s",
          past: "×œ×¤× ×™ %s",
          s: "×ž×¡×¤×¨ ×©× ×™×•×ª",
          ss: "%d ×©× ×™×•×ª",
          m: "×“×§×”",
          mm: "%d ×“×§×•×ª",
          h: "×©×¢×”",
          hh: function(number2) {
            if (number2 === 2) {
              return "×©×¢×ª×™×™×";
            }
            return number2 + " ×©×¢×•×ª";
          },
          d: "×™×•×",
          dd: function(number2) {
            if (number2 === 2) {
              return "×™×•×ž×™×™×";
            }
            return number2 + " ×™×ž×™×";
          },
          M: "×—×•×“×©",
          MM: function(number2) {
            if (number2 === 2) {
              return "×—×•×“×©×™×™×";
            }
            return number2 + " ×—×•×“×©×™×";
          },
          y: "×©× ×”",
          yy: function(number2) {
            if (number2 === 2) {
              return "×©× ×ª×™×™×";
            } else if (number2 % 10 === 0 && number2 !== 10) {
              return number2 + " ×©× ×”";
            }
            return number2 + " ×©× ×™×";
          }
        },
        meridiemParse: /××—×”"×¦|×œ×¤× ×”"×¦|××—×¨×™ ×”×¦×”×¨×™×™×|×œ×¤× ×™ ×”×¦×”×¨×™×™×|×œ×¤× ×•×ª ×‘×•×§×¨|×‘×‘×•×§×¨|×‘×¢×¨×‘/i,
        isPM: function(input) {
          return /^(××—×”"×¦|××—×¨×™ ×”×¦×”×¨×™×™×|×‘×¢×¨×‘)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 5) {
            return "×œ×¤× ×•×ª ×‘×•×§×¨";
          } else if (hour < 10) {
            return "×‘×‘×•×§×¨";
          } else if (hour < 12) {
            return isLower ? '×œ×¤× ×”"×¦' : "×œ×¤× ×™ ×”×¦×”×¨×™×™×";
          } else if (hour < 18) {
            return isLower ? '××—×”"×¦' : "××—×¨×™ ×”×¦×”×¨×™×™×";
          } else {
            return "×‘×¢×¨×‘";
          }
        }
      });
      //! moment.js locale configuration
      var symbolMap$9 = {
        1: "à¥§",
        2: "à¥¨",
        3: "à¥©",
        4: "à¥ª",
        5: "à¥«",
        6: "à¥¬",
        7: "à¥­",
        8: "à¥®",
        9: "à¥¯",
        0: "à¥¦"
      }, numberMap$8 = {
        "à¥§": "1",
        "à¥¨": "2",
        "à¥©": "3",
        "à¥ª": "4",
        "à¥«": "5",
        "à¥¬": "6",
        "à¥­": "7",
        "à¥®": "8",
        "à¥¯": "9",
        "à¥¦": "0"
      }, monthsParse$7 = [
        /^à¤œà¤¨/i,
        /^à¤«à¤¼à¤°|à¤«à¤°/i,
        /^à¤®à¤¾à¤°à¥à¤š/i,
        /^à¤…à¤ªà¥à¤°à¥ˆ/i,
        /^à¤®à¤ˆ/i,
        /^à¤œà¥‚à¤¨/i,
        /^à¤œà¥à¤²/i,
        /^à¤…à¤—/i,
        /^à¤¸à¤¿à¤¤à¤‚|à¤¸à¤¿à¤¤/i,
        /^à¤…à¤•à¥à¤Ÿà¥‚/i,
        /^à¤¨à¤µ|à¤¨à¤µà¤‚/i,
        /^à¤¦à¤¿à¤¸à¤‚|à¤¦à¤¿à¤¸/i
      ], shortMonthsParse = [
        /^à¤œà¤¨/i,
        /^à¤«à¤¼à¤°/i,
        /^à¤®à¤¾à¤°à¥à¤š/i,
        /^à¤…à¤ªà¥à¤°à¥ˆ/i,
        /^à¤®à¤ˆ/i,
        /^à¤œà¥‚à¤¨/i,
        /^à¤œà¥à¤²/i,
        /^à¤…à¤—/i,
        /^à¤¸à¤¿à¤¤/i,
        /^à¤…à¤•à¥à¤Ÿà¥‚/i,
        /^à¤¨à¤µ/i,
        /^à¤¦à¤¿à¤¸/i
      ];
      hooks.defineLocale("hi", {
        months: {
          format: "à¤œà¤¨à¤µà¤°à¥€_à¤«à¤¼à¤°à¤µà¤°à¥€_à¤®à¤¾à¤°à¥à¤š_à¤…à¤ªà¥à¤°à¥ˆà¤²_à¤®à¤ˆ_à¤œà¥‚à¤¨_à¤œà¥à¤²à¤¾à¤ˆ_à¤…à¤—à¤¸à¥à¤¤_à¤¸à¤¿à¤¤à¤®à¥à¤¬à¤°_à¤…à¤•à¥à¤Ÿà¥‚à¤¬à¤°_à¤¨à¤µà¤®à¥à¤¬à¤°_à¤¦à¤¿à¤¸à¤®à¥à¤¬à¤°".split(
            "_"
          ),
          standalone: "à¤œà¤¨à¤µà¤°à¥€_à¤«à¤°à¤µà¤°à¥€_à¤®à¤¾à¤°à¥à¤š_à¤…à¤ªà¥à¤°à¥ˆà¤²_à¤®à¤ˆ_à¤œà¥‚à¤¨_à¤œà¥à¤²à¤¾à¤ˆ_à¤…à¤—à¤¸à¥à¤¤_à¤¸à¤¿à¤¤à¤‚à¤¬à¤°_à¤…à¤•à¥à¤Ÿà¥‚à¤¬à¤°_à¤¨à¤µà¤‚à¤¬à¤°_à¤¦à¤¿à¤¸à¤‚à¤¬à¤°".split(
            "_"
          )
        },
        monthsShort: "à¤œà¤¨._à¤«à¤¼à¤°._à¤®à¤¾à¤°à¥à¤š_à¤…à¤ªà¥à¤°à¥ˆ._à¤®à¤ˆ_à¤œà¥‚à¤¨_à¤œà¥à¤²._à¤…à¤—._à¤¸à¤¿à¤¤._à¤…à¤•à¥à¤Ÿà¥‚._à¤¨à¤µ._à¤¦à¤¿à¤¸.".split("_"),
        weekdays: "à¤°à¤µà¤¿à¤µà¤¾à¤°_à¤¸à¥‹à¤®à¤µà¤¾à¤°_à¤®à¤‚à¤—à¤²à¤µà¤¾à¤°_à¤¬à¥à¤§à¤µà¤¾à¤°_à¤—à¥à¤°à¥‚à¤µà¤¾à¤°_à¤¶à¥à¤•à¥à¤°à¤µà¤¾à¤°_à¤¶à¤¨à¤¿à¤µà¤¾à¤°".split("_"),
        weekdaysShort: "à¤°à¤µà¤¿_à¤¸à¥‹à¤®_à¤®à¤‚à¤—à¤²_à¤¬à¥à¤§_à¤—à¥à¤°à¥‚_à¤¶à¥à¤•à¥à¤°_à¤¶à¤¨à¤¿".split("_"),
        weekdaysMin: "à¤°_à¤¸à¥‹_à¤®à¤‚_à¤¬à¥_à¤—à¥_à¤¶à¥_à¤¶".split("_"),
        longDateFormat: {
          LT: "A h:mm à¤¬à¤œà¥‡",
          LTS: "A h:mm:ss à¤¬à¤œà¥‡",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY, A h:mm à¤¬à¤œà¥‡",
          LLLL: "dddd, D MMMM YYYY, A h:mm à¤¬à¤œà¥‡"
        },
        monthsParse: monthsParse$7,
        longMonthsParse: monthsParse$7,
        shortMonthsParse,
        monthsRegex: /^(à¤œà¤¨à¤µà¤°à¥€|à¤œà¤¨\.?|à¤«à¤¼à¤°à¤µà¤°à¥€|à¤«à¤°à¤µà¤°à¥€|à¤«à¤¼à¤°\.?|à¤®à¤¾à¤°à¥à¤š?|à¤…à¤ªà¥à¤°à¥ˆà¤²|à¤…à¤ªà¥à¤°à¥ˆ\.?|à¤®à¤ˆ?|à¤œà¥‚à¤¨?|à¤œà¥à¤²à¤¾à¤ˆ|à¤œà¥à¤²\.?|à¤…à¤—à¤¸à¥à¤¤|à¤…à¤—\.?|à¤¸à¤¿à¤¤à¤®à¥à¤¬à¤°|à¤¸à¤¿à¤¤à¤‚à¤¬à¤°|à¤¸à¤¿à¤¤\.?|à¤…à¤•à¥à¤Ÿà¥‚à¤¬à¤°|à¤…à¤•à¥à¤Ÿà¥‚\.?|à¤¨à¤µà¤®à¥à¤¬à¤°|à¤¨à¤µà¤‚à¤¬à¤°|à¤¨à¤µ\.?|à¤¦à¤¿à¤¸à¤®à¥à¤¬à¤°|à¤¦à¤¿à¤¸à¤‚à¤¬à¤°|à¤¦à¤¿à¤¸\.?)/i,
        monthsShortRegex: /^(à¤œà¤¨à¤µà¤°à¥€|à¤œà¤¨\.?|à¤«à¤¼à¤°à¤µà¤°à¥€|à¤«à¤°à¤µà¤°à¥€|à¤«à¤¼à¤°\.?|à¤®à¤¾à¤°à¥à¤š?|à¤…à¤ªà¥à¤°à¥ˆà¤²|à¤…à¤ªà¥à¤°à¥ˆ\.?|à¤®à¤ˆ?|à¤œà¥‚à¤¨?|à¤œà¥à¤²à¤¾à¤ˆ|à¤œà¥à¤²\.?|à¤…à¤—à¤¸à¥à¤¤|à¤…à¤—\.?|à¤¸à¤¿à¤¤à¤®à¥à¤¬à¤°|à¤¸à¤¿à¤¤à¤‚à¤¬à¤°|à¤¸à¤¿à¤¤\.?|à¤…à¤•à¥à¤Ÿà¥‚à¤¬à¤°|à¤…à¤•à¥à¤Ÿà¥‚\.?|à¤¨à¤µà¤®à¥à¤¬à¤°|à¤¨à¤µà¤‚à¤¬à¤°|à¤¨à¤µ\.?|à¤¦à¤¿à¤¸à¤®à¥à¤¬à¤°|à¤¦à¤¿à¤¸à¤‚à¤¬à¤°|à¤¦à¤¿à¤¸\.?)/i,
        monthsStrictRegex: /^(à¤œà¤¨à¤µà¤°à¥€?|à¤«à¤¼à¤°à¤µà¤°à¥€|à¤«à¤°à¤µà¤°à¥€?|à¤®à¤¾à¤°à¥à¤š?|à¤…à¤ªà¥à¤°à¥ˆà¤²?|à¤®à¤ˆ?|à¤œà¥‚à¤¨?|à¤œà¥à¤²à¤¾à¤ˆ?|à¤…à¤—à¤¸à¥à¤¤?|à¤¸à¤¿à¤¤à¤®à¥à¤¬à¤°|à¤¸à¤¿à¤¤à¤‚à¤¬à¤°|à¤¸à¤¿à¤¤?\.?|à¤…à¤•à¥à¤Ÿà¥‚à¤¬à¤°|à¤…à¤•à¥à¤Ÿà¥‚\.?|à¤¨à¤µà¤®à¥à¤¬à¤°|à¤¨à¤µà¤‚à¤¬à¤°?|à¤¦à¤¿à¤¸à¤®à¥à¤¬à¤°|à¤¦à¤¿à¤¸à¤‚à¤¬à¤°?)/i,
        monthsShortStrictRegex: /^(à¤œà¤¨\.?|à¤«à¤¼à¤°\.?|à¤®à¤¾à¤°à¥à¤š?|à¤…à¤ªà¥à¤°à¥ˆ\.?|à¤®à¤ˆ?|à¤œà¥‚à¤¨?|à¤œà¥à¤²\.?|à¤…à¤—\.?|à¤¸à¤¿à¤¤\.?|à¤…à¤•à¥à¤Ÿà¥‚\.?|à¤¨à¤µ\.?|à¤¦à¤¿à¤¸\.?)/i,
        calendar: {
          sameDay: "[à¤†à¤œ] LT",
          nextDay: "[à¤•à¤²] LT",
          nextWeek: "dddd, LT",
          lastDay: "[à¤•à¤²] LT",
          lastWeek: "[à¤ªà¤¿à¤›à¤²à¥‡] dddd, LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s à¤®à¥‡à¤‚",
          past: "%s à¤ªà¤¹à¤²à¥‡",
          s: "à¤•à¥à¤› à¤¹à¥€ à¤•à¥à¤·à¤£",
          ss: "%d à¤¸à¥‡à¤•à¤‚à¤¡",
          m: "à¤à¤• à¤®à¤¿à¤¨à¤Ÿ",
          mm: "%d à¤®à¤¿à¤¨à¤Ÿ",
          h: "à¤à¤• à¤˜à¤‚à¤Ÿà¤¾",
          hh: "%d à¤˜à¤‚à¤Ÿà¥‡",
          d: "à¤à¤• à¤¦à¤¿à¤¨",
          dd: "%d à¤¦à¤¿à¤¨",
          M: "à¤à¤• à¤®à¤¹à¥€à¤¨à¥‡",
          MM: "%d à¤®à¤¹à¥€à¤¨à¥‡",
          y: "à¤à¤• à¤µà¤°à¥à¤·",
          yy: "%d à¤µà¤°à¥à¤·"
        },
        preparse: function(string2) {
          return string2.replace(/[à¥§à¥¨à¥©à¥ªà¥«à¥¬à¥­à¥®à¥¯à¥¦]/g, function(match) {
            return numberMap$8[match];
          });
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap$9[match];
          });
        },
        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
        meridiemParse: /à¤°à¤¾à¤¤|à¤¸à¥à¤¬à¤¹|à¤¦à¥‹à¤ªà¤¹à¤°|à¤¶à¤¾à¤®/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "à¤°à¤¾à¤¤") {
            return hour < 4 ? hour : hour + 12;
          } else if (meridiem2 === "à¤¸à¥à¤¬à¤¹") {
            return hour;
          } else if (meridiem2 === "à¤¦à¥‹à¤ªà¤¹à¤°") {
            return hour >= 10 ? hour : hour + 12;
          } else if (meridiem2 === "à¤¶à¤¾à¤®") {
            return hour + 12;
          }
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "à¤°à¤¾à¤¤";
          } else if (hour < 10) {
            return "à¤¸à¥à¤¬à¤¹";
          } else if (hour < 17) {
            return "à¤¦à¥‹à¤ªà¤¹à¤°";
          } else if (hour < 20) {
            return "à¤¶à¤¾à¤®";
          } else {
            return "à¤°à¤¾à¤¤";
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      function translate$3(number2, withoutSuffix, key) {
        var result = number2 + " ";
        switch (key) {
          case "ss":
            if (number2 === 1) {
              result += "sekunda";
            } else if (number2 === 2 || number2 === 3 || number2 === 4) {
              result += "sekunde";
            } else {
              result += "sekundi";
            }
            return result;
          case "m":
            return withoutSuffix ? "jedna minuta" : "jedne minute";
          case "mm":
            if (number2 === 1) {
              result += "minuta";
            } else if (number2 === 2 || number2 === 3 || number2 === 4) {
              result += "minute";
            } else {
              result += "minuta";
            }
            return result;
          case "h":
            return withoutSuffix ? "jedan sat" : "jednog sata";
          case "hh":
            if (number2 === 1) {
              result += "sat";
            } else if (number2 === 2 || number2 === 3 || number2 === 4) {
              result += "sata";
            } else {
              result += "sati";
            }
            return result;
          case "dd":
            if (number2 === 1) {
              result += "dan";
            } else {
              result += "dana";
            }
            return result;
          case "MM":
            if (number2 === 1) {
              result += "mjesec";
            } else if (number2 === 2 || number2 === 3 || number2 === 4) {
              result += "mjeseca";
            } else {
              result += "mjeseci";
            }
            return result;
          case "yy":
            if (number2 === 1) {
              result += "godina";
            } else if (number2 === 2 || number2 === 3 || number2 === 4) {
              result += "godine";
            } else {
              result += "godina";
            }
            return result;
        }
      }
      hooks.defineLocale("hr", {
        months: {
          format: "sijeÄnja_veljaÄe_oÅ¾ujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca".split(
            "_"
          ),
          standalone: "sijeÄanj_veljaÄa_oÅ¾ujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split(
            "_"
          )
        },
        monthsShort: "sij._velj._oÅ¾u._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "nedjelja_ponedjeljak_utorak_srijeda_Äetvrtak_petak_subota".split(
          "_"
        ),
        weekdaysShort: "ned._pon._uto._sri._Äet._pet._sub.".split("_"),
        weekdaysMin: "ne_po_ut_sr_Äe_pe_su".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD.MM.YYYY",
          LL: "Do MMMM YYYY",
          LLL: "Do MMMM YYYY H:mm",
          LLLL: "dddd, Do MMMM YYYY H:mm"
        },
        calendar: {
          sameDay: "[danas u] LT",
          nextDay: "[sutra u] LT",
          nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[u] [nedjelju] [u] LT";
              case 3:
                return "[u] [srijedu] [u] LT";
              case 6:
                return "[u] [subotu] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[u] dddd [u] LT";
            }
          },
          lastDay: "[juÄer u] LT",
          lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[proÅ¡lu] [nedjelju] [u] LT";
              case 3:
                return "[proÅ¡lu] [srijedu] [u] LT";
              case 6:
                return "[proÅ¡le] [subote] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[proÅ¡li] dddd [u] LT";
            }
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "za %s",
          past: "prije %s",
          s: "par sekundi",
          ss: translate$3,
          m: translate$3,
          mm: translate$3,
          h: translate$3,
          hh: translate$3,
          d: "dan",
          dd: translate$3,
          M: "mjesec",
          MM: translate$3,
          y: "godinu",
          yy: translate$3
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var weekEndings = "vasÃ¡rnap hÃ©tfÅ‘n kedden szerdÃ¡n csÃ¼tÃ¶rtÃ¶kÃ¶n pÃ©nteken szombaton".split(" ");
      function translate$4(number2, withoutSuffix, key, isFuture) {
        var num = number2;
        switch (key) {
          case "s":
            return isFuture || withoutSuffix ? "nÃ©hÃ¡ny mÃ¡sodperc" : "nÃ©hÃ¡ny mÃ¡sodperce";
          case "ss":
            return num + (isFuture || withoutSuffix) ? " mÃ¡sodperc" : " mÃ¡sodperce";
          case "m":
            return "egy" + (isFuture || withoutSuffix ? " perc" : " perce");
          case "mm":
            return num + (isFuture || withoutSuffix ? " perc" : " perce");
          case "h":
            return "egy" + (isFuture || withoutSuffix ? " Ã³ra" : " Ã³rÃ¡ja");
          case "hh":
            return num + (isFuture || withoutSuffix ? " Ã³ra" : " Ã³rÃ¡ja");
          case "d":
            return "egy" + (isFuture || withoutSuffix ? " nap" : " napja");
          case "dd":
            return num + (isFuture || withoutSuffix ? " nap" : " napja");
          case "M":
            return "egy" + (isFuture || withoutSuffix ? " hÃ³nap" : " hÃ³napja");
          case "MM":
            return num + (isFuture || withoutSuffix ? " hÃ³nap" : " hÃ³napja");
          case "y":
            return "egy" + (isFuture || withoutSuffix ? " Ã©v" : " Ã©ve");
          case "yy":
            return num + (isFuture || withoutSuffix ? " Ã©v" : " Ã©ve");
        }
        return "";
      }
      function week(isFuture) {
        return (isFuture ? "" : "[mÃºlt] ") + "[" + weekEndings[this.day()] + "] LT[-kor]";
      }
      hooks.defineLocale("hu", {
        months: "januÃ¡r_februÃ¡r_mÃ¡rcius_Ã¡prilis_mÃ¡jus_jÃºnius_jÃºlius_augusztus_szeptember_oktÃ³ber_november_december".split(
          "_"
        ),
        monthsShort: "jan._feb._mÃ¡rc._Ã¡pr._mÃ¡j._jÃºn._jÃºl._aug._szept._okt._nov._dec.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "vasÃ¡rnap_hÃ©tfÅ‘_kedd_szerda_csÃ¼tÃ¶rtÃ¶k_pÃ©ntek_szombat".split("_"),
        weekdaysShort: "vas_hÃ©t_kedd_sze_csÃ¼t_pÃ©n_szo".split("_"),
        weekdaysMin: "v_h_k_sze_cs_p_szo".split("_"),
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "YYYY.MM.DD.",
          LL: "YYYY. MMMM D.",
          LLL: "YYYY. MMMM D. H:mm",
          LLLL: "YYYY. MMMM D., dddd H:mm"
        },
        meridiemParse: /de|du/i,
        isPM: function(input) {
          return input.charAt(1).toLowerCase() === "u";
        },
        meridiem: function(hours2, minutes2, isLower) {
          if (hours2 < 12) {
            return isLower === true ? "de" : "DE";
          } else {
            return isLower === true ? "du" : "DU";
          }
        },
        calendar: {
          sameDay: "[ma] LT[-kor]",
          nextDay: "[holnap] LT[-kor]",
          nextWeek: function() {
            return week.call(this, true);
          },
          lastDay: "[tegnap] LT[-kor]",
          lastWeek: function() {
            return week.call(this, false);
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "%s mÃºlva",
          past: "%s",
          s: translate$4,
          ss: translate$4,
          m: translate$4,
          mm: translate$4,
          h: translate$4,
          hh: translate$4,
          d: translate$4,
          dd: translate$4,
          M: translate$4,
          MM: translate$4,
          y: translate$4,
          yy: translate$4
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("hy-am", {
        months: {
          format: "Õ°Õ¸Ö‚Õ¶Õ¾Õ¡Ö€Õ«_ÖƒÕ¥Õ¿Ö€Õ¾Õ¡Ö€Õ«_Õ´Õ¡Ö€Õ¿Õ«_Õ¡ÕºÖ€Õ«Õ¬Õ«_Õ´Õ¡ÕµÕ«Õ½Õ«_Õ°Õ¸Ö‚Õ¶Õ«Õ½Õ«_Õ°Õ¸Ö‚Õ¬Õ«Õ½Õ«_Ö…Õ£Õ¸Õ½Õ¿Õ¸Õ½Õ«_Õ½Õ¥ÕºÕ¿Õ¥Õ´Õ¢Õ¥Ö€Õ«_Õ°Õ¸Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö€Õ«_Õ¶Õ¸ÕµÕ¥Õ´Õ¢Õ¥Ö€Õ«_Õ¤Õ¥Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö€Õ«".split(
            "_"
          ),
          standalone: "Õ°Õ¸Ö‚Õ¶Õ¾Õ¡Ö€_ÖƒÕ¥Õ¿Ö€Õ¾Õ¡Ö€_Õ´Õ¡Ö€Õ¿_Õ¡ÕºÖ€Õ«Õ¬_Õ´Õ¡ÕµÕ«Õ½_Õ°Õ¸Ö‚Õ¶Õ«Õ½_Õ°Õ¸Ö‚Õ¬Õ«Õ½_Ö…Õ£Õ¸Õ½Õ¿Õ¸Õ½_Õ½Õ¥ÕºÕ¿Õ¥Õ´Õ¢Õ¥Ö€_Õ°Õ¸Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö€_Õ¶Õ¸ÕµÕ¥Õ´Õ¢Õ¥Ö€_Õ¤Õ¥Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö€".split(
            "_"
          )
        },
        monthsShort: "Õ°Õ¶Õ¾_ÖƒÕ¿Ö€_Õ´Ö€Õ¿_Õ¡ÕºÖ€_Õ´ÕµÕ½_Õ°Õ¶Õ½_Õ°Õ¬Õ½_Ö…Õ£Õ½_Õ½ÕºÕ¿_Õ°Õ¯Õ¿_Õ¶Õ´Õ¢_Õ¤Õ¯Õ¿".split("_"),
        weekdays: "Õ¯Õ«Ö€Õ¡Õ¯Õ«_Õ¥Ö€Õ¯Õ¸Ö‚Õ·Õ¡Õ¢Õ©Õ«_Õ¥Ö€Õ¥Ö„Õ·Õ¡Õ¢Õ©Õ«_Õ¹Õ¸Ö€Õ¥Ö„Õ·Õ¡Õ¢Õ©Õ«_Õ°Õ«Õ¶Õ£Õ·Õ¡Õ¢Õ©Õ«_Õ¸Ö‚Ö€Õ¢Õ¡Õ©_Õ·Õ¡Õ¢Õ¡Õ©".split(
          "_"
        ),
        weekdaysShort: "Õ¯Ö€Õ¯_Õ¥Ö€Õ¯_Õ¥Ö€Ö„_Õ¹Ö€Ö„_Õ°Õ¶Õ£_Õ¸Ö‚Ö€Õ¢_Õ·Õ¢Õ©".split("_"),
        weekdaysMin: "Õ¯Ö€Õ¯_Õ¥Ö€Õ¯_Õ¥Ö€Ö„_Õ¹Ö€Ö„_Õ°Õ¶Õ£_Õ¸Ö‚Ö€Õ¢_Õ·Õ¢Õ©".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY Õ©.",
          LLL: "D MMMM YYYY Õ©., HH:mm",
          LLLL: "dddd, D MMMM YYYY Õ©., HH:mm"
        },
        calendar: {
          sameDay: "[Õ¡ÕµÕ½Ö…Ö€] LT",
          nextDay: "[Õ¾Õ¡Õ²Õ¨] LT",
          lastDay: "[Õ¥Ö€Õ¥Õ¯] LT",
          nextWeek: function() {
            return "dddd [Ö…Ö€Õ¨ ÕªÕ¡Õ´Õ¨] LT";
          },
          lastWeek: function() {
            return "[Õ¡Õ¶ÖÕ¡Õ®] dddd [Ö…Ö€Õ¨ ÕªÕ¡Õ´Õ¨] LT";
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "%s Õ°Õ¥Õ¿Õ¸",
          past: "%s Õ¡Õ¼Õ¡Õ»",
          s: "Õ´Õ« Ö„Õ¡Õ¶Õ« Õ¾Õ¡ÕµÖ€Õ¯ÕµÕ¡Õ¶",
          ss: "%d Õ¾Õ¡ÕµÖ€Õ¯ÕµÕ¡Õ¶",
          m: "Ö€Õ¸ÕºÕ¥",
          mm: "%d Ö€Õ¸ÕºÕ¥",
          h: "ÕªÕ¡Õ´",
          hh: "%d ÕªÕ¡Õ´",
          d: "Ö…Ö€",
          dd: "%d Ö…Ö€",
          M: "Õ¡Õ´Õ«Õ½",
          MM: "%d Õ¡Õ´Õ«Õ½",
          y: "Õ¿Õ¡Ö€Õ«",
          yy: "%d Õ¿Õ¡Ö€Õ«"
        },
        meridiemParse: /Õ£Õ«Õ·Õ¥Ö€Õ¾Õ¡|Õ¡Õ¼Õ¡Õ¾Õ¸Õ¿Õ¾Õ¡|ÖÕ¥Ö€Õ¥Õ¯Õ¾Õ¡|Õ¥Ö€Õ¥Õ¯Õ¸ÕµÕ¡Õ¶/,
        isPM: function(input) {
          return /^(ÖÕ¥Ö€Õ¥Õ¯Õ¾Õ¡|Õ¥Ö€Õ¥Õ¯Õ¸ÕµÕ¡Õ¶)$/.test(input);
        },
        meridiem: function(hour) {
          if (hour < 4) {
            return "Õ£Õ«Õ·Õ¥Ö€Õ¾Õ¡";
          } else if (hour < 12) {
            return "Õ¡Õ¼Õ¡Õ¾Õ¸Õ¿Õ¾Õ¡";
          } else if (hour < 17) {
            return "ÖÕ¥Ö€Õ¥Õ¯Õ¾Õ¡";
          } else {
            return "Õ¥Ö€Õ¥Õ¯Õ¸ÕµÕ¡Õ¶";
          }
        },
        dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(Õ«Õ¶|Ö€Õ¤)/,
        ordinal: function(number2, period) {
          switch (period) {
            case "DDD":
            case "w":
            case "W":
            case "DDDo":
              if (number2 === 1) {
                return number2 + "-Õ«Õ¶";
              }
              return number2 + "-Ö€Õ¤";
            default:
              return number2;
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("id", {
        months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split(
          "_"
        ),
        monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des".split("_"),
        weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"),
        weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"),
        weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"),
        longDateFormat: {
          LT: "HH.mm",
          LTS: "HH.mm.ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY [pukul] HH.mm",
          LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "pagi") {
            return hour;
          } else if (meridiem2 === "siang") {
            return hour >= 11 ? hour : hour + 12;
          } else if (meridiem2 === "sore" || meridiem2 === "malam") {
            return hour + 12;
          }
        },
        meridiem: function(hours2, minutes2, isLower) {
          if (hours2 < 11) {
            return "pagi";
          } else if (hours2 < 15) {
            return "siang";
          } else if (hours2 < 19) {
            return "sore";
          } else {
            return "malam";
          }
        },
        calendar: {
          sameDay: "[Hari ini pukul] LT",
          nextDay: "[Besok pukul] LT",
          nextWeek: "dddd [pukul] LT",
          lastDay: "[Kemarin pukul] LT",
          lastWeek: "dddd [lalu pukul] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "dalam %s",
          past: "%s yang lalu",
          s: "beberapa detik",
          ss: "%d detik",
          m: "semenit",
          mm: "%d menit",
          h: "sejam",
          hh: "%d jam",
          d: "sehari",
          dd: "%d hari",
          M: "sebulan",
          MM: "%d bulan",
          y: "setahun",
          yy: "%d tahun"
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      function plural$2(n) {
        if (n % 100 === 11) {
          return true;
        } else if (n % 10 === 1) {
          return false;
        }
        return true;
      }
      function translate$5(number2, withoutSuffix, key, isFuture) {
        var result = number2 + " ";
        switch (key) {
          case "s":
            return withoutSuffix || isFuture ? "nokkrar sekÃºndur" : "nokkrum sekÃºndum";
          case "ss":
            if (plural$2(number2)) {
              return result + (withoutSuffix || isFuture ? "sekÃºndur" : "sekÃºndum");
            }
            return result + "sekÃºnda";
          case "m":
            return withoutSuffix ? "mÃ­nÃºta" : "mÃ­nÃºtu";
          case "mm":
            if (plural$2(number2)) {
              return result + (withoutSuffix || isFuture ? "mÃ­nÃºtur" : "mÃ­nÃºtum");
            } else if (withoutSuffix) {
              return result + "mÃ­nÃºta";
            }
            return result + "mÃ­nÃºtu";
          case "hh":
            if (plural$2(number2)) {
              return result + (withoutSuffix || isFuture ? "klukkustundir" : "klukkustundum");
            }
            return result + "klukkustund";
          case "d":
            if (withoutSuffix) {
              return "dagur";
            }
            return isFuture ? "dag" : "degi";
          case "dd":
            if (plural$2(number2)) {
              if (withoutSuffix) {
                return result + "dagar";
              }
              return result + (isFuture ? "daga" : "dÃ¶gum");
            } else if (withoutSuffix) {
              return result + "dagur";
            }
            return result + (isFuture ? "dag" : "degi");
          case "M":
            if (withoutSuffix) {
              return "mÃ¡nuÃ°ur";
            }
            return isFuture ? "mÃ¡nuÃ°" : "mÃ¡nuÃ°i";
          case "MM":
            if (plural$2(number2)) {
              if (withoutSuffix) {
                return result + "mÃ¡nuÃ°ir";
              }
              return result + (isFuture ? "mÃ¡nuÃ°i" : "mÃ¡nuÃ°um");
            } else if (withoutSuffix) {
              return result + "mÃ¡nuÃ°ur";
            }
            return result + (isFuture ? "mÃ¡nuÃ°" : "mÃ¡nuÃ°i");
          case "y":
            return withoutSuffix || isFuture ? "Ã¡r" : "Ã¡ri";
          case "yy":
            if (plural$2(number2)) {
              return result + (withoutSuffix || isFuture ? "Ã¡r" : "Ã¡rum");
            }
            return result + (withoutSuffix || isFuture ? "Ã¡r" : "Ã¡ri");
        }
      }
      hooks.defineLocale("is", {
        months: "janÃºar_febrÃºar_mars_aprÃ­l_maÃ­_jÃºnÃ­_jÃºlÃ­_Ã¡gÃºst_september_oktÃ³ber_nÃ³vember_desember".split(
          "_"
        ),
        monthsShort: "jan_feb_mar_apr_maÃ­_jÃºn_jÃºl_Ã¡gÃº_sep_okt_nÃ³v_des".split("_"),
        weekdays: "sunnudagur_mÃ¡nudagur_Ã¾riÃ°judagur_miÃ°vikudagur_fimmtudagur_fÃ¶studagur_laugardagur".split(
          "_"
        ),
        weekdaysShort: "sun_mÃ¡n_Ã¾ri_miÃ°_fim_fÃ¶s_lau".split("_"),
        weekdaysMin: "Su_MÃ¡_Ãžr_Mi_Fi_FÃ¶_La".split("_"),
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D. MMMM YYYY",
          LLL: "D. MMMM YYYY [kl.] H:mm",
          LLLL: "dddd, D. MMMM YYYY [kl.] H:mm"
        },
        calendar: {
          sameDay: "[Ã­ dag kl.] LT",
          nextDay: "[Ã¡ morgun kl.] LT",
          nextWeek: "dddd [kl.] LT",
          lastDay: "[Ã­ gÃ¦r kl.] LT",
          lastWeek: "[sÃ­Ã°asta] dddd [kl.] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "eftir %s",
          past: "fyrir %s sÃ­Ã°an",
          s: translate$5,
          ss: translate$5,
          m: translate$5,
          mm: translate$5,
          h: "klukkustund",
          hh: translate$5,
          d: translate$5,
          dd: translate$5,
          M: translate$5,
          MM: translate$5,
          y: translate$5,
          yy: translate$5
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("it-ch", {
        months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split(
          "_"
        ),
        monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
        weekdays: "domenica_lunedÃ¬_martedÃ¬_mercoledÃ¬_giovedÃ¬_venerdÃ¬_sabato".split(
          "_"
        ),
        weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
        weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Oggi alle] LT",
          nextDay: "[Domani alle] LT",
          nextWeek: "dddd [alle] LT",
          lastDay: "[Ieri alle] LT",
          lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[la scorsa] dddd [alle] LT";
              default:
                return "[lo scorso] dddd [alle] LT";
            }
          },
          sameElse: "L"
        },
        relativeTime: {
          future: function(s) {
            return (/^[0-9].+$/.test(s) ? "tra" : "in") + " " + s;
          },
          past: "%s fa",
          s: "alcuni secondi",
          ss: "%d secondi",
          m: "un minuto",
          mm: "%d minuti",
          h: "un'ora",
          hh: "%d ore",
          d: "un giorno",
          dd: "%d giorni",
          M: "un mese",
          MM: "%d mesi",
          y: "un anno",
          yy: "%d anni"
        },
        dayOfMonthOrdinalParse: /\d{1,2}Âº/,
        ordinal: "%dÂº",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("it", {
        months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split(
          "_"
        ),
        monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
        weekdays: "domenica_lunedÃ¬_martedÃ¬_mercoledÃ¬_giovedÃ¬_venerdÃ¬_sabato".split(
          "_"
        ),
        weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
        weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: function() {
            return "[Oggi a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          },
          nextDay: function() {
            return "[Domani a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          },
          nextWeek: function() {
            return "dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          },
          lastDay: function() {
            return "[Ieri a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          },
          lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[La scorsa] dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
              default:
                return "[Lo scorso] dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
            }
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "tra %s",
          past: "%s fa",
          s: "alcuni secondi",
          ss: "%d secondi",
          m: "un minuto",
          mm: "%d minuti",
          h: "un'ora",
          hh: "%d ore",
          d: "un giorno",
          dd: "%d giorni",
          w: "una settimana",
          ww: "%d settimane",
          M: "un mese",
          MM: "%d mesi",
          y: "un anno",
          yy: "%d anni"
        },
        dayOfMonthOrdinalParse: /\d{1,2}Âº/,
        ordinal: "%dÂº",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("ja", {
        eras: [
          {
            since: "2019-05-01",
            offset: 1,
            name: "ä»¤å’Œ",
            narrow: "ã‹¿",
            abbr: "R"
          },
          {
            since: "1989-01-08",
            until: "2019-04-30",
            offset: 1,
            name: "å¹³æˆ",
            narrow: "ã»",
            abbr: "H"
          },
          {
            since: "1926-12-25",
            until: "1989-01-07",
            offset: 1,
            name: "æ˜­å’Œ",
            narrow: "ã¼",
            abbr: "S"
          },
          {
            since: "1912-07-30",
            until: "1926-12-24",
            offset: 1,
            name: "å¤§æ­£",
            narrow: "ã½",
            abbr: "T"
          },
          {
            since: "1873-01-01",
            until: "1912-07-29",
            offset: 6,
            name: "æ˜Žæ²»",
            narrow: "ã¾",
            abbr: "M"
          },
          {
            since: "0001-01-01",
            until: "1873-12-31",
            offset: 1,
            name: "è¥¿æš¦",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "ç´€å…ƒå‰",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        eraYearOrdinalRegex: /(å…ƒ|\d+)å¹´/,
        eraYearOrdinalParse: function(input, match) {
          return match[1] === "å…ƒ" ? 1 : parseInt(match[1] || input, 10);
        },
        months: "1æœˆ_2æœˆ_3æœˆ_4æœˆ_5æœˆ_6æœˆ_7æœˆ_8æœˆ_9æœˆ_10æœˆ_11æœˆ_12æœˆ".split("_"),
        monthsShort: "1æœˆ_2æœˆ_3æœˆ_4æœˆ_5æœˆ_6æœˆ_7æœˆ_8æœˆ_9æœˆ_10æœˆ_11æœˆ_12æœˆ".split(
          "_"
        ),
        weekdays: "æ—¥æ›œæ—¥_æœˆæ›œæ—¥_ç«æ›œæ—¥_æ°´æ›œæ—¥_æœ¨æ›œæ—¥_é‡‘æ›œæ—¥_åœŸæ›œæ—¥".split("_"),
        weekdaysShort: "æ—¥_æœˆ_ç«_æ°´_æœ¨_é‡‘_åœŸ".split("_"),
        weekdaysMin: "æ—¥_æœˆ_ç«_æ°´_æœ¨_é‡‘_åœŸ".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "YYYY/MM/DD",
          LL: "YYYYå¹´MæœˆDæ—¥",
          LLL: "YYYYå¹´MæœˆDæ—¥ HH:mm",
          LLLL: "YYYYå¹´MæœˆDæ—¥ dddd HH:mm",
          l: "YYYY/MM/DD",
          ll: "YYYYå¹´MæœˆDæ—¥",
          lll: "YYYYå¹´MæœˆDæ—¥ HH:mm",
          llll: "YYYYå¹´MæœˆDæ—¥(ddd) HH:mm"
        },
        meridiemParse: /åˆå‰|åˆå¾Œ/i,
        isPM: function(input) {
          return input === "åˆå¾Œ";
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 12) {
            return "åˆå‰";
          } else {
            return "åˆå¾Œ";
          }
        },
        calendar: {
          sameDay: "[ä»Šæ—¥] LT",
          nextDay: "[æ˜Žæ—¥] LT",
          nextWeek: function(now2) {
            if (now2.week() !== this.week()) {
              return "[æ¥é€±]dddd LT";
            } else {
              return "dddd LT";
            }
          },
          lastDay: "[æ˜¨æ—¥] LT",
          lastWeek: function(now2) {
            if (this.week() !== now2.week()) {
              return "[å…ˆé€±]dddd LT";
            } else {
              return "dddd LT";
            }
          },
          sameElse: "L"
        },
        dayOfMonthOrdinalParse: /\d{1,2}æ—¥/,
        ordinal: function(number2, period) {
          switch (period) {
            case "y":
              return number2 === 1 ? "å…ƒå¹´" : number2 + "å¹´";
            case "d":
            case "D":
            case "DDD":
              return number2 + "æ—¥";
            default:
              return number2;
          }
        },
        relativeTime: {
          future: "%så¾Œ",
          past: "%så‰",
          s: "æ•°ç§’",
          ss: "%dç§’",
          m: "1åˆ†",
          mm: "%dåˆ†",
          h: "1æ™‚é–“",
          hh: "%dæ™‚é–“",
          d: "1æ—¥",
          dd: "%dæ—¥",
          M: "1ãƒ¶æœˆ",
          MM: "%dãƒ¶æœˆ",
          y: "1å¹´",
          yy: "%då¹´"
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("jv", {
        months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember".split(
          "_"
        ),
        monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des".split("_"),
        weekdays: "Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu".split("_"),
        weekdaysShort: "Min_Sen_Sel_Reb_Kem_Jem_Sep".split("_"),
        weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sp".split("_"),
        longDateFormat: {
          LT: "HH.mm",
          LTS: "HH.mm.ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY [pukul] HH.mm",
          LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
        },
        meridiemParse: /enjing|siyang|sonten|ndalu/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "enjing") {
            return hour;
          } else if (meridiem2 === "siyang") {
            return hour >= 11 ? hour : hour + 12;
          } else if (meridiem2 === "sonten" || meridiem2 === "ndalu") {
            return hour + 12;
          }
        },
        meridiem: function(hours2, minutes2, isLower) {
          if (hours2 < 11) {
            return "enjing";
          } else if (hours2 < 15) {
            return "siyang";
          } else if (hours2 < 19) {
            return "sonten";
          } else {
            return "ndalu";
          }
        },
        calendar: {
          sameDay: "[Dinten puniko pukul] LT",
          nextDay: "[Mbenjang pukul] LT",
          nextWeek: "dddd [pukul] LT",
          lastDay: "[Kala wingi pukul] LT",
          lastWeek: "dddd [kepengker pukul] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "wonten ing %s",
          past: "%s ingkang kepengker",
          s: "sawetawis detik",
          ss: "%d detik",
          m: "setunggal menit",
          mm: "%d menit",
          h: "setunggal jam",
          hh: "%d jam",
          d: "sedinten",
          dd: "%d dinten",
          M: "sewulan",
          MM: "%d wulan",
          y: "setaun",
          yy: "%d taun"
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("ka", {
        months: "áƒ˜áƒáƒœáƒ•áƒáƒ áƒ˜_áƒ—áƒ”áƒ‘áƒ”áƒ áƒ•áƒáƒšáƒ˜_áƒ›áƒáƒ áƒ¢áƒ˜_áƒáƒžáƒ áƒ˜áƒšáƒ˜_áƒ›áƒáƒ˜áƒ¡áƒ˜_áƒ˜áƒ•áƒœáƒ˜áƒ¡áƒ˜_áƒ˜áƒ•áƒšáƒ˜áƒ¡áƒ˜_áƒáƒ’áƒ•áƒ˜áƒ¡áƒ¢áƒ_áƒ¡áƒ”áƒ¥áƒ¢áƒ”áƒ›áƒ‘áƒ”áƒ áƒ˜_áƒáƒ¥áƒ¢áƒáƒ›áƒ‘áƒ”áƒ áƒ˜_áƒœáƒáƒ”áƒ›áƒ‘áƒ”áƒ áƒ˜_áƒ“áƒ”áƒ™áƒ”áƒ›áƒ‘áƒ”áƒ áƒ˜".split(
          "_"
        ),
        monthsShort: "áƒ˜áƒáƒœ_áƒ—áƒ”áƒ‘_áƒ›áƒáƒ _áƒáƒžáƒ _áƒ›áƒáƒ˜_áƒ˜áƒ•áƒœ_áƒ˜áƒ•áƒš_áƒáƒ’áƒ•_áƒ¡áƒ”áƒ¥_áƒáƒ¥áƒ¢_áƒœáƒáƒ”_áƒ“áƒ”áƒ™".split("_"),
        weekdays: {
          standalone: "áƒ™áƒ•áƒ˜áƒ áƒ_áƒáƒ áƒ¨áƒáƒ‘áƒáƒ—áƒ˜_áƒ¡áƒáƒ›áƒ¨áƒáƒ‘áƒáƒ—áƒ˜_áƒáƒ—áƒ®áƒ¨áƒáƒ‘áƒáƒ—áƒ˜_áƒ®áƒ£áƒ—áƒ¨áƒáƒ‘áƒáƒ—áƒ˜_áƒžáƒáƒ áƒáƒ¡áƒ™áƒ”áƒ•áƒ˜_áƒ¨áƒáƒ‘áƒáƒ—áƒ˜".split(
            "_"
          ),
          format: "áƒ™áƒ•áƒ˜áƒ áƒáƒ¡_áƒáƒ áƒ¨áƒáƒ‘áƒáƒ—áƒ¡_áƒ¡áƒáƒ›áƒ¨áƒáƒ‘áƒáƒ—áƒ¡_áƒáƒ—áƒ®áƒ¨áƒáƒ‘áƒáƒ—áƒ¡_áƒ®áƒ£áƒ—áƒ¨áƒáƒ‘áƒáƒ—áƒ¡_áƒžáƒáƒ áƒáƒ¡áƒ™áƒ”áƒ•áƒ¡_áƒ¨áƒáƒ‘áƒáƒ—áƒ¡".split(
            "_"
          ),
          isFormat: /(áƒ¬áƒ˜áƒœáƒ|áƒ¨áƒ”áƒ›áƒ“áƒ”áƒ’)/
        },
        weekdaysShort: "áƒ™áƒ•áƒ˜_áƒáƒ áƒ¨_áƒ¡áƒáƒ›_áƒáƒ—áƒ®_áƒ®áƒ£áƒ—_áƒžáƒáƒ _áƒ¨áƒáƒ‘".split("_"),
        weekdaysMin: "áƒ™áƒ•_áƒáƒ _áƒ¡áƒ_áƒáƒ—_áƒ®áƒ£_áƒžáƒ_áƒ¨áƒ".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[áƒ“áƒ¦áƒ”áƒ¡] LT[-áƒ–áƒ”]",
          nextDay: "[áƒ®áƒ•áƒáƒš] LT[-áƒ–áƒ”]",
          lastDay: "[áƒ’áƒ£áƒ¨áƒ˜áƒœ] LT[-áƒ–áƒ”]",
          nextWeek: "[áƒ¨áƒ”áƒ›áƒ“áƒ”áƒ’] dddd LT[-áƒ–áƒ”]",
          lastWeek: "[áƒ¬áƒ˜áƒœáƒ] dddd LT-áƒ–áƒ”",
          sameElse: "L"
        },
        relativeTime: {
          future: function(s) {
            return s.replace(
              /(áƒ¬áƒáƒ›|áƒ¬áƒ£áƒ—|áƒ¡áƒáƒáƒ—|áƒ¬áƒ”áƒš|áƒ“áƒ¦|áƒ—áƒ•)(áƒ˜|áƒ”)/,
              function($0, $1, $2) {
                return $2 === "áƒ˜" ? $1 + "áƒ¨áƒ˜" : $1 + $2 + "áƒ¨áƒ˜";
              }
            );
          },
          past: function(s) {
            if (/(áƒ¬áƒáƒ›áƒ˜|áƒ¬áƒ£áƒ—áƒ˜|áƒ¡áƒáƒáƒ—áƒ˜|áƒ“áƒ¦áƒ”|áƒ—áƒ•áƒ”)/.test(s)) {
              return s.replace(/(áƒ˜|áƒ”)$/, "áƒ˜áƒ¡ áƒ¬áƒ˜áƒœ");
            }
            if (/áƒ¬áƒ”áƒšáƒ˜/.test(s)) {
              return s.replace(/áƒ¬áƒ”áƒšáƒ˜$/, "áƒ¬áƒšáƒ˜áƒ¡ áƒ¬áƒ˜áƒœ");
            }
            return s;
          },
          s: "áƒ áƒáƒ›áƒ“áƒ”áƒœáƒ˜áƒ›áƒ” áƒ¬áƒáƒ›áƒ˜",
          ss: "%d áƒ¬áƒáƒ›áƒ˜",
          m: "áƒ¬áƒ£áƒ—áƒ˜",
          mm: "%d áƒ¬áƒ£áƒ—áƒ˜",
          h: "áƒ¡áƒáƒáƒ—áƒ˜",
          hh: "%d áƒ¡áƒáƒáƒ—áƒ˜",
          d: "áƒ“áƒ¦áƒ”",
          dd: "%d áƒ“áƒ¦áƒ”",
          M: "áƒ—áƒ•áƒ”",
          MM: "%d áƒ—áƒ•áƒ”",
          y: "áƒ¬áƒ”áƒšáƒ˜",
          yy: "%d áƒ¬áƒ”áƒšáƒ˜"
        },
        dayOfMonthOrdinalParse: /0|1-áƒšáƒ˜|áƒ›áƒ”-\d{1,2}|\d{1,2}-áƒ”/,
        ordinal: function(number2) {
          if (number2 === 0) {
            return number2;
          }
          if (number2 === 1) {
            return number2 + "-áƒšáƒ˜";
          }
          if (number2 < 20 || number2 <= 100 && number2 % 20 === 0 || number2 % 100 === 0) {
            return "áƒ›áƒ”-" + number2;
          }
          return number2 + "-áƒ”";
        },
        week: {
          dow: 1,
          doy: 7
        }
      });
      //! moment.js locale configuration
      var suffixes$1 = {
        0: "-ÑˆÑ–",
        1: "-ÑˆÑ–",
        2: "-ÑˆÑ–",
        3: "-ÑˆÑ–",
        4: "-ÑˆÑ–",
        5: "-ÑˆÑ–",
        6: "-ÑˆÑ‹",
        7: "-ÑˆÑ–",
        8: "-ÑˆÑ–",
        9: "-ÑˆÑ‹",
        10: "-ÑˆÑ‹",
        20: "-ÑˆÑ‹",
        30: "-ÑˆÑ‹",
        40: "-ÑˆÑ‹",
        50: "-ÑˆÑ–",
        60: "-ÑˆÑ‹",
        70: "-ÑˆÑ–",
        80: "-ÑˆÑ–",
        90: "-ÑˆÑ‹",
        100: "-ÑˆÑ–"
      };
      hooks.defineLocale("kk", {
        months: "Ò›Ð°Ò£Ñ‚Ð°Ñ€_Ð°Ò›Ð¿Ð°Ð½_Ð½Ð°ÑƒÑ€Ñ‹Ð·_ÑÓ™ÑƒÑ–Ñ€_Ð¼Ð°Ð¼Ñ‹Ñ€_Ð¼Ð°ÑƒÑÑ‹Ð¼_ÑˆÑ–Ð»Ð´Ðµ_Ñ‚Ð°Ð¼Ñ‹Ð·_Ò›Ñ‹Ñ€ÐºÒ¯Ð¹ÐµÐº_Ò›Ð°Ð·Ð°Ð½_Ò›Ð°Ñ€Ð°ÑˆÐ°_Ð¶ÐµÐ»Ñ‚Ð¾Ò›ÑÐ°Ð½".split(
          "_"
        ),
        monthsShort: "Ò›Ð°Ò£_Ð°Ò›Ð¿_Ð½Ð°Ñƒ_ÑÓ™Ñƒ_Ð¼Ð°Ð¼_Ð¼Ð°Ñƒ_ÑˆÑ–Ð»_Ñ‚Ð°Ð¼_Ò›Ñ‹Ñ€_Ò›Ð°Ð·_Ò›Ð°Ñ€_Ð¶ÐµÐ»".split("_"),
        weekdays: "Ð¶ÐµÐºÑÐµÐ½Ð±Ñ–_Ð´Ò¯Ð¹ÑÐµÐ½Ð±Ñ–_ÑÐµÐ¹ÑÐµÐ½Ð±Ñ–_ÑÓ™Ñ€ÑÐµÐ½Ð±Ñ–_Ð±ÐµÐ¹ÑÐµÐ½Ð±Ñ–_Ð¶Ò±Ð¼Ð°_ÑÐµÐ½Ð±Ñ–".split(
          "_"
        ),
        weekdaysShort: "Ð¶ÐµÐº_Ð´Ò¯Ð¹_ÑÐµÐ¹_ÑÓ™Ñ€_Ð±ÐµÐ¹_Ð¶Ò±Ð¼_ÑÐµÐ½".split("_"),
        weekdaysMin: "Ð¶Ðº_Ð´Ð¹_ÑÐ¹_ÑÑ€_Ð±Ð¹_Ð¶Ð¼_ÑÐ½".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Ð‘Ò¯Ð³Ñ–Ð½ ÑÐ°Ò“Ð°Ñ‚] LT",
          nextDay: "[Ð•Ñ€Ñ‚ÐµÒ£ ÑÐ°Ò“Ð°Ñ‚] LT",
          nextWeek: "dddd [ÑÐ°Ò“Ð°Ñ‚] LT",
          lastDay: "[ÐšÐµÑˆÐµ ÑÐ°Ò“Ð°Ñ‚] LT",
          lastWeek: "[Ó¨Ñ‚ÐºÐµÐ½ Ð°Ð¿Ñ‚Ð°Ð½Ñ‹Ò£] dddd [ÑÐ°Ò“Ð°Ñ‚] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s Ñ–ÑˆÑ–Ð½Ð´Ðµ",
          past: "%s Ð±Ò±Ñ€Ñ‹Ð½",
          s: "Ð±Ñ–Ñ€Ð½ÐµÑˆÐµ ÑÐµÐºÑƒÐ½Ð´",
          ss: "%d ÑÐµÐºÑƒÐ½Ð´",
          m: "Ð±Ñ–Ñ€ Ð¼Ð¸Ð½ÑƒÑ‚",
          mm: "%d Ð¼Ð¸Ð½ÑƒÑ‚",
          h: "Ð±Ñ–Ñ€ ÑÐ°Ò“Ð°Ñ‚",
          hh: "%d ÑÐ°Ò“Ð°Ñ‚",
          d: "Ð±Ñ–Ñ€ ÐºÒ¯Ð½",
          dd: "%d ÐºÒ¯Ð½",
          M: "Ð±Ñ–Ñ€ Ð°Ð¹",
          MM: "%d Ð°Ð¹",
          y: "Ð±Ñ–Ñ€ Ð¶Ñ‹Ð»",
          yy: "%d Ð¶Ñ‹Ð»"
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ÑˆÑ–|ÑˆÑ‹)/,
        ordinal: function(number2) {
          var a = number2 % 10, b = number2 >= 100 ? 100 : null;
          return number2 + (suffixes$1[number2] || suffixes$1[a] || suffixes$1[b]);
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var symbolMap$a = {
        1: "áŸ¡",
        2: "áŸ¢",
        3: "áŸ£",
        4: "áŸ¤",
        5: "áŸ¥",
        6: "áŸ¦",
        7: "áŸ§",
        8: "áŸ¨",
        9: "áŸ©",
        0: "áŸ "
      }, numberMap$9 = {
        "áŸ¡": "1",
        "áŸ¢": "2",
        "áŸ£": "3",
        "áŸ¤": "4",
        "áŸ¥": "5",
        "áŸ¦": "6",
        "áŸ§": "7",
        "áŸ¨": "8",
        "áŸ©": "9",
        "áŸ ": "0"
      };
      hooks.defineLocale("km", {
        months: "áž˜áž€ážšáž¶_áž€áž»áž˜áŸ’áž—áŸˆ_áž˜áž¸áž“áž¶_áž˜áŸážŸáž¶_áž§ážŸáž—áž¶_áž˜áž·ážáž»áž“áž¶_áž€áž€áŸ’áž€ážŠáž¶_ážŸáž¸áž áž¶_áž€áž‰áŸ’áž‰áž¶_ážáž»áž›áž¶_ážœáž·áž…áŸ’áž†áž·áž€áž¶_áž’áŸ’áž“áž¼".split(
          "_"
        ),
        monthsShort: "áž˜áž€ážšáž¶_áž€áž»áž˜áŸ’áž—áŸˆ_áž˜áž¸áž“áž¶_áž˜áŸážŸáž¶_áž§ážŸáž—áž¶_áž˜áž·ážáž»áž“áž¶_áž€áž€áŸ’áž€ážŠáž¶_ážŸáž¸áž áž¶_áž€áž‰áŸ’áž‰áž¶_ážáž»áž›áž¶_ážœáž·áž…áŸ’áž†áž·áž€áž¶_áž’áŸ’áž“áž¼".split(
          "_"
        ),
        weekdays: "áž¢áž¶áž‘áž·ážáŸ’áž™_áž…áŸáž“áŸ’áž‘_áž¢áž„áŸ’áž‚áž¶ážš_áž–áž»áž’_áž–áŸ’ážšáž ážŸáŸ’áž”ážáž·áŸ_ážŸáž»áž€áŸ’ážš_ážŸáŸ…ážšáŸ".split("_"),
        weekdaysShort: "áž¢áž¶_áž…_áž¢_áž–_áž–áŸ’ážš_ážŸáž»_ážŸ".split("_"),
        weekdaysMin: "áž¢áž¶_áž…_áž¢_áž–_áž–áŸ’ážš_ážŸáž»_ážŸ".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        meridiemParse: /áž–áŸ’ážšáž¹áž€|áž›áŸ’áž„áž¶áž…/,
        isPM: function(input) {
          return input === "áž›áŸ’áž„áž¶áž…";
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 12) {
            return "áž–áŸ’ážšáž¹áž€";
          } else {
            return "áž›áŸ’áž„áž¶áž…";
          }
        },
        calendar: {
          sameDay: "[ážáŸ’áž„áŸƒáž“áŸáŸ‡ áž˜áŸ‰áŸ„áž„] LT",
          nextDay: "[ážŸáŸ’áž¢áŸ‚áž€ áž˜áŸ‰áŸ„áž„] LT",
          nextWeek: "dddd [áž˜áŸ‰áŸ„áž„] LT",
          lastDay: "[áž˜áŸ’ážŸáž·áž›áž˜áž·áž‰ áž˜áŸ‰áŸ„áž„] LT",
          lastWeek: "dddd [ážŸáž”áŸ’ážáž¶áž áŸáž˜áž»áž“] [áž˜áŸ‰áŸ„áž„] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%sáž‘áŸ€áž",
          past: "%sáž˜áž»áž“",
          s: "áž”áŸ‰áž»áž“áŸ’áž˜áž¶áž“ážœáž·áž“áž¶áž‘áž¸",
          ss: "%d ážœáž·áž“áž¶áž‘áž¸",
          m: "áž˜áž½áž™áž“áž¶áž‘áž¸",
          mm: "%d áž“áž¶áž‘áž¸",
          h: "áž˜áž½áž™áž˜áŸ‰áŸ„áž„",
          hh: "%d áž˜áŸ‰áŸ„áž„",
          d: "áž˜áž½áž™ážáŸ’áž„áŸƒ",
          dd: "%d ážáŸ’áž„áŸƒ",
          M: "áž˜áž½áž™ážáŸ‚",
          MM: "%d ážáŸ‚",
          y: "áž˜áž½áž™áž†áŸ’áž“áž¶áŸ†",
          yy: "%d áž†áŸ’áž“áž¶áŸ†"
        },
        dayOfMonthOrdinalParse: /áž‘áž¸\d{1,2}/,
        ordinal: "áž‘áž¸%d",
        preparse: function(string2) {
          return string2.replace(/[áŸ¡áŸ¢áŸ£áŸ¤áŸ¥áŸ¦áŸ§áŸ¨áŸ©áŸ ]/g, function(match) {
            return numberMap$9[match];
          });
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap$a[match];
          });
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var symbolMap$b = {
        1: "à³§",
        2: "à³¨",
        3: "à³©",
        4: "à³ª",
        5: "à³«",
        6: "à³¬",
        7: "à³­",
        8: "à³®",
        9: "à³¯",
        0: "à³¦"
      }, numberMap$a = {
        "à³§": "1",
        "à³¨": "2",
        "à³©": "3",
        "à³ª": "4",
        "à³«": "5",
        "à³¬": "6",
        "à³­": "7",
        "à³®": "8",
        "à³¯": "9",
        "à³¦": "0"
      };
      hooks.defineLocale("kn", {
        months: "à²œà²¨à²µà²°à²¿_à²«à³†à²¬à³à²°à²µà²°à²¿_à²®à²¾à²°à³à²šà³_à²à²ªà³à²°à²¿à²²à³_à²®à³†à³•_à²œà³‚à²¨à³_à²œà³à²²à³†à³–_à²†à²—à²¸à³à²Ÿà³_à²¸à³†à²ªà³à²Ÿà³†à²‚à²¬à²°à³_à²…à²•à³à²Ÿà³†à³‚à³•à²¬à²°à³_à²¨à²µà³†à²‚à²¬à²°à³_à²¡à²¿à²¸à³†à²‚à²¬à²°à³".split(
          "_"
        ),
        monthsShort: "à²œà²¨_à²«à³†à²¬à³à²°_à²®à²¾à²°à³à²šà³_à²à²ªà³à²°à²¿à²²à³_à²®à³†à³•_à²œà³‚à²¨à³_à²œà³à²²à³†à³–_à²†à²—à²¸à³à²Ÿà³_à²¸à³†à²ªà³à²Ÿà³†à²‚_à²…à²•à³à²Ÿà³†à³‚à³•_à²¨à²µà³†à²‚_à²¡à²¿à²¸à³†à²‚".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "à²­à²¾à²¨à³à²µà²¾à²°_à²¸à³†à³‚à³•à²®à²µà²¾à²°_à²®à²‚à²—à²³à²µà²¾à²°_à²¬à³à²§à²µà²¾à²°_à²—à³à²°à³à²µà²¾à²°_à²¶à³à²•à³à²°à²µà²¾à²°_à²¶à²¨à²¿à²µà²¾à²°".split(
          "_"
        ),
        weekdaysShort: "à²­à²¾à²¨à³_à²¸à³†à³‚à³•à²®_à²®à²‚à²—à²³_à²¬à³à²§_à²—à³à²°à³_à²¶à³à²•à³à²°_à²¶à²¨à²¿".split("_"),
        weekdaysMin: "à²­à²¾_à²¸à³†à³‚à³•_à²®à²‚_à²¬à³_à²—à³_à²¶à³_à²¶".split("_"),
        longDateFormat: {
          LT: "A h:mm",
          LTS: "A h:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY, A h:mm",
          LLLL: "dddd, D MMMM YYYY, A h:mm"
        },
        calendar: {
          sameDay: "[à²‡à²‚à²¦à³] LT",
          nextDay: "[à²¨à²¾à²³à³†] LT",
          nextWeek: "dddd, LT",
          lastDay: "[à²¨à²¿à²¨à³à²¨à³†] LT",
          lastWeek: "[à²•à³†à³‚à²¨à³†à²¯] dddd, LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s à²¨à²‚à²¤à²°",
          past: "%s à²¹à²¿à²‚à²¦à³†",
          s: "à²•à³†à²²à²µà³ à²•à³à²·à²£à²—à²³à³",
          ss: "%d à²¸à³†à²•à³†à²‚à²¡à³à²—à²³à³",
          m: "à²’à²‚à²¦à³ à²¨à²¿à²®à²¿à²·",
          mm: "%d à²¨à²¿à²®à²¿à²·",
          h: "à²’à²‚à²¦à³ à²—à²‚à²Ÿà³†",
          hh: "%d à²—à²‚à²Ÿà³†",
          d: "à²’à²‚à²¦à³ à²¦à²¿à²¨",
          dd: "%d à²¦à²¿à²¨",
          M: "à²’à²‚à²¦à³ à²¤à²¿à²‚à²—à²³à³",
          MM: "%d à²¤à²¿à²‚à²—à²³à³",
          y: "à²’à²‚à²¦à³ à²µà²°à³à²·",
          yy: "%d à²µà²°à³à²·"
        },
        preparse: function(string2) {
          return string2.replace(/[à³§à³¨à³©à³ªà³«à³¬à³­à³®à³¯à³¦]/g, function(match) {
            return numberMap$a[match];
          });
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap$b[match];
          });
        },
        meridiemParse: /à²°à²¾à²¤à³à²°à²¿|à²¬à³†à²³à²¿à²—à³à²—à³†|à²®à²§à³à²¯à²¾à²¹à³à²¨|à²¸à²‚à²œà³†/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "à²°à²¾à²¤à³à²°à²¿") {
            return hour < 4 ? hour : hour + 12;
          } else if (meridiem2 === "à²¬à³†à²³à²¿à²—à³à²—à³†") {
            return hour;
          } else if (meridiem2 === "à²®à²§à³à²¯à²¾à²¹à³à²¨") {
            return hour >= 10 ? hour : hour + 12;
          } else if (meridiem2 === "à²¸à²‚à²œà³†") {
            return hour + 12;
          }
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "à²°à²¾à²¤à³à²°à²¿";
          } else if (hour < 10) {
            return "à²¬à³†à²³à²¿à²—à³à²—à³†";
          } else if (hour < 17) {
            return "à²®à²§à³à²¯à²¾à²¹à³à²¨";
          } else if (hour < 20) {
            return "à²¸à²‚à²œà³†";
          } else {
            return "à²°à²¾à²¤à³à²°à²¿";
          }
        },
        dayOfMonthOrdinalParse: /\d{1,2}(à²¨à³†à³•)/,
        ordinal: function(number2) {
          return number2 + "à²¨à³†à³•";
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("ko", {
        months: "1ì›”_2ì›”_3ì›”_4ì›”_5ì›”_6ì›”_7ì›”_8ì›”_9ì›”_10ì›”_11ì›”_12ì›”".split("_"),
        monthsShort: "1ì›”_2ì›”_3ì›”_4ì›”_5ì›”_6ì›”_7ì›”_8ì›”_9ì›”_10ì›”_11ì›”_12ì›”".split(
          "_"
        ),
        weekdays: "ì¼ìš”ì¼_ì›”ìš”ì¼_í™”ìš”ì¼_ìˆ˜ìš”ì¼_ëª©ìš”ì¼_ê¸ˆìš”ì¼_í† ìš”ì¼".split("_"),
        weekdaysShort: "ì¼_ì›”_í™”_ìˆ˜_ëª©_ê¸ˆ_í† ".split("_"),
        weekdaysMin: "ì¼_ì›”_í™”_ìˆ˜_ëª©_ê¸ˆ_í† ".split("_"),
        longDateFormat: {
          LT: "A h:mm",
          LTS: "A h:mm:ss",
          L: "YYYY.MM.DD.",
          LL: "YYYYë…„ MMMM Dì¼",
          LLL: "YYYYë…„ MMMM Dì¼ A h:mm",
          LLLL: "YYYYë…„ MMMM Dì¼ dddd A h:mm",
          l: "YYYY.MM.DD.",
          ll: "YYYYë…„ MMMM Dì¼",
          lll: "YYYYë…„ MMMM Dì¼ A h:mm",
          llll: "YYYYë…„ MMMM Dì¼ dddd A h:mm"
        },
        calendar: {
          sameDay: "ì˜¤ëŠ˜ LT",
          nextDay: "ë‚´ì¼ LT",
          nextWeek: "dddd LT",
          lastDay: "ì–´ì œ LT",
          lastWeek: "ì§€ë‚œì£¼ dddd LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s í›„",
          past: "%s ì „",
          s: "ëª‡ ì´ˆ",
          ss: "%dì´ˆ",
          m: "1ë¶„",
          mm: "%dë¶„",
          h: "í•œ ì‹œê°„",
          hh: "%dì‹œê°„",
          d: "í•˜ë£¨",
          dd: "%dì¼",
          M: "í•œ ë‹¬",
          MM: "%dë‹¬",
          y: "ì¼ ë…„",
          yy: "%dë…„"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ì¼|ì›”|ì£¼)/,
        ordinal: function(number2, period) {
          switch (period) {
            case "d":
            case "D":
            case "DDD":
              return number2 + "ì¼";
            case "M":
              return number2 + "ì›”";
            case "w":
            case "W":
              return number2 + "ì£¼";
            default:
              return number2;
          }
        },
        meridiemParse: /ì˜¤ì „|ì˜¤í›„/,
        isPM: function(token2) {
          return token2 === "ì˜¤í›„";
        },
        meridiem: function(hour, minute, isUpper) {
          return hour < 12 ? "ì˜¤ì „" : "ì˜¤í›„";
        }
      });
      //! moment.js locale configuration
      function processRelativeTime$7(num, withoutSuffix, key, isFuture) {
        var format2 = {
          s: ["Ã§end sanÃ®ye", "Ã§end sanÃ®yeyan"],
          ss: [num + " sanÃ®ye", num + " sanÃ®yeyan"],
          m: ["deqÃ®qeyek", "deqÃ®qeyekÃª"],
          mm: [num + " deqÃ®qe", num + " deqÃ®qeyan"],
          h: ["saetek", "saetekÃª"],
          hh: [num + " saet", num + " saetan"],
          d: ["rojek", "rojekÃª"],
          dd: [num + " roj", num + " rojan"],
          w: ["hefteyek", "hefteyekÃª"],
          ww: [num + " hefte", num + " hefteyan"],
          M: ["mehek", "mehekÃª"],
          MM: [num + " meh", num + " mehan"],
          y: ["salek", "salekÃª"],
          yy: [num + " sal", num + " salan"]
        };
        return withoutSuffix ? format2[key][0] : format2[key][1];
      }
      function ezafeNumSuffix(num) {
        num = "" + num;
        var l = num.substring(num.length - 1), ll = num.length > 1 ? num.substring(num.length - 2) : "";
        if (!(ll == 12 || ll == 13) && (l == "2" || l == "3" || ll == "50" || l == "70" || l == "80"))
          return "yÃª";
        return "Ãª";
      }
      hooks.defineLocale("ku-kmr", {
        // According to the spelling rules defined by the work group of Weqfa MezopotamyayÃª (Mesopotamia Foundation)
        // this should be: 'KanÃ»na PaÅŸÃ®n_Sibat_Adar_NÃ®san_Gulan_HezÃ®ran_TÃ®rmeh_Tebax_ÃŽlon_Ã‡irÃ®ya PÃªÅŸÃ®n_Ã‡irÃ®ya PaÅŸÃ®n_KanÃ»na PÃªÅŸÃ®n'
        // But the names below are more well known and handy
        months: "RÃªbendan_Sibat_Adar_NÃ®san_Gulan_HezÃ®ran_TÃ®rmeh_Tebax_ÃŽlon_Cotmeh_Mijdar_Berfanbar".split(
          "_"
        ),
        monthsShort: "RÃªb_Sib_Ada_NÃ®s_Gul_Hez_TÃ®r_Teb_ÃŽlo_Cot_Mij_Ber".split("_"),
        monthsParseExact: true,
        weekdays: "YekÅŸem_DuÅŸem_SÃªÅŸem_Ã‡arÅŸem_PÃªncÅŸem_ÃŽn_ÅžemÃ®".split("_"),
        weekdaysShort: "Yek_Du_SÃª_Ã‡ar_PÃªn_ÃŽn_Åžem".split("_"),
        weekdaysMin: "Ye_Du_SÃª_Ã‡a_PÃª_ÃŽn_Åže".split("_"),
        meridiem: function(hours2, minutes2, isLower) {
          if (hours2 < 12) {
            return isLower ? "bn" : "BN";
          } else {
            return isLower ? "pn" : "PN";
          }
        },
        meridiemParse: /bn|BN|pn|PN/,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "Do MMMM[a] YYYY[an]",
          LLL: "Do MMMM[a] YYYY[an] HH:mm",
          LLLL: "dddd, Do MMMM[a] YYYY[an] HH:mm",
          ll: "Do MMM[.] YYYY[an]",
          lll: "Do MMM[.] YYYY[an] HH:mm",
          llll: "ddd[.], Do MMM[.] YYYY[an] HH:mm"
        },
        calendar: {
          sameDay: "[ÃŽro di saet] LT [de]",
          nextDay: "[SibÃª di saet] LT [de]",
          nextWeek: "dddd [di saet] LT [de]",
          lastDay: "[Duh di saet] LT [de]",
          lastWeek: "dddd[a borÃ® di saet] LT [de]",
          sameElse: "L"
        },
        relativeTime: {
          future: "di %s de",
          past: "berÃ® %s",
          s: processRelativeTime$7,
          ss: processRelativeTime$7,
          m: processRelativeTime$7,
          mm: processRelativeTime$7,
          h: processRelativeTime$7,
          hh: processRelativeTime$7,
          d: processRelativeTime$7,
          dd: processRelativeTime$7,
          w: processRelativeTime$7,
          ww: processRelativeTime$7,
          M: processRelativeTime$7,
          MM: processRelativeTime$7,
          y: processRelativeTime$7,
          yy: processRelativeTime$7
        },
        dayOfMonthOrdinalParse: /\d{1,2}(?:yÃª|Ãª|\.)/,
        ordinal: function(num, period) {
          var p = period.toLowerCase();
          if (p.includes("w") || p.includes("m")) return num + ".";
          return num + ezafeNumSuffix(num);
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var symbolMap$c = {
        1: "Ù¡",
        2: "Ù¢",
        3: "Ù£",
        4: "Ù¤",
        5: "Ù¥",
        6: "Ù¦",
        7: "Ù§",
        8: "Ù¨",
        9: "Ù©",
        0: "Ù "
      }, numberMap$b = {
        "Ù¡": "1",
        "Ù¢": "2",
        "Ù£": "3",
        "Ù¤": "4",
        "Ù¥": "5",
        "Ù¦": "6",
        "Ù§": "7",
        "Ù¨": "8",
        "Ù©": "9",
        "Ù ": "0"
      }, months$8 = [
        "Ú©Ø§Ù†ÙˆÙ†ÛŒ Ø¯ÙˆÙˆÛ•Ù…",
        "Ø´ÙˆØ¨Ø§Øª",
        "Ø¦Ø§Ø²Ø§Ø±",
        "Ù†ÛŒØ³Ø§Ù†",
        "Ø¦Ø§ÛŒØ§Ø±",
        "Ø­ÙˆØ²Û•ÛŒØ±Ø§Ù†",
        "ØªÛ•Ù…Ù…ÙˆØ²",
        "Ø¦Ø§Ø¨",
        "Ø¦Û•ÛŒÙ„ÙˆÙˆÙ„",
        "ØªØ´Ø±ÛŒÙ†ÛŒ ÛŒÛ•ÙƒÛ•Ù…",
        "ØªØ´Ø±ÛŒÙ†ÛŒ Ø¯ÙˆÙˆÛ•Ù…",
        "ÙƒØ§Ù†ÙˆÙ†ÛŒ ÛŒÛ•Ú©Û•Ù…"
      ];
      hooks.defineLocale("ku", {
        months: months$8,
        monthsShort: months$8,
        weekdays: "ÛŒÙ‡â€ŒÙƒØ´Ù‡â€ŒÙ…Ù…Ù‡â€Œ_Ø¯ÙˆÙˆØ´Ù‡â€ŒÙ…Ù…Ù‡â€Œ_Ø³ÛŽØ´Ù‡â€ŒÙ…Ù…Ù‡â€Œ_Ú†ÙˆØ§Ø±Ø´Ù‡â€ŒÙ…Ù…Ù‡â€Œ_Ù¾ÛŽÙ†Ø¬Ø´Ù‡â€ŒÙ…Ù…Ù‡â€Œ_Ù‡Ù‡â€ŒÛŒÙ†ÛŒ_Ø´Ù‡â€ŒÙ…Ù…Ù‡â€Œ".split(
          "_"
        ),
        weekdaysShort: "ÛŒÙ‡â€ŒÙƒØ´Ù‡â€ŒÙ…_Ø¯ÙˆÙˆØ´Ù‡â€ŒÙ…_Ø³ÛŽØ´Ù‡â€ŒÙ…_Ú†ÙˆØ§Ø±Ø´Ù‡â€ŒÙ…_Ù¾ÛŽÙ†Ø¬Ø´Ù‡â€ŒÙ…_Ù‡Ù‡â€ŒÛŒÙ†ÛŒ_Ø´Ù‡â€ŒÙ…Ù…Ù‡â€Œ".split("_"),
        weekdaysMin: "ÛŒ_Ø¯_Ø³_Ú†_Ù¾_Ù‡_Ø´".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        meridiemParse: /Ø¦ÛŽÙˆØ§Ø±Ù‡â€Œ|Ø¨Ù‡â€ŒÛŒØ§Ù†ÛŒ/,
        isPM: function(input) {
          return /Ø¦ÛŽÙˆØ§Ø±Ù‡â€Œ/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 12) {
            return "Ø¨Ù‡â€ŒÛŒØ§Ù†ÛŒ";
          } else {
            return "Ø¦ÛŽÙˆØ§Ø±Ù‡â€Œ";
          }
        },
        calendar: {
          sameDay: "[Ø¦Ù‡â€ŒÙ…Ø±Û† ÙƒØ§ØªÚ˜Ù…ÛŽØ±] LT",
          nextDay: "[Ø¨Ù‡â€ŒÛŒØ§Ù†ÛŒ ÙƒØ§ØªÚ˜Ù…ÛŽØ±] LT",
          nextWeek: "dddd [ÙƒØ§ØªÚ˜Ù…ÛŽØ±] LT",
          lastDay: "[Ø¯ÙˆÛŽÙ†ÛŽ ÙƒØ§ØªÚ˜Ù…ÛŽØ±] LT",
          lastWeek: "dddd [ÙƒØ§ØªÚ˜Ù…ÛŽØ±] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "Ù„Ù‡â€Œ %s",
          past: "%s",
          s: "Ú†Ù‡â€ŒÙ†Ø¯ Ú†Ø±ÙƒÙ‡â€ŒÛŒÙ‡â€ŒÙƒ",
          ss: "Ú†Ø±ÙƒÙ‡â€Œ %d",
          m: "ÛŒÙ‡â€ŒÙƒ Ø®ÙˆÙ„Ù‡â€ŒÙƒ",
          mm: "%d Ø®ÙˆÙ„Ù‡â€ŒÙƒ",
          h: "ÛŒÙ‡â€ŒÙƒ ÙƒØ§ØªÚ˜Ù…ÛŽØ±",
          hh: "%d ÙƒØ§ØªÚ˜Ù…ÛŽØ±",
          d: "ÛŒÙ‡â€ŒÙƒ Ú•Û†Ú˜",
          dd: "%d Ú•Û†Ú˜",
          M: "ÛŒÙ‡â€ŒÙƒ Ù…Ø§Ù†Ú¯",
          MM: "%d Ù…Ø§Ù†Ú¯",
          y: "ÛŒÙ‡â€ŒÙƒ Ø³Ø§Úµ",
          yy: "%d Ø³Ø§Úµ"
        },
        preparse: function(string2) {
          return string2.replace(/[Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©Ù ]/g, function(match) {
            return numberMap$b[match];
          }).replace(/ØŒ/g, ",");
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap$c[match];
          }).replace(/,/g, "ØŒ");
        },
        week: {
          dow: 6,
          // Saturday is the first day of the week.
          doy: 12
          // The week that contains Jan 12th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var suffixes$2 = {
        0: "-Ñ‡Ò¯",
        1: "-Ñ‡Ð¸",
        2: "-Ñ‡Ð¸",
        3: "-Ñ‡Ò¯",
        4: "-Ñ‡Ò¯",
        5: "-Ñ‡Ð¸",
        6: "-Ñ‡Ñ‹",
        7: "-Ñ‡Ð¸",
        8: "-Ñ‡Ð¸",
        9: "-Ñ‡Ñƒ",
        10: "-Ñ‡Ñƒ",
        20: "-Ñ‡Ñ‹",
        30: "-Ñ‡Ñƒ",
        40: "-Ñ‡Ñ‹",
        50: "-Ñ‡Ò¯",
        60: "-Ñ‡Ñ‹",
        70: "-Ñ‡Ð¸",
        80: "-Ñ‡Ð¸",
        90: "-Ñ‡Ñƒ",
        100: "-Ñ‡Ò¯"
      };
      hooks.defineLocale("ky", {
        months: "ÑÐ½Ð²Ð°Ñ€ÑŒ_Ñ„ÐµÐ²Ñ€Ð°Ð»ÑŒ_Ð¼Ð°Ñ€Ñ‚_Ð°Ð¿Ñ€ÐµÐ»ÑŒ_Ð¼Ð°Ð¹_Ð¸ÑŽÐ½ÑŒ_Ð¸ÑŽÐ»ÑŒ_Ð°Ð²Ð³ÑƒÑÑ‚_ÑÐµÐ½Ñ‚ÑÐ±Ñ€ÑŒ_Ð¾ÐºÑ‚ÑÐ±Ñ€ÑŒ_Ð½Ð¾ÑÐ±Ñ€ÑŒ_Ð´ÐµÐºÐ°Ð±Ñ€ÑŒ".split(
          "_"
        ),
        monthsShort: "ÑÐ½Ð²_Ñ„ÐµÐ²_Ð¼Ð°Ñ€Ñ‚_Ð°Ð¿Ñ€_Ð¼Ð°Ð¹_Ð¸ÑŽÐ½ÑŒ_Ð¸ÑŽÐ»ÑŒ_Ð°Ð²Ð³_ÑÐµÐ½_Ð¾ÐºÑ‚_Ð½Ð¾Ñ_Ð´ÐµÐº".split(
          "_"
        ),
        weekdays: "Ð–ÐµÐºÑˆÐµÐ¼Ð±Ð¸_Ð”Ò¯Ð¹ÑˆÓ©Ð¼Ð±Ò¯_Ð¨ÐµÐ¹ÑˆÐµÐ¼Ð±Ð¸_Ð¨Ð°Ñ€ÑˆÐµÐ¼Ð±Ð¸_Ð‘ÐµÐ¹ÑˆÐµÐ¼Ð±Ð¸_Ð–ÑƒÐ¼Ð°_Ð˜ÑˆÐµÐ¼Ð±Ð¸".split(
          "_"
        ),
        weekdaysShort: "Ð–ÐµÐº_Ð”Ò¯Ð¹_Ð¨ÐµÐ¹_Ð¨Ð°Ñ€_Ð‘ÐµÐ¹_Ð–ÑƒÐ¼_Ð˜ÑˆÐµ".split("_"),
        weekdaysMin: "Ð–Ðº_Ð”Ð¹_Ð¨Ð¹_Ð¨Ñ€_Ð‘Ð¹_Ð–Ð¼_Ð˜Ñˆ".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Ð‘Ò¯Ð³Ò¯Ð½ ÑÐ°Ð°Ñ‚] LT",
          nextDay: "[Ð­Ñ€Ñ‚ÐµÒ£ ÑÐ°Ð°Ñ‚] LT",
          nextWeek: "dddd [ÑÐ°Ð°Ñ‚] LT",
          lastDay: "[ÐšÐµÑ‡ÑÑ ÑÐ°Ð°Ñ‚] LT",
          lastWeek: "[Ó¨Ñ‚ÐºÓ©Ð½ Ð°Ð¿Ñ‚Ð°Ð½Ñ‹Ð½] dddd [ÐºÒ¯Ð½Ò¯] [ÑÐ°Ð°Ñ‚] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s Ð¸Ñ‡Ð¸Ð½Ð´Ðµ",
          past: "%s Ð¼ÑƒÑ€ÑƒÐ½",
          s: "Ð±Ð¸Ñ€Ð½ÐµÑ‡Ðµ ÑÐµÐºÑƒÐ½Ð´",
          ss: "%d ÑÐµÐºÑƒÐ½Ð´",
          m: "Ð±Ð¸Ñ€ Ð¼Ò¯Ð½Ó©Ñ‚",
          mm: "%d Ð¼Ò¯Ð½Ó©Ñ‚",
          h: "Ð±Ð¸Ñ€ ÑÐ°Ð°Ñ‚",
          hh: "%d ÑÐ°Ð°Ñ‚",
          d: "Ð±Ð¸Ñ€ ÐºÒ¯Ð½",
          dd: "%d ÐºÒ¯Ð½",
          M: "Ð±Ð¸Ñ€ Ð°Ð¹",
          MM: "%d Ð°Ð¹",
          y: "Ð±Ð¸Ñ€ Ð¶Ñ‹Ð»",
          yy: "%d Ð¶Ñ‹Ð»"
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(Ñ‡Ð¸|Ñ‡Ñ‹|Ñ‡Ò¯|Ñ‡Ñƒ)/,
        ordinal: function(number2) {
          var a = number2 % 10, b = number2 >= 100 ? 100 : null;
          return number2 + (suffixes$2[number2] || suffixes$2[a] || suffixes$2[b]);
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      function processRelativeTime$8(number2, withoutSuffix, key, isFuture) {
        var format2 = {
          m: ["eng Minutt", "enger Minutt"],
          h: ["eng Stonn", "enger Stonn"],
          d: ["een Dag", "engem Dag"],
          M: ["ee Mount", "engem Mount"],
          y: ["ee Joer", "engem Joer"]
        };
        return withoutSuffix ? format2[key][0] : format2[key][1];
      }
      function processFutureTime(string2) {
        var number2 = string2.substr(0, string2.indexOf(" "));
        if (eifelerRegelAppliesToNumber(number2)) {
          return "a " + string2;
        }
        return "an " + string2;
      }
      function processPastTime(string2) {
        var number2 = string2.substr(0, string2.indexOf(" "));
        if (eifelerRegelAppliesToNumber(number2)) {
          return "viru " + string2;
        }
        return "virun " + string2;
      }
      function eifelerRegelAppliesToNumber(number2) {
        number2 = parseInt(number2, 10);
        if (isNaN(number2)) {
          return false;
        }
        if (number2 < 0) {
          return true;
        } else if (number2 < 10) {
          if (4 <= number2 && number2 <= 7) {
            return true;
          }
          return false;
        } else if (number2 < 100) {
          var lastDigit = number2 % 10, firstDigit = number2 / 10;
          if (lastDigit === 0) {
            return eifelerRegelAppliesToNumber(firstDigit);
          }
          return eifelerRegelAppliesToNumber(lastDigit);
        } else if (number2 < 1e4) {
          while (number2 >= 10) {
            number2 = number2 / 10;
          }
          return eifelerRegelAppliesToNumber(number2);
        } else {
          number2 = number2 / 1e3;
          return eifelerRegelAppliesToNumber(number2);
        }
      }
      hooks.defineLocale("lb", {
        months: "Januar_Februar_MÃ¤erz_AbrÃ«ll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split(
          "_"
        ),
        monthsShort: "Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "Sonndeg_MÃ©indeg_DÃ«nschdeg_MÃ«ttwoch_Donneschdeg_Freideg_Samschdeg".split(
          "_"
        ),
        weekdaysShort: "So._MÃ©._DÃ«._MÃ«._Do._Fr._Sa.".split("_"),
        weekdaysMin: "So_MÃ©_DÃ«_MÃ«_Do_Fr_Sa".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "H:mm [Auer]",
          LTS: "H:mm:ss [Auer]",
          L: "DD.MM.YYYY",
          LL: "D. MMMM YYYY",
          LLL: "D. MMMM YYYY H:mm [Auer]",
          LLLL: "dddd, D. MMMM YYYY H:mm [Auer]"
        },
        calendar: {
          sameDay: "[Haut um] LT",
          sameElse: "L",
          nextDay: "[Muer um] LT",
          nextWeek: "dddd [um] LT",
          lastDay: "[GÃ«schter um] LT",
          lastWeek: function() {
            switch (this.day()) {
              case 2:
              case 4:
                return "[Leschten] dddd [um] LT";
              default:
                return "[Leschte] dddd [um] LT";
            }
          }
        },
        relativeTime: {
          future: processFutureTime,
          past: processPastTime,
          s: "e puer Sekonnen",
          ss: "%d Sekonnen",
          m: processRelativeTime$8,
          mm: "%d Minutten",
          h: processRelativeTime$8,
          hh: "%d Stonnen",
          d: processRelativeTime$8,
          dd: "%d Deeg",
          M: processRelativeTime$8,
          MM: "%d MÃ©int",
          y: processRelativeTime$8,
          yy: "%d Joer"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("lo", {
        months: "àº¡àº±àº‡àºàº­àº™_àºàº¸àº¡àºžàº²_àº¡àºµàº™àº²_à»€àº¡àºªàº²_àºžàº¶àº”àºªàº°àºžàº²_àº¡àº´àº–àº¸àº™àº²_àºà»àº¥àº°àºàº»àº”_àºªàº´àº‡àº«àº²_àºàº±àº™àºàº²_àº•àº¸àº¥àº²_àºžàº°àºˆàº´àº_àº—àº±àº™àº§àº²".split(
          "_"
        ),
        monthsShort: "àº¡àº±àº‡àºàº­àº™_àºàº¸àº¡àºžàº²_àº¡àºµàº™àº²_à»€àº¡àºªàº²_àºžàº¶àº”àºªàº°àºžàº²_àº¡àº´àº–àº¸àº™àº²_àºà»àº¥àº°àºàº»àº”_àºªàº´àº‡àº«àº²_àºàº±àº™àºàº²_àº•àº¸àº¥àº²_àºžàº°àºˆàº´àº_àº—àº±àº™àº§àº²".split(
          "_"
        ),
        weekdays: "àº­àº²àº—àº´àº”_àºˆàº±àº™_àº­àº±àº‡àº„àº²àº™_àºžàº¸àº”_àºžàº°àº«àº±àº”_àºªàº¸àº_à»€àºªàº»àº²".split("_"),
        weekdaysShort: "àº—àº´àº”_àºˆàº±àº™_àº­àº±àº‡àº„àº²àº™_àºžàº¸àº”_àºžàº°àº«àº±àº”_àºªàº¸àº_à»€àºªàº»àº²".split("_"),
        weekdaysMin: "àº—_àºˆ_àº­àº„_àºž_àºžàº«_àºªàº_àºª".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "àº§àº±àº™dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /àº•àº­àº™à»€àºŠàº»à»‰àº²|àº•àº­àº™à»àº¥àº‡/,
        isPM: function(input) {
          return input === "àº•àº­àº™à»àº¥àº‡";
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 12) {
            return "àº•àº­àº™à»€àºŠàº»à»‰àº²";
          } else {
            return "àº•àº­àº™à»àº¥àº‡";
          }
        },
        calendar: {
          sameDay: "[àº¡àº·à»‰àº™àºµà»‰à»€àº§àº¥àº²] LT",
          nextDay: "[àº¡àº·à»‰àº­àº·à»ˆàº™à»€àº§àº¥àº²] LT",
          nextWeek: "[àº§àº±àº™]dddd[à»œà»‰àº²à»€àº§àº¥àº²] LT",
          lastDay: "[àº¡àº·à»‰àº§àº²àº™àº™àºµà»‰à»€àº§àº¥àº²] LT",
          lastWeek: "[àº§àº±àº™]dddd[à»àº¥à»‰àº§àº™àºµà»‰à»€àº§àº¥àº²] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "àº­àºµàº %s",
          past: "%sàºœà»ˆàº²àº™àº¡àº²",
          s: "àºšà»à»ˆà»€àº—àº»à»ˆàº²à»ƒàº”àº§àº´àº™àº²àº—àºµ",
          ss: "%d àº§àº´àº™àº²àº—àºµ",
          m: "1 àº™àº²àº—àºµ",
          mm: "%d àº™àº²àº—àºµ",
          h: "1 àºŠàº»à»ˆàº§à»‚àº¡àº‡",
          hh: "%d àºŠàº»à»ˆàº§à»‚àº¡àº‡",
          d: "1 àº¡àº·à»‰",
          dd: "%d àº¡àº·à»‰",
          M: "1 à»€àº”àº·àº­àº™",
          MM: "%d à»€àº”àº·àº­àº™",
          y: "1 àº›àºµ",
          yy: "%d àº›àºµ"
        },
        dayOfMonthOrdinalParse: /(àº—àºµà»ˆ)\d{1,2}/,
        ordinal: function(number2) {
          return "àº—àºµà»ˆ" + number2;
        }
      });
      //! moment.js locale configuration
      var units = {
        ss: "sekundÄ—_sekundÅ¾iÅ³_sekundes",
        m: "minutÄ—_minutÄ—s_minutÄ™",
        mm: "minutÄ—s_minuÄiÅ³_minutes",
        h: "valanda_valandos_valandÄ…",
        hh: "valandos_valandÅ³_valandas",
        d: "diena_dienos_dienÄ…",
        dd: "dienos_dienÅ³_dienas",
        M: "mÄ—nuo_mÄ—nesio_mÄ—nesÄ¯",
        MM: "mÄ—nesiai_mÄ—nesiÅ³_mÄ—nesius",
        y: "metai_metÅ³_metus",
        yy: "metai_metÅ³_metus"
      };
      function translateSeconds(number2, withoutSuffix, key, isFuture) {
        if (withoutSuffix) {
          return "kelios sekundÄ—s";
        } else {
          return isFuture ? "keliÅ³ sekundÅ¾iÅ³" : "kelias sekundes";
        }
      }
      function translateSingular(number2, withoutSuffix, key, isFuture) {
        return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
      }
      function special(number2) {
        return number2 % 10 === 0 || number2 > 10 && number2 < 20;
      }
      function forms(key) {
        return units[key].split("_");
      }
      function translate$6(number2, withoutSuffix, key, isFuture) {
        var result = number2 + " ";
        if (number2 === 1) {
          return result + translateSingular(number2, withoutSuffix, key[0], isFuture);
        } else if (withoutSuffix) {
          return result + (special(number2) ? forms(key)[1] : forms(key)[0]);
        } else {
          if (isFuture) {
            return result + forms(key)[1];
          } else {
            return result + (special(number2) ? forms(key)[1] : forms(key)[2]);
          }
        }
      }
      hooks.defineLocale("lt", {
        months: {
          format: "sausio_vasario_kovo_balandÅ¾io_geguÅ¾Ä—s_birÅ¾elio_liepos_rugpjÅ«Äio_rugsÄ—jo_spalio_lapkriÄio_gruodÅ¾io".split(
            "_"
          ),
          standalone: "sausis_vasaris_kovas_balandis_geguÅ¾Ä—_birÅ¾elis_liepa_rugpjÅ«tis_rugsÄ—jis_spalis_lapkritis_gruodis".split(
            "_"
          ),
          isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
        },
        monthsShort: "sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"),
        weekdays: {
          format: "sekmadienÄ¯_pirmadienÄ¯_antradienÄ¯_treÄiadienÄ¯_ketvirtadienÄ¯_penktadienÄ¯_Å¡eÅ¡tadienÄ¯".split(
            "_"
          ),
          standalone: "sekmadienis_pirmadienis_antradienis_treÄiadienis_ketvirtadienis_penktadienis_Å¡eÅ¡tadienis".split(
            "_"
          ),
          isFormat: /dddd HH:mm/
        },
        weekdaysShort: "Sek_Pir_Ant_Tre_Ket_Pen_Å eÅ¡".split("_"),
        weekdaysMin: "S_P_A_T_K_Pn_Å ".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "YYYY-MM-DD",
          LL: "YYYY [m.] MMMM D [d.]",
          LLL: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
          LLLL: "YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]",
          l: "YYYY-MM-DD",
          ll: "YYYY [m.] MMMM D [d.]",
          lll: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
          llll: "YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]"
        },
        calendar: {
          sameDay: "[Å iandien] LT",
          nextDay: "[Rytoj] LT",
          nextWeek: "dddd LT",
          lastDay: "[Vakar] LT",
          lastWeek: "[PraÄ—jusÄ¯] dddd LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "po %s",
          past: "prieÅ¡ %s",
          s: translateSeconds,
          ss: translate$6,
          m: translateSingular,
          mm: translate$6,
          h: translateSingular,
          hh: translate$6,
          d: translateSingular,
          dd: translate$6,
          M: translateSingular,
          MM: translate$6,
          y: translateSingular,
          yy: translate$6
        },
        dayOfMonthOrdinalParse: /\d{1,2}-oji/,
        ordinal: function(number2) {
          return number2 + "-oji";
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var units$1 = {
        ss: "sekundes_sekundÄ“m_sekunde_sekundes".split("_"),
        m: "minÅ«tes_minÅ«tÄ“m_minÅ«te_minÅ«tes".split("_"),
        mm: "minÅ«tes_minÅ«tÄ“m_minÅ«te_minÅ«tes".split("_"),
        h: "stundas_stundÄm_stunda_stundas".split("_"),
        hh: "stundas_stundÄm_stunda_stundas".split("_"),
        d: "dienas_dienÄm_diena_dienas".split("_"),
        dd: "dienas_dienÄm_diena_dienas".split("_"),
        M: "mÄ“neÅ¡a_mÄ“neÅ¡iem_mÄ“nesis_mÄ“neÅ¡i".split("_"),
        MM: "mÄ“neÅ¡a_mÄ“neÅ¡iem_mÄ“nesis_mÄ“neÅ¡i".split("_"),
        y: "gada_gadiem_gads_gadi".split("_"),
        yy: "gada_gadiem_gads_gadi".split("_")
      };
      function format$1(forms2, number2, withoutSuffix) {
        if (withoutSuffix) {
          return number2 % 10 === 1 && number2 % 100 !== 11 ? forms2[2] : forms2[3];
        } else {
          return number2 % 10 === 1 && number2 % 100 !== 11 ? forms2[0] : forms2[1];
        }
      }
      function relativeTimeWithPlural$1(number2, withoutSuffix, key) {
        return number2 + " " + format$1(units$1[key], number2, withoutSuffix);
      }
      function relativeTimeWithSingular(number2, withoutSuffix, key) {
        return format$1(units$1[key], number2, withoutSuffix);
      }
      function relativeSeconds(number2, withoutSuffix) {
        return withoutSuffix ? "daÅ¾as sekundes" : "daÅ¾Äm sekundÄ“m";
      }
      hooks.defineLocale("lv", {
        months: "janvÄris_februÄris_marts_aprÄ«lis_maijs_jÅ«nijs_jÅ«lijs_augusts_septembris_oktobris_novembris_decembris".split(
          "_"
        ),
        monthsShort: "jan_feb_mar_apr_mai_jÅ«n_jÅ«l_aug_sep_okt_nov_dec".split("_"),
        weekdays: "svÄ“tdiena_pirmdiena_otrdiena_treÅ¡diena_ceturtdiena_piektdiena_sestdiena".split(
          "_"
        ),
        weekdaysShort: "Sv_P_O_T_C_Pk_S".split("_"),
        weekdaysMin: "Sv_P_O_T_C_Pk_S".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY.",
          LL: "YYYY. [gada] D. MMMM",
          LLL: "YYYY. [gada] D. MMMM, HH:mm",
          LLLL: "YYYY. [gada] D. MMMM, dddd, HH:mm"
        },
        calendar: {
          sameDay: "[Å odien pulksten] LT",
          nextDay: "[RÄ«t pulksten] LT",
          nextWeek: "dddd [pulksten] LT",
          lastDay: "[Vakar pulksten] LT",
          lastWeek: "[PagÄjuÅ¡Ä] dddd [pulksten] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "pÄ“c %s",
          past: "pirms %s",
          s: relativeSeconds,
          ss: relativeTimeWithPlural$1,
          m: relativeTimeWithSingular,
          mm: relativeTimeWithPlural$1,
          h: relativeTimeWithSingular,
          hh: relativeTimeWithPlural$1,
          d: relativeTimeWithSingular,
          dd: relativeTimeWithPlural$1,
          M: relativeTimeWithSingular,
          MM: relativeTimeWithPlural$1,
          y: relativeTimeWithSingular,
          yy: relativeTimeWithPlural$1
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var translator = {
        words: {
          //Different grammatical cases
          ss: ["sekund", "sekunda", "sekundi"],
          m: ["jedan minut", "jednog minuta"],
          mm: ["minut", "minuta", "minuta"],
          h: ["jedan sat", "jednog sata"],
          hh: ["sat", "sata", "sati"],
          dd: ["dan", "dana", "dana"],
          MM: ["mjesec", "mjeseca", "mjeseci"],
          yy: ["godina", "godine", "godina"]
        },
        correctGrammaticalCase: function(number2, wordKey) {
          return number2 === 1 ? wordKey[0] : number2 >= 2 && number2 <= 4 ? wordKey[1] : wordKey[2];
        },
        translate: function(number2, withoutSuffix, key) {
          var wordKey = translator.words[key];
          if (key.length === 1) {
            return withoutSuffix ? wordKey[0] : wordKey[1];
          } else {
            return number2 + " " + translator.correctGrammaticalCase(number2, wordKey);
          }
        }
      };
      hooks.defineLocale("me", {
        months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split(
          "_"
        ),
        monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
        monthsParseExact: true,
        weekdays: "nedjelja_ponedjeljak_utorak_srijeda_Äetvrtak_petak_subota".split(
          "_"
        ),
        weekdaysShort: "ned._pon._uto._sri._Äet._pet._sub.".split("_"),
        weekdaysMin: "ne_po_ut_sr_Äe_pe_su".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D. MMMM YYYY",
          LLL: "D. MMMM YYYY H:mm",
          LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
          sameDay: "[danas u] LT",
          nextDay: "[sjutra u] LT",
          nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[u] [nedjelju] [u] LT";
              case 3:
                return "[u] [srijedu] [u] LT";
              case 6:
                return "[u] [subotu] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[u] dddd [u] LT";
            }
          },
          lastDay: "[juÄe u] LT",
          lastWeek: function() {
            var lastWeekDays = [
              "[proÅ¡le] [nedjelje] [u] LT",
              "[proÅ¡log] [ponedjeljka] [u] LT",
              "[proÅ¡log] [utorka] [u] LT",
              "[proÅ¡le] [srijede] [u] LT",
              "[proÅ¡log] [Äetvrtka] [u] LT",
              "[proÅ¡log] [petka] [u] LT",
              "[proÅ¡le] [subote] [u] LT"
            ];
            return lastWeekDays[this.day()];
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "za %s",
          past: "prije %s",
          s: "nekoliko sekundi",
          ss: translator.translate,
          m: translator.translate,
          mm: translator.translate,
          h: translator.translate,
          hh: translator.translate,
          d: "dan",
          dd: translator.translate,
          M: "mjesec",
          MM: translator.translate,
          y: "godinu",
          yy: translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("mi", {
        months: "Kohi-tÄte_Hui-tanguru_PoutÅ«-te-rangi_Paenga-whÄwhÄ_Haratua_Pipiri_HÅngoingoi_Here-turi-kÅkÄ_Mahuru_Whiringa-Ä-nuku_Whiringa-Ä-rangi_Hakihea".split(
          "_"
        ),
        monthsShort: "Kohi_Hui_Pou_Pae_Hara_Pipi_HÅngoi_Here_Mahu_Whi-nu_Whi-ra_Haki".split(
          "_"
        ),
        monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
        weekdays: "RÄtapu_Mane_TÅ«rei_Wenerei_TÄite_Paraire_HÄtarei".split("_"),
        weekdaysShort: "Ta_Ma_TÅ«_We_TÄi_Pa_HÄ".split("_"),
        weekdaysMin: "Ta_Ma_TÅ«_We_TÄi_Pa_HÄ".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY [i] HH:mm",
          LLLL: "dddd, D MMMM YYYY [i] HH:mm"
        },
        calendar: {
          sameDay: "[i teie mahana, i] LT",
          nextDay: "[apopo i] LT",
          nextWeek: "dddd [i] LT",
          lastDay: "[inanahi i] LT",
          lastWeek: "dddd [whakamutunga i] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "i roto i %s",
          past: "%s i mua",
          s: "te hÄ“kona ruarua",
          ss: "%d hÄ“kona",
          m: "he meneti",
          mm: "%d meneti",
          h: "te haora",
          hh: "%d haora",
          d: "he ra",
          dd: "%d ra",
          M: "he marama",
          MM: "%d marama",
          y: "he tau",
          yy: "%d tau"
        },
        dayOfMonthOrdinalParse: /\d{1,2}Âº/,
        ordinal: "%dÂº",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("mk", {
        months: "Ñ˜Ð°Ð½ÑƒÐ°Ñ€Ð¸_Ñ„ÐµÐ²Ñ€ÑƒÐ°Ñ€Ð¸_Ð¼Ð°Ñ€Ñ‚_Ð°Ð¿Ñ€Ð¸Ð»_Ð¼Ð°Ñ˜_Ñ˜ÑƒÐ½Ð¸_Ñ˜ÑƒÐ»Ð¸_Ð°Ð²Ð³ÑƒÑÑ‚_ÑÐµÐ¿Ñ‚ÐµÐ¼Ð²Ñ€Ð¸_Ð¾ÐºÑ‚Ð¾Ð¼Ð²Ñ€Ð¸_Ð½Ð¾ÐµÐ¼Ð²Ñ€Ð¸_Ð´ÐµÐºÐµÐ¼Ð²Ñ€Ð¸".split(
          "_"
        ),
        monthsShort: "Ñ˜Ð°Ð½_Ñ„ÐµÐ²_Ð¼Ð°Ñ€_Ð°Ð¿Ñ€_Ð¼Ð°Ñ˜_Ñ˜ÑƒÐ½_Ñ˜ÑƒÐ»_Ð°Ð²Ð³_ÑÐµÐ¿_Ð¾ÐºÑ‚_Ð½Ð¾Ðµ_Ð´ÐµÐº".split("_"),
        weekdays: "Ð½ÐµÐ´ÐµÐ»Ð°_Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»Ð½Ð¸Ðº_Ð²Ñ‚Ð¾Ñ€Ð½Ð¸Ðº_ÑÑ€ÐµÐ´Ð°_Ñ‡ÐµÑ‚Ð²Ñ€Ñ‚Ð¾Ðº_Ð¿ÐµÑ‚Ð¾Ðº_ÑÐ°Ð±Ð¾Ñ‚Ð°".split(
          "_"
        ),
        weekdaysShort: "Ð½ÐµÐ´_Ð¿Ð¾Ð½_Ð²Ñ‚Ð¾_ÑÑ€Ðµ_Ñ‡ÐµÑ‚_Ð¿ÐµÑ‚_ÑÐ°Ð±".split("_"),
        weekdaysMin: "Ð½e_Ð¿o_Ð²Ñ‚_ÑÑ€_Ñ‡Ðµ_Ð¿Ðµ_Ña".split("_"),
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "D.MM.YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY H:mm",
          LLLL: "dddd, D MMMM YYYY H:mm"
        },
        calendar: {
          sameDay: "[Ð”ÐµÐ½ÐµÑ Ð²Ð¾] LT",
          nextDay: "[Ð£Ñ‚Ñ€Ðµ Ð²Ð¾] LT",
          nextWeek: "[Ð’Ð¾] dddd [Ð²Ð¾] LT",
          lastDay: "[Ð’Ñ‡ÐµÑ€Ð° Ð²Ð¾] LT",
          lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
              case 6:
                return "[Ð˜Ð·Ð¼Ð¸Ð½Ð°Ñ‚Ð°Ñ‚Ð°] dddd [Ð²Ð¾] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[Ð˜Ð·Ð¼Ð¸Ð½Ð°Ñ‚Ð¸Ð¾Ñ‚] dddd [Ð²Ð¾] LT";
            }
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "Ð·Ð° %s",
          past: "Ð¿Ñ€ÐµÐ´ %s",
          s: "Ð½ÐµÐºÐ¾Ð»ÐºÑƒ ÑÐµÐºÑƒÐ½Ð´Ð¸",
          ss: "%d ÑÐµÐºÑƒÐ½Ð´Ð¸",
          m: "ÐµÐ´Ð½Ð° Ð¼Ð¸Ð½ÑƒÑ‚Ð°",
          mm: "%d Ð¼Ð¸Ð½ÑƒÑ‚Ð¸",
          h: "ÐµÐ´ÐµÐ½ Ñ‡Ð°Ñ",
          hh: "%d Ñ‡Ð°ÑÐ°",
          d: "ÐµÐ´ÐµÐ½ Ð´ÐµÐ½",
          dd: "%d Ð´ÐµÐ½Ð°",
          M: "ÐµÐ´ÐµÐ½ Ð¼ÐµÑÐµÑ†",
          MM: "%d Ð¼ÐµÑÐµÑ†Ð¸",
          y: "ÐµÐ´Ð½Ð° Ð³Ð¾Ð´Ð¸Ð½Ð°",
          yy: "%d Ð³Ð¾Ð´Ð¸Ð½Ð¸"
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ÐµÐ²|ÐµÐ½|Ñ‚Ð¸|Ð²Ð¸|Ñ€Ð¸|Ð¼Ð¸)/,
        ordinal: function(number2) {
          var lastDigit = number2 % 10, last2Digits = number2 % 100;
          if (number2 === 0) {
            return number2 + "-ÐµÐ²";
          } else if (last2Digits === 0) {
            return number2 + "-ÐµÐ½";
          } else if (last2Digits > 10 && last2Digits < 20) {
            return number2 + "-Ñ‚Ð¸";
          } else if (lastDigit === 1) {
            return number2 + "-Ð²Ð¸";
          } else if (lastDigit === 2) {
            return number2 + "-Ñ€Ð¸";
          } else if (lastDigit === 7 || lastDigit === 8) {
            return number2 + "-Ð¼Ð¸";
          } else {
            return number2 + "-Ñ‚Ð¸";
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("ml", {
        months: "à´œà´¨àµà´µà´°à´¿_à´«àµ†à´¬àµà´°àµà´µà´°à´¿_à´®à´¾àµ¼à´šàµà´šàµ_à´à´ªàµà´°à´¿àµ½_à´®àµ‡à´¯àµ_à´œàµ‚àµº_à´œàµ‚à´²àµˆ_à´“à´—à´¸àµà´±àµà´±àµ_à´¸àµ†à´ªàµà´±àµà´±à´‚à´¬àµ¼_à´’à´•àµà´Ÿàµ‹à´¬àµ¼_à´¨à´µà´‚à´¬àµ¼_à´¡à´¿à´¸à´‚à´¬àµ¼".split(
          "_"
        ),
        monthsShort: "à´œà´¨àµ._à´«àµ†à´¬àµà´°àµ._à´®à´¾àµ¼._à´à´ªàµà´°à´¿._à´®àµ‡à´¯àµ_à´œàµ‚àµº_à´œàµ‚à´²àµˆ._à´“à´—._à´¸àµ†à´ªàµà´±àµà´±._à´’à´•àµà´Ÿàµ‹._à´¨à´µà´‚._à´¡à´¿à´¸à´‚.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "à´žà´¾à´¯à´±à´¾à´´àµà´š_à´¤à´¿à´™àµà´•à´³à´¾à´´àµà´š_à´šàµŠà´µàµà´µà´¾à´´àµà´š_à´¬àµà´§à´¨à´¾à´´àµà´š_à´µàµà´¯à´¾à´´à´¾à´´àµà´š_à´µàµ†à´³àµà´³à´¿à´¯à´¾à´´àµà´š_à´¶à´¨à´¿à´¯à´¾à´´àµà´š".split(
          "_"
        ),
        weekdaysShort: "à´žà´¾à´¯àµ¼_à´¤à´¿à´™àµà´•àµ¾_à´šàµŠà´µàµà´µ_à´¬àµà´§àµ»_à´µàµà´¯à´¾à´´à´‚_à´µàµ†à´³àµà´³à´¿_à´¶à´¨à´¿".split("_"),
        weekdaysMin: "à´žà´¾_à´¤à´¿_à´šàµŠ_à´¬àµ_à´µàµà´¯à´¾_à´µàµ†_à´¶".split("_"),
        longDateFormat: {
          LT: "A h:mm -à´¨àµ",
          LTS: "A h:mm:ss -à´¨àµ",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY, A h:mm -à´¨àµ",
          LLLL: "dddd, D MMMM YYYY, A h:mm -à´¨àµ"
        },
        calendar: {
          sameDay: "[à´‡à´¨àµà´¨àµ] LT",
          nextDay: "[à´¨à´¾à´³àµ†] LT",
          nextWeek: "dddd, LT",
          lastDay: "[à´‡à´¨àµà´¨à´²àµ†] LT",
          lastWeek: "[à´•à´´à´¿à´žàµà´ž] dddd, LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s à´•à´´à´¿à´žàµà´žàµ",
          past: "%s à´®àµàµ»à´ªàµ",
          s: "à´…àµ½à´ª à´¨à´¿à´®à´¿à´·à´™àµà´™àµ¾",
          ss: "%d à´¸àµ†à´•àµà´•àµ»à´¡àµ",
          m: "à´’à´°àµ à´®à´¿à´¨à´¿à´±àµà´±àµ",
          mm: "%d à´®à´¿à´¨à´¿à´±àµà´±àµ",
          h: "à´’à´°àµ à´®à´£à´¿à´•àµà´•àµ‚àµ¼",
          hh: "%d à´®à´£à´¿à´•àµà´•àµ‚àµ¼",
          d: "à´’à´°àµ à´¦à´¿à´µà´¸à´‚",
          dd: "%d à´¦à´¿à´µà´¸à´‚",
          M: "à´’à´°àµ à´®à´¾à´¸à´‚",
          MM: "%d à´®à´¾à´¸à´‚",
          y: "à´’à´°àµ à´µàµ¼à´·à´‚",
          yy: "%d à´µàµ¼à´·à´‚"
        },
        meridiemParse: /à´°à´¾à´¤àµà´°à´¿|à´°à´¾à´µà´¿à´²àµ†|à´‰à´šàµà´š à´•à´´à´¿à´žàµà´žàµ|à´µàµˆà´•àµà´¨àµà´¨àµ‡à´°à´‚|à´°à´¾à´¤àµà´°à´¿/i,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "à´°à´¾à´¤àµà´°à´¿" && hour >= 4 || meridiem2 === "à´‰à´šàµà´š à´•à´´à´¿à´žàµà´žàµ" || meridiem2 === "à´µàµˆà´•àµà´¨àµà´¨àµ‡à´°à´‚") {
            return hour + 12;
          } else {
            return hour;
          }
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "à´°à´¾à´¤àµà´°à´¿";
          } else if (hour < 12) {
            return "à´°à´¾à´µà´¿à´²àµ†";
          } else if (hour < 17) {
            return "à´‰à´šàµà´š à´•à´´à´¿à´žàµà´žàµ";
          } else if (hour < 20) {
            return "à´µàµˆà´•àµà´¨àµà´¨àµ‡à´°à´‚";
          } else {
            return "à´°à´¾à´¤àµà´°à´¿";
          }
        }
      });
      //! moment.js locale configuration
      function translate$7(number2, withoutSuffix, key, isFuture) {
        switch (key) {
          case "s":
            return withoutSuffix ? "Ñ…ÑÐ´Ñ…ÑÐ½ ÑÐµÐºÑƒÐ½Ð´" : "Ñ…ÑÐ´Ñ…ÑÐ½ ÑÐµÐºÑƒÐ½Ð´Ñ‹Ð½";
          case "ss":
            return number2 + (withoutSuffix ? " ÑÐµÐºÑƒÐ½Ð´" : " ÑÐµÐºÑƒÐ½Ð´Ñ‹Ð½");
          case "m":
          case "mm":
            return number2 + (withoutSuffix ? " Ð¼Ð¸Ð½ÑƒÑ‚" : " Ð¼Ð¸Ð½ÑƒÑ‚Ñ‹Ð½");
          case "h":
          case "hh":
            return number2 + (withoutSuffix ? " Ñ†Ð°Ð³" : " Ñ†Ð°Ð³Ð¸Ð¹Ð½");
          case "d":
          case "dd":
            return number2 + (withoutSuffix ? " Ó©Ð´Ó©Ñ€" : " Ó©Ð´Ñ€Ð¸Ð¹Ð½");
          case "M":
          case "MM":
            return number2 + (withoutSuffix ? " ÑÐ°Ñ€" : " ÑÐ°Ñ€Ñ‹Ð½");
          case "y":
          case "yy":
            return number2 + (withoutSuffix ? " Ð¶Ð¸Ð»" : " Ð¶Ð¸Ð»Ð¸Ð¹Ð½");
          default:
            return number2;
        }
      }
      hooks.defineLocale("mn", {
        months: "ÐÑÐ³Ð´Ò¯Ð³ÑÑÑ€ ÑÐ°Ñ€_Ð¥Ð¾Ñ‘Ñ€Ð´ÑƒÐ³Ð°Ð°Ñ€ ÑÐ°Ñ€_Ð“ÑƒÑ€Ð°Ð²Ð´ÑƒÐ³Ð°Ð°Ñ€ ÑÐ°Ñ€_Ð”Ó©Ñ€Ó©Ð²Ð´Ò¯Ð³ÑÑÑ€ ÑÐ°Ñ€_Ð¢Ð°Ð²Ð´ÑƒÐ³Ð°Ð°Ñ€ ÑÐ°Ñ€_Ð—ÑƒÑ€Ð³Ð°Ð´ÑƒÐ³Ð°Ð°Ñ€ ÑÐ°Ñ€_Ð”Ð¾Ð»Ð´ÑƒÐ³Ð°Ð°Ñ€ ÑÐ°Ñ€_ÐÐ°Ð¹Ð¼Ð´ÑƒÐ³Ð°Ð°Ñ€ ÑÐ°Ñ€_Ð•ÑÐ´Ò¯Ð³ÑÑÑ€ ÑÐ°Ñ€_ÐÑ€Ð°Ð²Ð´ÑƒÐ³Ð°Ð°Ñ€ ÑÐ°Ñ€_ÐÑ€Ð²Ð°Ð½ Ð½ÑÐ³Ð´Ò¯Ð³ÑÑÑ€ ÑÐ°Ñ€_ÐÑ€Ð²Ð°Ð½ Ñ…Ð¾Ñ‘Ñ€Ð´ÑƒÐ³Ð°Ð°Ñ€ ÑÐ°Ñ€".split(
          "_"
        ),
        monthsShort: "1 ÑÐ°Ñ€_2 ÑÐ°Ñ€_3 ÑÐ°Ñ€_4 ÑÐ°Ñ€_5 ÑÐ°Ñ€_6 ÑÐ°Ñ€_7 ÑÐ°Ñ€_8 ÑÐ°Ñ€_9 ÑÐ°Ñ€_10 ÑÐ°Ñ€_11 ÑÐ°Ñ€_12 ÑÐ°Ñ€".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "ÐÑÐ¼_Ð”Ð°Ð²Ð°Ð°_ÐœÑÐ³Ð¼Ð°Ñ€_Ð›Ñ…Ð°Ð³Ð²Ð°_ÐŸÒ¯Ñ€ÑÐ²_Ð‘Ð°Ð°ÑÐ°Ð½_Ð‘ÑÐ¼Ð±Ð°".split("_"),
        weekdaysShort: "ÐÑÐ¼_Ð”Ð°Ð²_ÐœÑÐ³_Ð›Ñ…Ð°_ÐŸÒ¯Ñ€_Ð‘Ð°Ð°_Ð‘ÑÐ¼".split("_"),
        weekdaysMin: "ÐÑ_Ð”Ð°_ÐœÑ_Ð›Ñ…_ÐŸÒ¯_Ð‘Ð°_Ð‘Ñ".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "YYYY-MM-DD",
          LL: "YYYY Ð¾Ð½Ñ‹ MMMMÑ‹Ð½ D",
          LLL: "YYYY Ð¾Ð½Ñ‹ MMMMÑ‹Ð½ D HH:mm",
          LLLL: "dddd, YYYY Ð¾Ð½Ñ‹ MMMMÑ‹Ð½ D HH:mm"
        },
        meridiemParse: /Ò®Ó¨|Ò®Ð¥/i,
        isPM: function(input) {
          return input === "Ò®Ð¥";
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 12) {
            return "Ò®Ó¨";
          } else {
            return "Ò®Ð¥";
          }
        },
        calendar: {
          sameDay: "[Ó¨Ð½Ó©Ó©Ð´Ó©Ñ€] LT",
          nextDay: "[ÐœÐ°Ñ€Ð³Ð°Ð°Ñˆ] LT",
          nextWeek: "[Ð˜Ñ€ÑÑ…] dddd LT",
          lastDay: "[Ó¨Ñ‡Ð¸Ð³Ð´Ó©Ñ€] LT",
          lastWeek: "[Ó¨Ð½Ð³Ó©Ñ€ÑÓ©Ð½] dddd LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s Ð´Ð°Ñ€Ð°Ð°",
          past: "%s Ó©Ð¼Ð½Ó©",
          s: translate$7,
          ss: translate$7,
          m: translate$7,
          mm: translate$7,
          h: translate$7,
          hh: translate$7,
          d: translate$7,
          dd: translate$7,
          M: translate$7,
          MM: translate$7,
          y: translate$7,
          yy: translate$7
        },
        dayOfMonthOrdinalParse: /\d{1,2} Ó©Ð´Ó©Ñ€/,
        ordinal: function(number2, period) {
          switch (period) {
            case "d":
            case "D":
            case "DDD":
              return number2 + " Ó©Ð´Ó©Ñ€";
            default:
              return number2;
          }
        }
      });
      //! moment.js locale configuration
      var symbolMap$d = {
        1: "à¥§",
        2: "à¥¨",
        3: "à¥©",
        4: "à¥ª",
        5: "à¥«",
        6: "à¥¬",
        7: "à¥­",
        8: "à¥®",
        9: "à¥¯",
        0: "à¥¦"
      }, numberMap$c = {
        "à¥§": "1",
        "à¥¨": "2",
        "à¥©": "3",
        "à¥ª": "4",
        "à¥«": "5",
        "à¥¬": "6",
        "à¥­": "7",
        "à¥®": "8",
        "à¥¯": "9",
        "à¥¦": "0"
      };
      function relativeTimeMr(number2, withoutSuffix, string2, isFuture) {
        var output = "";
        if (withoutSuffix) {
          switch (string2) {
            case "s":
              output = "à¤•à¤¾à¤¹à¥€ à¤¸à¥‡à¤•à¤‚à¤¦";
              break;
            case "ss":
              output = "%d à¤¸à¥‡à¤•à¤‚à¤¦";
              break;
            case "m":
              output = "à¤à¤• à¤®à¤¿à¤¨à¤¿à¤Ÿ";
              break;
            case "mm":
              output = "%d à¤®à¤¿à¤¨à¤¿à¤Ÿà¥‡";
              break;
            case "h":
              output = "à¤à¤• à¤¤à¤¾à¤¸";
              break;
            case "hh":
              output = "%d à¤¤à¤¾à¤¸";
              break;
            case "d":
              output = "à¤à¤• à¤¦à¤¿à¤µà¤¸";
              break;
            case "dd":
              output = "%d à¤¦à¤¿à¤µà¤¸";
              break;
            case "M":
              output = "à¤à¤• à¤®à¤¹à¤¿à¤¨à¤¾";
              break;
            case "MM":
              output = "%d à¤®à¤¹à¤¿à¤¨à¥‡";
              break;
            case "y":
              output = "à¤à¤• à¤µà¤°à¥à¤·";
              break;
            case "yy":
              output = "%d à¤µà¤°à¥à¤·à¥‡";
              break;
          }
        } else {
          switch (string2) {
            case "s":
              output = "à¤•à¤¾à¤¹à¥€ à¤¸à¥‡à¤•à¤‚à¤¦à¤¾à¤‚";
              break;
            case "ss":
              output = "%d à¤¸à¥‡à¤•à¤‚à¤¦à¤¾à¤‚";
              break;
            case "m":
              output = "à¤à¤•à¤¾ à¤®à¤¿à¤¨à¤¿à¤Ÿà¤¾";
              break;
            case "mm":
              output = "%d à¤®à¤¿à¤¨à¤¿à¤Ÿà¤¾à¤‚";
              break;
            case "h":
              output = "à¤à¤•à¤¾ à¤¤à¤¾à¤¸à¤¾";
              break;
            case "hh":
              output = "%d à¤¤à¤¾à¤¸à¤¾à¤‚";
              break;
            case "d":
              output = "à¤à¤•à¤¾ à¤¦à¤¿à¤µà¤¸à¤¾";
              break;
            case "dd":
              output = "%d à¤¦à¤¿à¤µà¤¸à¤¾à¤‚";
              break;
            case "M":
              output = "à¤à¤•à¤¾ à¤®à¤¹à¤¿à¤¨à¥à¤¯à¤¾";
              break;
            case "MM":
              output = "%d à¤®à¤¹à¤¿à¤¨à¥à¤¯à¤¾à¤‚";
              break;
            case "y":
              output = "à¤à¤•à¤¾ à¤µà¤°à¥à¤·à¤¾";
              break;
            case "yy":
              output = "%d à¤µà¤°à¥à¤·à¤¾à¤‚";
              break;
          }
        }
        return output.replace(/%d/i, number2);
      }
      hooks.defineLocale("mr", {
        months: "à¤œà¤¾à¤¨à¥‡à¤µà¤¾à¤°à¥€_à¤«à¥‡à¤¬à¥à¤°à¥à¤µà¤¾à¤°à¥€_à¤®à¤¾à¤°à¥à¤š_à¤à¤ªà¥à¤°à¤¿à¤²_à¤®à¥‡_à¤œà¥‚à¤¨_à¤œà¥à¤²à¥ˆ_à¤‘à¤—à¤¸à¥à¤Ÿ_à¤¸à¤ªà¥à¤Ÿà¥‡à¤‚à¤¬à¤°_à¤‘à¤•à¥à¤Ÿà¥‹à¤¬à¤°_à¤¨à¥‹à¤µà¥à¤¹à¥‡à¤‚à¤¬à¤°_à¤¡à¤¿à¤¸à¥‡à¤‚à¤¬à¤°".split(
          "_"
        ),
        monthsShort: "à¤œà¤¾à¤¨à¥‡._à¤«à¥‡à¤¬à¥à¤°à¥._à¤®à¤¾à¤°à¥à¤š._à¤à¤ªà¥à¤°à¤¿._à¤®à¥‡._à¤œà¥‚à¤¨._à¤œà¥à¤²à¥ˆ._à¤‘à¤—._à¤¸à¤ªà¥à¤Ÿà¥‡à¤‚._à¤‘à¤•à¥à¤Ÿà¥‹._à¤¨à¥‹à¤µà¥à¤¹à¥‡à¤‚._à¤¡à¤¿à¤¸à¥‡à¤‚.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "à¤°à¤µà¤¿à¤µà¤¾à¤°_à¤¸à¥‹à¤®à¤µà¤¾à¤°_à¤®à¤‚à¤—à¤³à¤µà¤¾à¤°_à¤¬à¥à¤§à¤µà¤¾à¤°_à¤—à¥à¤°à¥‚à¤µà¤¾à¤°_à¤¶à¥à¤•à¥à¤°à¤µà¤¾à¤°_à¤¶à¤¨à¤¿à¤µà¤¾à¤°".split("_"),
        weekdaysShort: "à¤°à¤µà¤¿_à¤¸à¥‹à¤®_à¤®à¤‚à¤—à¤³_à¤¬à¥à¤§_à¤—à¥à¤°à¥‚_à¤¶à¥à¤•à¥à¤°_à¤¶à¤¨à¤¿".split("_"),
        weekdaysMin: "à¤°_à¤¸à¥‹_à¤®à¤‚_à¤¬à¥_à¤—à¥_à¤¶à¥_à¤¶".split("_"),
        longDateFormat: {
          LT: "A h:mm à¤µà¤¾à¤œà¤¤à¤¾",
          LTS: "A h:mm:ss à¤µà¤¾à¤œà¤¤à¤¾",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY, A h:mm à¤µà¤¾à¤œà¤¤à¤¾",
          LLLL: "dddd, D MMMM YYYY, A h:mm à¤µà¤¾à¤œà¤¤à¤¾"
        },
        calendar: {
          sameDay: "[à¤†à¤œ] LT",
          nextDay: "[à¤‰à¤¦à¥à¤¯à¤¾] LT",
          nextWeek: "dddd, LT",
          lastDay: "[à¤•à¤¾à¤²] LT",
          lastWeek: "[à¤®à¤¾à¤—à¥€à¤²] dddd, LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%sà¤®à¤§à¥à¤¯à¥‡",
          past: "%sà¤ªà¥‚à¤°à¥à¤µà¥€",
          s: relativeTimeMr,
          ss: relativeTimeMr,
          m: relativeTimeMr,
          mm: relativeTimeMr,
          h: relativeTimeMr,
          hh: relativeTimeMr,
          d: relativeTimeMr,
          dd: relativeTimeMr,
          M: relativeTimeMr,
          MM: relativeTimeMr,
          y: relativeTimeMr,
          yy: relativeTimeMr
        },
        preparse: function(string2) {
          return string2.replace(/[à¥§à¥¨à¥©à¥ªà¥«à¥¬à¥­à¥®à¥¯à¥¦]/g, function(match) {
            return numberMap$c[match];
          });
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap$d[match];
          });
        },
        meridiemParse: /à¤ªà¤¹à¤¾à¤Ÿà¥‡|à¤¸à¤•à¤¾à¤³à¥€|à¤¦à¥à¤ªà¤¾à¤°à¥€|à¤¸à¤¾à¤¯à¤‚à¤•à¤¾à¤³à¥€|à¤°à¤¾à¤¤à¥à¤°à¥€/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "à¤ªà¤¹à¤¾à¤Ÿà¥‡" || meridiem2 === "à¤¸à¤•à¤¾à¤³à¥€") {
            return hour;
          } else if (meridiem2 === "à¤¦à¥à¤ªà¤¾à¤°à¥€" || meridiem2 === "à¤¸à¤¾à¤¯à¤‚à¤•à¤¾à¤³à¥€" || meridiem2 === "à¤°à¤¾à¤¤à¥à¤°à¥€") {
            return hour >= 12 ? hour : hour + 12;
          }
        },
        meridiem: function(hour, minute, isLower) {
          if (hour >= 0 && hour < 6) {
            return "à¤ªà¤¹à¤¾à¤Ÿà¥‡";
          } else if (hour < 12) {
            return "à¤¸à¤•à¤¾à¤³à¥€";
          } else if (hour < 17) {
            return "à¤¦à¥à¤ªà¤¾à¤°à¥€";
          } else if (hour < 20) {
            return "à¤¸à¤¾à¤¯à¤‚à¤•à¤¾à¤³à¥€";
          } else {
            return "à¤°à¤¾à¤¤à¥à¤°à¥€";
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("ms-my", {
        months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split(
          "_"
        ),
        monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
        weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
        weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
        weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
        longDateFormat: {
          LT: "HH.mm",
          LTS: "HH.mm.ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY [pukul] HH.mm",
          LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "pagi") {
            return hour;
          } else if (meridiem2 === "tengahari") {
            return hour >= 11 ? hour : hour + 12;
          } else if (meridiem2 === "petang" || meridiem2 === "malam") {
            return hour + 12;
          }
        },
        meridiem: function(hours2, minutes2, isLower) {
          if (hours2 < 11) {
            return "pagi";
          } else if (hours2 < 15) {
            return "tengahari";
          } else if (hours2 < 19) {
            return "petang";
          } else {
            return "malam";
          }
        },
        calendar: {
          sameDay: "[Hari ini pukul] LT",
          nextDay: "[Esok pukul] LT",
          nextWeek: "dddd [pukul] LT",
          lastDay: "[Kelmarin pukul] LT",
          lastWeek: "dddd [lepas pukul] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "dalam %s",
          past: "%s yang lepas",
          s: "beberapa saat",
          ss: "%d saat",
          m: "seminit",
          mm: "%d minit",
          h: "sejam",
          hh: "%d jam",
          d: "sehari",
          dd: "%d hari",
          M: "sebulan",
          MM: "%d bulan",
          y: "setahun",
          yy: "%d tahun"
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("ms", {
        months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split(
          "_"
        ),
        monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
        weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
        weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
        weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
        longDateFormat: {
          LT: "HH.mm",
          LTS: "HH.mm.ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY [pukul] HH.mm",
          LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "pagi") {
            return hour;
          } else if (meridiem2 === "tengahari") {
            return hour >= 11 ? hour : hour + 12;
          } else if (meridiem2 === "petang" || meridiem2 === "malam") {
            return hour + 12;
          }
        },
        meridiem: function(hours2, minutes2, isLower) {
          if (hours2 < 11) {
            return "pagi";
          } else if (hours2 < 15) {
            return "tengahari";
          } else if (hours2 < 19) {
            return "petang";
          } else {
            return "malam";
          }
        },
        calendar: {
          sameDay: "[Hari ini pukul] LT",
          nextDay: "[Esok pukul] LT",
          nextWeek: "dddd [pukul] LT",
          lastDay: "[Kelmarin pukul] LT",
          lastWeek: "dddd [lepas pukul] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "dalam %s",
          past: "%s yang lepas",
          s: "beberapa saat",
          ss: "%d saat",
          m: "seminit",
          mm: "%d minit",
          h: "sejam",
          hh: "%d jam",
          d: "sehari",
          dd: "%d hari",
          M: "sebulan",
          MM: "%d bulan",
          y: "setahun",
          yy: "%d tahun"
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("mt", {
        months: "Jannar_Frar_Marzu_April_Mejju_Ä unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_DiÄ‹embru".split(
          "_"
        ),
        monthsShort: "Jan_Fra_Mar_Apr_Mej_Ä un_Lul_Aww_Set_Ott_Nov_DiÄ‹".split("_"),
        weekdays: "Il-Ä¦add_It-Tnejn_It-Tlieta_L-ErbgÄ§a_Il-Ä¦amis_Il-Ä imgÄ§a_Is-Sibt".split(
          "_"
        ),
        weekdaysShort: "Ä¦ad_Tne_Tli_Erb_Ä¦am_Ä im_Sib".split("_"),
        weekdaysMin: "Ä¦a_Tn_Tl_Er_Ä¦a_Ä i_Si".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Illum fil-]LT",
          nextDay: "[GÄ§ada fil-]LT",
          nextWeek: "dddd [fil-]LT",
          lastDay: "[Il-bieraÄ§ fil-]LT",
          lastWeek: "dddd [li gÄ§adda] [fil-]LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "fâ€™ %s",
          past: "%s ilu",
          s: "ftit sekondi",
          ss: "%d sekondi",
          m: "minuta",
          mm: "%d minuti",
          h: "siegÄ§a",
          hh: "%d siegÄ§at",
          d: "Ä¡urnata",
          dd: "%d Ä¡ranet",
          M: "xahar",
          MM: "%d xhur",
          y: "sena",
          yy: "%d sni"
        },
        dayOfMonthOrdinalParse: /\d{1,2}Âº/,
        ordinal: "%dÂº",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var symbolMap$e = {
        1: "á",
        2: "á‚",
        3: "áƒ",
        4: "á„",
        5: "á…",
        6: "á†",
        7: "á‡",
        8: "áˆ",
        9: "á‰",
        0: "á€"
      }, numberMap$d = {
        "á": "1",
        "á‚": "2",
        "áƒ": "3",
        "á„": "4",
        "á…": "5",
        "á†": "6",
        "á‡": "7",
        "áˆ": "8",
        "á‰": "9",
        "á€": "0"
      };
      hooks.defineLocale("my", {
        months: "á€‡á€”á€ºá€”á€á€«á€›á€®_á€–á€±á€–á€±á€¬á€ºá€á€«á€›á€®_á€™á€á€º_á€§á€•á€¼á€®_á€™á€±_á€‡á€½á€”á€º_á€‡á€°á€œá€­á€¯á€„á€º_á€žá€¼á€‚á€¯á€á€º_á€…á€€á€ºá€á€„á€ºá€˜á€¬_á€¡á€±á€¬á€€á€ºá€á€­á€¯á€˜á€¬_á€”á€­á€¯á€á€„á€ºá€˜á€¬_á€’á€®á€‡á€„á€ºá€˜á€¬".split(
          "_"
        ),
        monthsShort: "á€‡á€”á€º_á€–á€±_á€™á€á€º_á€•á€¼á€®_á€™á€±_á€‡á€½á€”á€º_á€œá€­á€¯á€„á€º_á€žá€¼_á€…á€€á€º_á€¡á€±á€¬á€€á€º_á€”á€­á€¯_á€’á€®".split("_"),
        weekdays: "á€á€”á€„á€ºá€¹á€‚á€”á€½á€±_á€á€”á€„á€ºá€¹á€œá€¬_á€¡á€„á€ºá€¹á€‚á€«_á€—á€¯á€’á€¹á€“á€Ÿá€°á€¸_á€€á€¼á€¬á€žá€•á€á€±á€¸_á€žá€±á€¬á€€á€¼á€¬_á€…á€”á€±".split(
          "_"
        ),
        weekdaysShort: "á€”á€½á€±_á€œá€¬_á€‚á€«_á€Ÿá€°á€¸_á€€á€¼á€¬_á€žá€±á€¬_á€”á€±".split("_"),
        weekdaysMin: "á€”á€½á€±_á€œá€¬_á€‚á€«_á€Ÿá€°á€¸_á€€á€¼á€¬_á€žá€±á€¬_á€”á€±".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[á€šá€”á€±.] LT [á€™á€¾á€¬]",
          nextDay: "[á€™á€”á€€á€ºá€–á€¼á€”á€º] LT [á€™á€¾á€¬]",
          nextWeek: "dddd LT [á€™á€¾á€¬]",
          lastDay: "[á€™á€”á€±.á€€] LT [á€™á€¾á€¬]",
          lastWeek: "[á€•á€¼á€®á€¸á€á€²á€·á€žá€±á€¬] dddd LT [á€™á€¾á€¬]",
          sameElse: "L"
        },
        relativeTime: {
          future: "á€œá€¬á€™á€Šá€ºá€· %s á€™á€¾á€¬",
          past: "á€œá€½á€”á€ºá€á€²á€·á€žá€±á€¬ %s á€€",
          s: "á€…á€€á€¹á€€á€”á€º.á€¡á€”á€Šá€ºá€¸á€„á€šá€º",
          ss: "%d á€…á€€á€¹á€€á€”á€·á€º",
          m: "á€á€…á€ºá€™á€­á€”á€…á€º",
          mm: "%d á€™á€­á€”á€…á€º",
          h: "á€á€…á€ºá€”á€¬á€›á€®",
          hh: "%d á€”á€¬á€›á€®",
          d: "á€á€…á€ºá€›á€€á€º",
          dd: "%d á€›á€€á€º",
          M: "á€á€…á€ºá€œ",
          MM: "%d á€œ",
          y: "á€á€…á€ºá€”á€¾á€…á€º",
          yy: "%d á€”á€¾á€…á€º"
        },
        preparse: function(string2) {
          return string2.replace(/[áá‚áƒá„á…á†á‡áˆá‰á€]/g, function(match) {
            return numberMap$d[match];
          });
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap$e[match];
          });
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("nb", {
        months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split(
          "_"
        ),
        monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
        monthsParseExact: true,
        weekdays: "sÃ¸ndag_mandag_tirsdag_onsdag_torsdag_fredag_lÃ¸rdag".split("_"),
        weekdaysShort: "sÃ¸._ma._ti._on._to._fr._lÃ¸.".split("_"),
        weekdaysMin: "sÃ¸_ma_ti_on_to_fr_lÃ¸".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D. MMMM YYYY",
          LLL: "D. MMMM YYYY [kl.] HH:mm",
          LLLL: "dddd D. MMMM YYYY [kl.] HH:mm"
        },
        calendar: {
          sameDay: "[i dag kl.] LT",
          nextDay: "[i morgen kl.] LT",
          nextWeek: "dddd [kl.] LT",
          lastDay: "[i gÃ¥r kl.] LT",
          lastWeek: "[forrige] dddd [kl.] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "om %s",
          past: "%s siden",
          s: "noen sekunder",
          ss: "%d sekunder",
          m: "ett minutt",
          mm: "%d minutter",
          h: "Ã©n time",
          hh: "%d timer",
          d: "Ã©n dag",
          dd: "%d dager",
          w: "Ã©n uke",
          ww: "%d uker",
          M: "Ã©n mÃ¥ned",
          MM: "%d mÃ¥neder",
          y: "ett Ã¥r",
          yy: "%d Ã¥r"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var symbolMap$f = {
        1: "à¥§",
        2: "à¥¨",
        3: "à¥©",
        4: "à¥ª",
        5: "à¥«",
        6: "à¥¬",
        7: "à¥­",
        8: "à¥®",
        9: "à¥¯",
        0: "à¥¦"
      }, numberMap$e = {
        "à¥§": "1",
        "à¥¨": "2",
        "à¥©": "3",
        "à¥ª": "4",
        "à¥«": "5",
        "à¥¬": "6",
        "à¥­": "7",
        "à¥®": "8",
        "à¥¯": "9",
        "à¥¦": "0"
      };
      hooks.defineLocale("ne", {
        months: "à¤œà¤¨à¤µà¤°à¥€_à¤«à¥‡à¤¬à¥à¤°à¥à¤µà¤°à¥€_à¤®à¤¾à¤°à¥à¤š_à¤…à¤ªà¥à¤°à¤¿à¤²_à¤®à¤ˆ_à¤œà¥à¤¨_à¤œà¥à¤²à¤¾à¤ˆ_à¤…à¤—à¤·à¥à¤Ÿ_à¤¸à¥‡à¤ªà¥à¤Ÿà¥‡à¤®à¥à¤¬à¤°_à¤…à¤•à¥à¤Ÿà¥‹à¤¬à¤°_à¤¨à¥‹à¤­à¥‡à¤®à¥à¤¬à¤°_à¤¡à¤¿à¤¸à¥‡à¤®à¥à¤¬à¤°".split(
          "_"
        ),
        monthsShort: "à¤œà¤¨._à¤«à¥‡à¤¬à¥à¤°à¥._à¤®à¤¾à¤°à¥à¤š_à¤…à¤ªà¥à¤°à¤¿._à¤®à¤ˆ_à¤œà¥à¤¨_à¤œà¥à¤²à¤¾à¤ˆ._à¤…à¤—._à¤¸à¥‡à¤ªà¥à¤Ÿ._à¤…à¤•à¥à¤Ÿà¥‹._à¤¨à¥‹à¤­à¥‡._à¤¡à¤¿à¤¸à¥‡.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "à¤†à¤‡à¤¤à¤¬à¤¾à¤°_à¤¸à¥‹à¤®à¤¬à¤¾à¤°_à¤®à¤™à¥à¤—à¤²à¤¬à¤¾à¤°_à¤¬à¥à¤§à¤¬à¤¾à¤°_à¤¬à¤¿à¤¹à¤¿à¤¬à¤¾à¤°_à¤¶à¥à¤•à¥à¤°à¤¬à¤¾à¤°_à¤¶à¤¨à¤¿à¤¬à¤¾à¤°".split(
          "_"
        ),
        weekdaysShort: "à¤†à¤‡à¤¤._à¤¸à¥‹à¤®._à¤®à¤™à¥à¤—à¤²._à¤¬à¥à¤§._à¤¬à¤¿à¤¹à¤¿._à¤¶à¥à¤•à¥à¤°._à¤¶à¤¨à¤¿.".split("_"),
        weekdaysMin: "à¤†._à¤¸à¥‹._à¤®à¤‚._à¤¬à¥._à¤¬à¤¿._à¤¶à¥._à¤¶.".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "Aà¤•à¥‹ h:mm à¤¬à¤œà¥‡",
          LTS: "Aà¤•à¥‹ h:mm:ss à¤¬à¤œà¥‡",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY, Aà¤•à¥‹ h:mm à¤¬à¤œà¥‡",
          LLLL: "dddd, D MMMM YYYY, Aà¤•à¥‹ h:mm à¤¬à¤œà¥‡"
        },
        preparse: function(string2) {
          return string2.replace(/[à¥§à¥¨à¥©à¥ªà¥«à¥¬à¥­à¥®à¥¯à¥¦]/g, function(match) {
            return numberMap$e[match];
          });
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap$f[match];
          });
        },
        meridiemParse: /à¤°à¤¾à¤¤à¤¿|à¤¬à¤¿à¤¹à¤¾à¤¨|à¤¦à¤¿à¤‰à¤à¤¸à¥‹|à¤¸à¤¾à¤à¤/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "à¤°à¤¾à¤¤à¤¿") {
            return hour < 4 ? hour : hour + 12;
          } else if (meridiem2 === "à¤¬à¤¿à¤¹à¤¾à¤¨") {
            return hour;
          } else if (meridiem2 === "à¤¦à¤¿à¤‰à¤à¤¸à¥‹") {
            return hour >= 10 ? hour : hour + 12;
          } else if (meridiem2 === "à¤¸à¤¾à¤à¤") {
            return hour + 12;
          }
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 3) {
            return "à¤°à¤¾à¤¤à¤¿";
          } else if (hour < 12) {
            return "à¤¬à¤¿à¤¹à¤¾à¤¨";
          } else if (hour < 16) {
            return "à¤¦à¤¿à¤‰à¤à¤¸à¥‹";
          } else if (hour < 20) {
            return "à¤¸à¤¾à¤à¤";
          } else {
            return "à¤°à¤¾à¤¤à¤¿";
          }
        },
        calendar: {
          sameDay: "[à¤†à¤œ] LT",
          nextDay: "[à¤­à¥‹à¤²à¤¿] LT",
          nextWeek: "[à¤†à¤‰à¤à¤¦à¥‹] dddd[,] LT",
          lastDay: "[à¤¹à¤¿à¤œà¥‹] LT",
          lastWeek: "[à¤—à¤à¤•à¥‹] dddd[,] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%sà¤®à¤¾",
          past: "%s à¤…à¤—à¤¾à¤¡à¤¿",
          s: "à¤•à¥‡à¤¹à¥€ à¤•à¥à¤·à¤£",
          ss: "%d à¤¸à¥‡à¤•à¥‡à¤£à¥à¤¡",
          m: "à¤à¤• à¤®à¤¿à¤¨à¥‡à¤Ÿ",
          mm: "%d à¤®à¤¿à¤¨à¥‡à¤Ÿ",
          h: "à¤à¤• à¤˜à¤£à¥à¤Ÿà¤¾",
          hh: "%d à¤˜à¤£à¥à¤Ÿà¤¾",
          d: "à¤à¤• à¤¦à¤¿à¤¨",
          dd: "%d à¤¦à¤¿à¤¨",
          M: "à¤à¤• à¤®à¤¹à¤¿à¤¨à¤¾",
          MM: "%d à¤®à¤¹à¤¿à¤¨à¤¾",
          y: "à¤à¤• à¤¬à¤°à¥à¤·",
          yy: "%d à¤¬à¤°à¥à¤·"
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var monthsShortWithDots$1 = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsShortWithoutDots$1 = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), monthsParse$8 = [
        /^jan/i,
        /^feb/i,
        /^(maart|mrt\.?)$/i,
        /^apr/i,
        /^mei$/i,
        /^jun[i.]?$/i,
        /^jul[i.]?$/i,
        /^aug/i,
        /^sep/i,
        /^okt/i,
        /^nov/i,
        /^dec/i
      ], monthsRegex$8 = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
      hooks.defineLocale("nl-be", {
        months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split(
          "_"
        ),
        monthsShort: function(m2, format2) {
          if (!m2) {
            return monthsShortWithDots$1;
          } else if (/-MMM-/.test(format2)) {
            return monthsShortWithoutDots$1[m2.month()];
          } else {
            return monthsShortWithDots$1[m2.month()];
          }
        },
        monthsRegex: monthsRegex$8,
        monthsShortRegex: monthsRegex$8,
        monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
        monthsParse: monthsParse$8,
        longMonthsParse: monthsParse$8,
        shortMonthsParse: monthsParse$8,
        weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
        weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
        weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[vandaag om] LT",
          nextDay: "[morgen om] LT",
          nextWeek: "dddd [om] LT",
          lastDay: "[gisteren om] LT",
          lastWeek: "[afgelopen] dddd [om] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "over %s",
          past: "%s geleden",
          s: "een paar seconden",
          ss: "%d seconden",
          m: "Ã©Ã©n minuut",
          mm: "%d minuten",
          h: "Ã©Ã©n uur",
          hh: "%d uur",
          d: "Ã©Ã©n dag",
          dd: "%d dagen",
          M: "Ã©Ã©n maand",
          MM: "%d maanden",
          y: "Ã©Ã©n jaar",
          yy: "%d jaar"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function(number2) {
          return number2 + (number2 === 1 || number2 === 8 || number2 >= 20 ? "ste" : "de");
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var monthsShortWithDots$2 = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsShortWithoutDots$2 = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), monthsParse$9 = [
        /^jan/i,
        /^feb/i,
        /^(maart|mrt\.?)$/i,
        /^apr/i,
        /^mei$/i,
        /^jun[i.]?$/i,
        /^jul[i.]?$/i,
        /^aug/i,
        /^sep/i,
        /^okt/i,
        /^nov/i,
        /^dec/i
      ], monthsRegex$9 = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
      hooks.defineLocale("nl", {
        months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split(
          "_"
        ),
        monthsShort: function(m2, format2) {
          if (!m2) {
            return monthsShortWithDots$2;
          } else if (/-MMM-/.test(format2)) {
            return monthsShortWithoutDots$2[m2.month()];
          } else {
            return monthsShortWithDots$2[m2.month()];
          }
        },
        monthsRegex: monthsRegex$9,
        monthsShortRegex: monthsRegex$9,
        monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
        monthsParse: monthsParse$9,
        longMonthsParse: monthsParse$9,
        shortMonthsParse: monthsParse$9,
        weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
        weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
        weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD-MM-YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[vandaag om] LT",
          nextDay: "[morgen om] LT",
          nextWeek: "dddd [om] LT",
          lastDay: "[gisteren om] LT",
          lastWeek: "[afgelopen] dddd [om] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "over %s",
          past: "%s geleden",
          s: "een paar seconden",
          ss: "%d seconden",
          m: "Ã©Ã©n minuut",
          mm: "%d minuten",
          h: "Ã©Ã©n uur",
          hh: "%d uur",
          d: "Ã©Ã©n dag",
          dd: "%d dagen",
          w: "Ã©Ã©n week",
          ww: "%d weken",
          M: "Ã©Ã©n maand",
          MM: "%d maanden",
          y: "Ã©Ã©n jaar",
          yy: "%d jaar"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function(number2) {
          return number2 + (number2 === 1 || number2 === 8 || number2 >= 20 ? "ste" : "de");
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("nn", {
        months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split(
          "_"
        ),
        monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
        monthsParseExact: true,
        weekdays: "sundag_mÃ¥ndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"),
        weekdaysShort: "su._mÃ¥._ty._on._to._fr._lau.".split("_"),
        weekdaysMin: "su_mÃ¥_ty_on_to_fr_la".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D. MMMM YYYY",
          LLL: "D. MMMM YYYY [kl.] H:mm",
          LLLL: "dddd D. MMMM YYYY [kl.] HH:mm"
        },
        calendar: {
          sameDay: "[I dag klokka] LT",
          nextDay: "[I morgon klokka] LT",
          nextWeek: "dddd [klokka] LT",
          lastDay: "[I gÃ¥r klokka] LT",
          lastWeek: "[FÃ¸regÃ¥ande] dddd [klokka] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "om %s",
          past: "%s sidan",
          s: "nokre sekund",
          ss: "%d sekund",
          m: "eit minutt",
          mm: "%d minutt",
          h: "ein time",
          hh: "%d timar",
          d: "ein dag",
          dd: "%d dagar",
          w: "ei veke",
          ww: "%d veker",
          M: "ein mÃ¥nad",
          MM: "%d mÃ¥nader",
          y: "eit Ã¥r",
          yy: "%d Ã¥r"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("oc-lnc", {
        months: {
          standalone: "geniÃ¨r_febriÃ¨r_marÃ§_abril_mai_junh_julhet_agost_setembre_octÃ²bre_novembre_decembre".split(
            "_"
          ),
          format: "de geniÃ¨r_de febriÃ¨r_de marÃ§_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octÃ²bre_de novembre_de decembre".split(
            "_"
          ),
          isFormat: /D[oD]?(\s)+MMMM/
        },
        monthsShort: "gen._febr._marÃ§_abr._mai_junh_julh._ago._set._oct._nov._dec.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "dimenge_diluns_dimars_dimÃ¨cres_dijÃ²us_divendres_dissabte".split(
          "_"
        ),
        weekdaysShort: "dg._dl._dm._dc._dj._dv._ds.".split("_"),
        weekdaysMin: "dg_dl_dm_dc_dj_dv_ds".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM [de] YYYY",
          ll: "D MMM YYYY",
          LLL: "D MMMM [de] YYYY [a] H:mm",
          lll: "D MMM YYYY, H:mm",
          LLLL: "dddd D MMMM [de] YYYY [a] H:mm",
          llll: "ddd D MMM YYYY, H:mm"
        },
        calendar: {
          sameDay: "[uÃ¨i a] LT",
          nextDay: "[deman a] LT",
          nextWeek: "dddd [a] LT",
          lastDay: "[iÃ¨r a] LT",
          lastWeek: "dddd [passat a] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "d'aquÃ­ %s",
          past: "fa %s",
          s: "unas segondas",
          ss: "%d segondas",
          m: "una minuta",
          mm: "%d minutas",
          h: "una ora",
          hh: "%d oras",
          d: "un jorn",
          dd: "%d jorns",
          M: "un mes",
          MM: "%d meses",
          y: "un an",
          yy: "%d ans"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|Ã¨|a)/,
        ordinal: function(number2, period) {
          var output = number2 === 1 ? "r" : number2 === 2 ? "n" : number2 === 3 ? "r" : number2 === 4 ? "t" : "Ã¨";
          if (period === "w" || period === "W") {
            output = "a";
          }
          return number2 + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
        }
      });
      //! moment.js locale configuration
      var symbolMap$g = {
        1: "à©§",
        2: "à©¨",
        3: "à©©",
        4: "à©ª",
        5: "à©«",
        6: "à©¬",
        7: "à©­",
        8: "à©®",
        9: "à©¯",
        0: "à©¦"
      }, numberMap$f = {
        "à©§": "1",
        "à©¨": "2",
        "à©©": "3",
        "à©ª": "4",
        "à©«": "5",
        "à©¬": "6",
        "à©­": "7",
        "à©®": "8",
        "à©¯": "9",
        "à©¦": "0"
      };
      hooks.defineLocale("pa-in", {
        // There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.
        months: "à¨œà¨¨à¨µà¨°à©€_à¨«à¨¼à¨°à¨µà¨°à©€_à¨®à¨¾à¨°à¨š_à¨…à¨ªà©à¨°à©ˆà¨²_à¨®à¨ˆ_à¨œà©‚à¨¨_à¨œà©à¨²à¨¾à¨ˆ_à¨…à¨—à¨¸à¨¤_à¨¸à¨¤à©°à¨¬à¨°_à¨…à¨•à¨¤à©‚à¨¬à¨°_à¨¨à¨µà©°à¨¬à¨°_à¨¦à¨¸à©°à¨¬à¨°".split(
          "_"
        ),
        monthsShort: "à¨œà¨¨à¨µà¨°à©€_à¨«à¨¼à¨°à¨µà¨°à©€_à¨®à¨¾à¨°à¨š_à¨…à¨ªà©à¨°à©ˆà¨²_à¨®à¨ˆ_à¨œà©‚à¨¨_à¨œà©à¨²à¨¾à¨ˆ_à¨…à¨—à¨¸à¨¤_à¨¸à¨¤à©°à¨¬à¨°_à¨…à¨•à¨¤à©‚à¨¬à¨°_à¨¨à¨µà©°à¨¬à¨°_à¨¦à¨¸à©°à¨¬à¨°".split(
          "_"
        ),
        weekdays: "à¨à¨¤à¨µà¨¾à¨°_à¨¸à©‹à¨®à¨µà¨¾à¨°_à¨®à©°à¨—à¨²à¨µà¨¾à¨°_à¨¬à©à¨§à¨µà¨¾à¨°_à¨µà©€à¨°à¨µà¨¾à¨°_à¨¸à¨¼à©à©±à¨•à¨°à¨µà¨¾à¨°_à¨¸à¨¼à¨¨à©€à¨šà¨°à¨µà¨¾à¨°".split(
          "_"
        ),
        weekdaysShort: "à¨à¨¤_à¨¸à©‹à¨®_à¨®à©°à¨—à¨²_à¨¬à©à¨§_à¨µà©€à¨°_à¨¸à¨¼à©à¨•à¨°_à¨¸à¨¼à¨¨à©€".split("_"),
        weekdaysMin: "à¨à¨¤_à¨¸à©‹à¨®_à¨®à©°à¨—à¨²_à¨¬à©à¨§_à¨µà©€à¨°_à¨¸à¨¼à©à¨•à¨°_à¨¸à¨¼à¨¨à©€".split("_"),
        longDateFormat: {
          LT: "A h:mm à¨µà¨œà©‡",
          LTS: "A h:mm:ss à¨µà¨œà©‡",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY, A h:mm à¨µà¨œà©‡",
          LLLL: "dddd, D MMMM YYYY, A h:mm à¨µà¨œà©‡"
        },
        calendar: {
          sameDay: "[à¨…à¨œ] LT",
          nextDay: "[à¨•à¨²] LT",
          nextWeek: "[à¨…à¨—à¨²à¨¾] dddd, LT",
          lastDay: "[à¨•à¨²] LT",
          lastWeek: "[à¨ªà¨¿à¨›à¨²à©‡] dddd, LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s à¨µà¨¿à©±à¨š",
          past: "%s à¨ªà¨¿à¨›à¨²à©‡",
          s: "à¨•à©à¨ à¨¸à¨•à¨¿à©°à¨Ÿ",
          ss: "%d à¨¸à¨•à¨¿à©°à¨Ÿ",
          m: "à¨‡à¨• à¨®à¨¿à©°à¨Ÿ",
          mm: "%d à¨®à¨¿à©°à¨Ÿ",
          h: "à¨‡à©±à¨• à¨˜à©°à¨Ÿà¨¾",
          hh: "%d à¨˜à©°à¨Ÿà©‡",
          d: "à¨‡à©±à¨• à¨¦à¨¿à¨¨",
          dd: "%d à¨¦à¨¿à¨¨",
          M: "à¨‡à©±à¨• à¨®à¨¹à©€à¨¨à¨¾",
          MM: "%d à¨®à¨¹à©€à¨¨à©‡",
          y: "à¨‡à©±à¨• à¨¸à¨¾à¨²",
          yy: "%d à¨¸à¨¾à¨²"
        },
        preparse: function(string2) {
          return string2.replace(/[à©§à©¨à©©à©ªà©«à©¬à©­à©®à©¯à©¦]/g, function(match) {
            return numberMap$f[match];
          });
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap$g[match];
          });
        },
        // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
        meridiemParse: /à¨°à¨¾à¨¤|à¨¸à¨µà©‡à¨°|à¨¦à©à¨ªà¨¹à¨¿à¨°|à¨¸à¨¼à¨¾à¨®/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "à¨°à¨¾à¨¤") {
            return hour < 4 ? hour : hour + 12;
          } else if (meridiem2 === "à¨¸à¨µà©‡à¨°") {
            return hour;
          } else if (meridiem2 === "à¨¦à©à¨ªà¨¹à¨¿à¨°") {
            return hour >= 10 ? hour : hour + 12;
          } else if (meridiem2 === "à¨¸à¨¼à¨¾à¨®") {
            return hour + 12;
          }
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "à¨°à¨¾à¨¤";
          } else if (hour < 10) {
            return "à¨¸à¨µà©‡à¨°";
          } else if (hour < 17) {
            return "à¨¦à©à¨ªà¨¹à¨¿à¨°";
          } else if (hour < 20) {
            return "à¨¸à¨¼à¨¾à¨®";
          } else {
            return "à¨°à¨¾à¨¤";
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var monthsNominative = "styczeÅ„_luty_marzec_kwiecieÅ„_maj_czerwiec_lipiec_sierpieÅ„_wrzesieÅ„_paÅºdziernik_listopad_grudzieÅ„".split(
        "_"
      ), monthsSubjective = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzeÅ›nia_paÅºdziernika_listopada_grudnia".split(
        "_"
      ), monthsParse$a = [
        /^sty/i,
        /^lut/i,
        /^mar/i,
        /^kwi/i,
        /^maj/i,
        /^cze/i,
        /^lip/i,
        /^sie/i,
        /^wrz/i,
        /^paÅº/i,
        /^lis/i,
        /^gru/i
      ];
      function plural$3(n) {
        return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
      }
      function translate$8(number2, withoutSuffix, key) {
        var result = number2 + " ";
        switch (key) {
          case "ss":
            return result + (plural$3(number2) ? "sekundy" : "sekund");
          case "m":
            return withoutSuffix ? "minuta" : "minutÄ™";
          case "mm":
            return result + (plural$3(number2) ? "minuty" : "minut");
          case "h":
            return withoutSuffix ? "godzina" : "godzinÄ™";
          case "hh":
            return result + (plural$3(number2) ? "godziny" : "godzin");
          case "ww":
            return result + (plural$3(number2) ? "tygodnie" : "tygodni");
          case "MM":
            return result + (plural$3(number2) ? "miesiÄ…ce" : "miesiÄ™cy");
          case "yy":
            return result + (plural$3(number2) ? "lata" : "lat");
        }
      }
      hooks.defineLocale("pl", {
        months: function(momentToFormat, format2) {
          if (!momentToFormat) {
            return monthsNominative;
          } else if (/D MMMM/.test(format2)) {
            return monthsSubjective[momentToFormat.month()];
          } else {
            return monthsNominative[momentToFormat.month()];
          }
        },
        monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paÅº_lis_gru".split("_"),
        monthsParse: monthsParse$a,
        longMonthsParse: monthsParse$a,
        shortMonthsParse: monthsParse$a,
        weekdays: "niedziela_poniedziaÅ‚ek_wtorek_Å›roda_czwartek_piÄ…tek_sobota".split("_"),
        weekdaysShort: "ndz_pon_wt_Å›r_czw_pt_sob".split("_"),
        weekdaysMin: "Nd_Pn_Wt_Åšr_Cz_Pt_So".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[DziÅ› o] LT",
          nextDay: "[Jutro o] LT",
          nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[W niedzielÄ™ o] LT";
              case 2:
                return "[We wtorek o] LT";
              case 3:
                return "[W Å›rodÄ™ o] LT";
              case 6:
                return "[W sobotÄ™ o] LT";
              default:
                return "[W] dddd [o] LT";
            }
          },
          lastDay: "[Wczoraj o] LT",
          lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[W zeszÅ‚Ä… niedzielÄ™ o] LT";
              case 3:
                return "[W zeszÅ‚Ä… Å›rodÄ™ o] LT";
              case 6:
                return "[W zeszÅ‚Ä… sobotÄ™ o] LT";
              default:
                return "[W zeszÅ‚y] dddd [o] LT";
            }
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "za %s",
          past: "%s temu",
          s: "kilka sekund",
          ss: translate$8,
          m: translate$8,
          mm: translate$8,
          h: translate$8,
          hh: translate$8,
          d: "1 dzieÅ„",
          dd: "%d dni",
          w: "tydzieÅ„",
          ww: translate$8,
          M: "miesiÄ…c",
          MM: translate$8,
          y: "rok",
          yy: translate$8
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("pt-br", {
        months: "janeiro_fevereiro_marÃ§o_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split(
          "_"
        ),
        monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
        weekdays: "domingo_segunda-feira_terÃ§a-feira_quarta-feira_quinta-feira_sexta-feira_sÃ¡bado".split(
          "_"
        ),
        weekdaysShort: "dom_seg_ter_qua_qui_sex_sÃ¡b".split("_"),
        weekdaysMin: "do_2Âª_3Âª_4Âª_5Âª_6Âª_sÃ¡".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D [de] MMMM [de] YYYY",
          LLL: "D [de] MMMM [de] YYYY [Ã s] HH:mm",
          LLLL: "dddd, D [de] MMMM [de] YYYY [Ã s] HH:mm"
        },
        calendar: {
          sameDay: "[Hoje Ã s] LT",
          nextDay: "[AmanhÃ£ Ã s] LT",
          nextWeek: "dddd [Ã s] LT",
          lastDay: "[Ontem Ã s] LT",
          lastWeek: function() {
            return this.day() === 0 || this.day() === 6 ? "[Ãšltimo] dddd [Ã s] LT" : "[Ãšltima] dddd [Ã s] LT";
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "em %s",
          past: "hÃ¡ %s",
          s: "poucos segundos",
          ss: "%d segundos",
          m: "um minuto",
          mm: "%d minutos",
          h: "uma hora",
          hh: "%d horas",
          d: "um dia",
          dd: "%d dias",
          M: "um mÃªs",
          MM: "%d meses",
          y: "um ano",
          yy: "%d anos"
        },
        dayOfMonthOrdinalParse: /\d{1,2}Âº/,
        ordinal: "%dÂº",
        invalidDate: "Data invÃ¡lida"
      });
      //! moment.js locale configuration
      hooks.defineLocale("pt", {
        months: "janeiro_fevereiro_marÃ§o_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split(
          "_"
        ),
        monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
        weekdays: "Domingo_Segunda-feira_TerÃ§a-feira_Quarta-feira_Quinta-feira_Sexta-feira_SÃ¡bado".split(
          "_"
        ),
        weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_SÃ¡b".split("_"),
        weekdaysMin: "Do_2Âª_3Âª_4Âª_5Âª_6Âª_SÃ¡".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D [de] MMMM [de] YYYY",
          LLL: "D [de] MMMM [de] YYYY HH:mm",
          LLLL: "dddd, D [de] MMMM [de] YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Hoje Ã s] LT",
          nextDay: "[AmanhÃ£ Ã s] LT",
          nextWeek: "dddd [Ã s] LT",
          lastDay: "[Ontem Ã s] LT",
          lastWeek: function() {
            return this.day() === 0 || this.day() === 6 ? "[Ãšltimo] dddd [Ã s] LT" : "[Ãšltima] dddd [Ã s] LT";
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "em %s",
          past: "hÃ¡ %s",
          s: "segundos",
          ss: "%d segundos",
          m: "um minuto",
          mm: "%d minutos",
          h: "uma hora",
          hh: "%d horas",
          d: "um dia",
          dd: "%d dias",
          w: "uma semana",
          ww: "%d semanas",
          M: "um mÃªs",
          MM: "%d meses",
          y: "um ano",
          yy: "%d anos"
        },
        dayOfMonthOrdinalParse: /\d{1,2}Âº/,
        ordinal: "%dÂº",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      function relativeTimeWithPlural$2(number2, withoutSuffix, key) {
        var format2 = {
          ss: "secunde",
          mm: "minute",
          hh: "ore",
          dd: "zile",
          ww: "sÄƒptÄƒmÃ¢ni",
          MM: "luni",
          yy: "ani"
        }, separator = " ";
        if (number2 % 100 >= 20 || number2 >= 100 && number2 % 100 === 0) {
          separator = " de ";
        }
        return number2 + separator + format2[key];
      }
      hooks.defineLocale("ro", {
        months: "ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split(
          "_"
        ),
        monthsShort: "ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "duminicÄƒ_luni_marÈ›i_miercuri_joi_vineri_sÃ¢mbÄƒtÄƒ".split("_"),
        weekdaysShort: "Dum_Lun_Mar_Mie_Joi_Vin_SÃ¢m".split("_"),
        weekdaysMin: "Du_Lu_Ma_Mi_Jo_Vi_SÃ¢".split("_"),
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY H:mm",
          LLLL: "dddd, D MMMM YYYY H:mm"
        },
        calendar: {
          sameDay: "[azi la] LT",
          nextDay: "[mÃ¢ine la] LT",
          nextWeek: "dddd [la] LT",
          lastDay: "[ieri la] LT",
          lastWeek: "[fosta] dddd [la] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "peste %s",
          past: "%s Ã®n urmÄƒ",
          s: "cÃ¢teva secunde",
          ss: relativeTimeWithPlural$2,
          m: "un minut",
          mm: relativeTimeWithPlural$2,
          h: "o orÄƒ",
          hh: relativeTimeWithPlural$2,
          d: "o zi",
          dd: relativeTimeWithPlural$2,
          w: "o sÄƒptÄƒmÃ¢nÄƒ",
          ww: relativeTimeWithPlural$2,
          M: "o lunÄƒ",
          MM: relativeTimeWithPlural$2,
          y: "un an",
          yy: relativeTimeWithPlural$2
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      function plural$4(word, num) {
        var forms2 = word.split("_");
        return num % 10 === 1 && num % 100 !== 11 ? forms2[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms2[1] : forms2[2];
      }
      function relativeTimeWithPlural$3(number2, withoutSuffix, key) {
        var format2 = {
          ss: withoutSuffix ? "ÑÐµÐºÑƒÐ½Ð´Ð°_ÑÐµÐºÑƒÐ½Ð´Ñ‹_ÑÐµÐºÑƒÐ½Ð´" : "ÑÐµÐºÑƒÐ½Ð´Ñƒ_ÑÐµÐºÑƒÐ½Ð´Ñ‹_ÑÐµÐºÑƒÐ½Ð´",
          mm: withoutSuffix ? "Ð¼Ð¸Ð½ÑƒÑ‚Ð°_Ð¼Ð¸Ð½ÑƒÑ‚Ñ‹_Ð¼Ð¸Ð½ÑƒÑ‚" : "Ð¼Ð¸Ð½ÑƒÑ‚Ñƒ_Ð¼Ð¸Ð½ÑƒÑ‚Ñ‹_Ð¼Ð¸Ð½ÑƒÑ‚",
          hh: "Ñ‡Ð°Ñ_Ñ‡Ð°ÑÐ°_Ñ‡Ð°ÑÐ¾Ð²",
          dd: "Ð´ÐµÐ½ÑŒ_Ð´Ð½Ñ_Ð´Ð½ÐµÐ¹",
          ww: "Ð½ÐµÐ´ÐµÐ»Ñ_Ð½ÐµÐ´ÐµÐ»Ð¸_Ð½ÐµÐ´ÐµÐ»ÑŒ",
          MM: "Ð¼ÐµÑÑÑ†_Ð¼ÐµÑÑÑ†Ð°_Ð¼ÐµÑÑÑ†ÐµÐ²",
          yy: "Ð³Ð¾Ð´_Ð³Ð¾Ð´Ð°_Ð»ÐµÑ‚"
        };
        if (key === "m") {
          return withoutSuffix ? "Ð¼Ð¸Ð½ÑƒÑ‚Ð°" : "Ð¼Ð¸Ð½ÑƒÑ‚Ñƒ";
        } else {
          return number2 + " " + plural$4(format2[key], +number2);
        }
      }
      var monthsParse$b = [
        /^ÑÐ½Ð²/i,
        /^Ñ„ÐµÐ²/i,
        /^Ð¼Ð°Ñ€/i,
        /^Ð°Ð¿Ñ€/i,
        /^Ð¼Ð°[Ð¹Ñ]/i,
        /^Ð¸ÑŽÐ½/i,
        /^Ð¸ÑŽÐ»/i,
        /^Ð°Ð²Ð³/i,
        /^ÑÐµÐ½/i,
        /^Ð¾ÐºÑ‚/i,
        /^Ð½Ð¾Ñ/i,
        /^Ð´ÐµÐº/i
      ];
      hooks.defineLocale("ru", {
        months: {
          format: "ÑÐ½Ð²Ð°Ñ€Ñ_Ñ„ÐµÐ²Ñ€Ð°Ð»Ñ_Ð¼Ð°Ñ€Ñ‚Ð°_Ð°Ð¿Ñ€ÐµÐ»Ñ_Ð¼Ð°Ñ_Ð¸ÑŽÐ½Ñ_Ð¸ÑŽÐ»Ñ_Ð°Ð²Ð³ÑƒÑÑ‚Ð°_ÑÐµÐ½Ñ‚ÑÐ±Ñ€Ñ_Ð¾ÐºÑ‚ÑÐ±Ñ€Ñ_Ð½Ð¾ÑÐ±Ñ€Ñ_Ð´ÐµÐºÐ°Ð±Ñ€Ñ".split(
            "_"
          ),
          standalone: "ÑÐ½Ð²Ð°Ñ€ÑŒ_Ñ„ÐµÐ²Ñ€Ð°Ð»ÑŒ_Ð¼Ð°Ñ€Ñ‚_Ð°Ð¿Ñ€ÐµÐ»ÑŒ_Ð¼Ð°Ð¹_Ð¸ÑŽÐ½ÑŒ_Ð¸ÑŽÐ»ÑŒ_Ð°Ð²Ð³ÑƒÑÑ‚_ÑÐµÐ½Ñ‚ÑÐ±Ñ€ÑŒ_Ð¾ÐºÑ‚ÑÐ±Ñ€ÑŒ_Ð½Ð¾ÑÐ±Ñ€ÑŒ_Ð´ÐµÐºÐ°Ð±Ñ€ÑŒ".split(
            "_"
          )
        },
        monthsShort: {
          // Ð¿Ð¾ CLDR Ð¸Ð¼ÐµÐ½Ð½Ð¾ "Ð¸ÑŽÐ»." Ð¸ "Ð¸ÑŽÐ½.", Ð½Ð¾ ÐºÐ°ÐºÐ¾Ð¹ ÑÐ¼Ñ‹ÑÐ» Ð¼ÐµÐ½ÑÑ‚ÑŒ Ð±ÑƒÐºÐ²Ñƒ Ð½Ð° Ñ‚Ð¾Ñ‡ÐºÑƒ?
          format: "ÑÐ½Ð²._Ñ„ÐµÐ²Ñ€._Ð¼Ð°Ñ€._Ð°Ð¿Ñ€._Ð¼Ð°Ñ_Ð¸ÑŽÐ½Ñ_Ð¸ÑŽÐ»Ñ_Ð°Ð²Ð³._ÑÐµÐ½Ñ‚._Ð¾ÐºÑ‚._Ð½Ð¾ÑÐ±._Ð´ÐµÐº.".split(
            "_"
          ),
          standalone: "ÑÐ½Ð²._Ñ„ÐµÐ²Ñ€._Ð¼Ð°Ñ€Ñ‚_Ð°Ð¿Ñ€._Ð¼Ð°Ð¹_Ð¸ÑŽÐ½ÑŒ_Ð¸ÑŽÐ»ÑŒ_Ð°Ð²Ð³._ÑÐµÐ½Ñ‚._Ð¾ÐºÑ‚._Ð½Ð¾ÑÐ±._Ð´ÐµÐº.".split(
            "_"
          )
        },
        weekdays: {
          standalone: "Ð²Ð¾ÑÐºÑ€ÐµÑÐµÐ½ÑŒÐµ_Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»ÑŒÐ½Ð¸Ðº_Ð²Ñ‚Ð¾Ñ€Ð½Ð¸Ðº_ÑÑ€ÐµÐ´Ð°_Ñ‡ÐµÑ‚Ð²ÐµÑ€Ð³_Ð¿ÑÑ‚Ð½Ð¸Ñ†Ð°_ÑÑƒÐ±Ð±Ð¾Ñ‚Ð°".split(
            "_"
          ),
          format: "Ð²Ð¾ÑÐºÑ€ÐµÑÐµÐ½ÑŒÐµ_Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»ÑŒÐ½Ð¸Ðº_Ð²Ñ‚Ð¾Ñ€Ð½Ð¸Ðº_ÑÑ€ÐµÐ´Ñƒ_Ñ‡ÐµÑ‚Ð²ÐµÑ€Ð³_Ð¿ÑÑ‚Ð½Ð¸Ñ†Ñƒ_ÑÑƒÐ±Ð±Ð¾Ñ‚Ñƒ".split(
            "_"
          ),
          isFormat: /\[ ?[Ð’Ð²] ?(?:Ð¿Ñ€Ð¾ÑˆÐ»ÑƒÑŽ|ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÑƒÑŽ|ÑÑ‚Ñƒ)? ?] ?dddd/
        },
        weekdaysShort: "Ð²Ñ_Ð¿Ð½_Ð²Ñ‚_ÑÑ€_Ñ‡Ñ‚_Ð¿Ñ‚_ÑÐ±".split("_"),
        weekdaysMin: "Ð²Ñ_Ð¿Ð½_Ð²Ñ‚_ÑÑ€_Ñ‡Ñ‚_Ð¿Ñ‚_ÑÐ±".split("_"),
        monthsParse: monthsParse$b,
        longMonthsParse: monthsParse$b,
        shortMonthsParse: monthsParse$b,
        // Ð¿Ð¾Ð»Ð½Ñ‹Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ Ñ Ð¿Ð°Ð´ÐµÐ¶Ð°Ð¼Ð¸, Ð¿Ð¾ Ñ‚Ñ€Ð¸ Ð±ÑƒÐºÐ²Ñ‹, Ð´Ð»Ñ Ð½ÐµÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ñ…, Ð¿Ð¾ 4 Ð±ÑƒÐºÐ²Ñ‹, ÑÐ¾ÐºÑ€Ð°Ñ‰ÐµÐ½Ð¸Ñ Ñ Ñ‚Ð¾Ñ‡ÐºÐ¾Ð¹ Ð¸ Ð±ÐµÐ· Ñ‚Ð¾Ñ‡ÐºÐ¸
        monthsRegex: /^(ÑÐ½Ð²Ð°Ñ€[ÑŒÑ]|ÑÐ½Ð²\.?|Ñ„ÐµÐ²Ñ€Ð°Ð»[ÑŒÑ]|Ñ„ÐµÐ²Ñ€?\.?|Ð¼Ð°Ñ€Ñ‚Ð°?|Ð¼Ð°Ñ€\.?|Ð°Ð¿Ñ€ÐµÐ»[ÑŒÑ]|Ð°Ð¿Ñ€\.?|Ð¼Ð°[Ð¹Ñ]|Ð¸ÑŽÐ½[ÑŒÑ]|Ð¸ÑŽÐ½\.?|Ð¸ÑŽÐ»[ÑŒÑ]|Ð¸ÑŽÐ»\.?|Ð°Ð²Ð³ÑƒÑÑ‚Ð°?|Ð°Ð²Ð³\.?|ÑÐµÐ½Ñ‚ÑÐ±Ñ€[ÑŒÑ]|ÑÐµÐ½Ñ‚?\.?|Ð¾ÐºÑ‚ÑÐ±Ñ€[ÑŒÑ]|Ð¾ÐºÑ‚\.?|Ð½Ð¾ÑÐ±Ñ€[ÑŒÑ]|Ð½Ð¾ÑÐ±?\.?|Ð´ÐµÐºÐ°Ð±Ñ€[ÑŒÑ]|Ð´ÐµÐº\.?)/i,
        // ÐºÐ¾Ð¿Ð¸Ñ Ð¿Ñ€ÐµÐ´Ñ‹Ð´ÑƒÑ‰ÐµÐ³Ð¾
        monthsShortRegex: /^(ÑÐ½Ð²Ð°Ñ€[ÑŒÑ]|ÑÐ½Ð²\.?|Ñ„ÐµÐ²Ñ€Ð°Ð»[ÑŒÑ]|Ñ„ÐµÐ²Ñ€?\.?|Ð¼Ð°Ñ€Ñ‚Ð°?|Ð¼Ð°Ñ€\.?|Ð°Ð¿Ñ€ÐµÐ»[ÑŒÑ]|Ð°Ð¿Ñ€\.?|Ð¼Ð°[Ð¹Ñ]|Ð¸ÑŽÐ½[ÑŒÑ]|Ð¸ÑŽÐ½\.?|Ð¸ÑŽÐ»[ÑŒÑ]|Ð¸ÑŽÐ»\.?|Ð°Ð²Ð³ÑƒÑÑ‚Ð°?|Ð°Ð²Ð³\.?|ÑÐµÐ½Ñ‚ÑÐ±Ñ€[ÑŒÑ]|ÑÐµÐ½Ñ‚?\.?|Ð¾ÐºÑ‚ÑÐ±Ñ€[ÑŒÑ]|Ð¾ÐºÑ‚\.?|Ð½Ð¾ÑÐ±Ñ€[ÑŒÑ]|Ð½Ð¾ÑÐ±?\.?|Ð´ÐµÐºÐ°Ð±Ñ€[ÑŒÑ]|Ð´ÐµÐº\.?)/i,
        // Ð¿Ð¾Ð»Ð½Ñ‹Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ Ñ Ð¿Ð°Ð´ÐµÐ¶Ð°Ð¼Ð¸
        monthsStrictRegex: /^(ÑÐ½Ð²Ð°Ñ€[ÑÑŒ]|Ñ„ÐµÐ²Ñ€Ð°Ð»[ÑÑŒ]|Ð¼Ð°Ñ€Ñ‚Ð°?|Ð°Ð¿Ñ€ÐµÐ»[ÑÑŒ]|Ð¼Ð°[ÑÐ¹]|Ð¸ÑŽÐ½[ÑÑŒ]|Ð¸ÑŽÐ»[ÑÑŒ]|Ð°Ð²Ð³ÑƒÑÑ‚Ð°?|ÑÐµÐ½Ñ‚ÑÐ±Ñ€[ÑÑŒ]|Ð¾ÐºÑ‚ÑÐ±Ñ€[ÑÑŒ]|Ð½Ð¾ÑÐ±Ñ€[ÑÑŒ]|Ð´ÐµÐºÐ°Ð±Ñ€[ÑÑŒ])/i,
        // Ð’Ñ‹Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ, ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ðµ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ ÑÐ¾ÐºÑ€Ð°Ñ‰Ñ‘Ð½Ð½Ñ‹Ð¼ Ñ„Ð¾Ñ€Ð¼Ð°Ð¼
        monthsShortStrictRegex: /^(ÑÐ½Ð²\.|Ñ„ÐµÐ²Ñ€?\.|Ð¼Ð°Ñ€[Ñ‚.]|Ð°Ð¿Ñ€\.|Ð¼Ð°[ÑÐ¹]|Ð¸ÑŽÐ½[ÑŒÑ.]|Ð¸ÑŽÐ»[ÑŒÑ.]|Ð°Ð²Ð³\.|ÑÐµÐ½Ñ‚?\.|Ð¾ÐºÑ‚\.|Ð½Ð¾ÑÐ±?\.|Ð´ÐµÐº\.)/i,
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY Ð³.",
          LLL: "D MMMM YYYY Ð³., H:mm",
          LLLL: "dddd, D MMMM YYYY Ð³., H:mm"
        },
        calendar: {
          sameDay: "[Ð¡ÐµÐ³Ð¾Ð´Ð½Ñ, Ð²] LT",
          nextDay: "[Ð—Ð°Ð²Ñ‚Ñ€Ð°, Ð²] LT",
          lastDay: "[Ð’Ñ‡ÐµÑ€Ð°, Ð²] LT",
          nextWeek: function(now2) {
            if (now2.week() !== this.week()) {
              switch (this.day()) {
                case 0:
                  return "[Ð’ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐµ] dddd, [Ð²] LT";
                case 1:
                case 2:
                case 4:
                  return "[Ð’ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ð¹] dddd, [Ð²] LT";
                case 3:
                case 5:
                case 6:
                  return "[Ð’ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÑƒÑŽ] dddd, [Ð²] LT";
              }
            } else {
              if (this.day() === 2) {
                return "[Ð’Ð¾] dddd, [Ð²] LT";
              } else {
                return "[Ð’] dddd, [Ð²] LT";
              }
            }
          },
          lastWeek: function(now2) {
            if (now2.week() !== this.week()) {
              switch (this.day()) {
                case 0:
                  return "[Ð’ Ð¿Ñ€Ð¾ÑˆÐ»Ð¾Ðµ] dddd, [Ð²] LT";
                case 1:
                case 2:
                case 4:
                  return "[Ð’ Ð¿Ñ€Ð¾ÑˆÐ»Ñ‹Ð¹] dddd, [Ð²] LT";
                case 3:
                case 5:
                case 6:
                  return "[Ð’ Ð¿Ñ€Ð¾ÑˆÐ»ÑƒÑŽ] dddd, [Ð²] LT";
              }
            } else {
              if (this.day() === 2) {
                return "[Ð’Ð¾] dddd, [Ð²] LT";
              } else {
                return "[Ð’] dddd, [Ð²] LT";
              }
            }
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "Ñ‡ÐµÑ€ÐµÐ· %s",
          past: "%s Ð½Ð°Ð·Ð°Ð´",
          s: "Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ ÑÐµÐºÑƒÐ½Ð´",
          ss: relativeTimeWithPlural$3,
          m: relativeTimeWithPlural$3,
          mm: relativeTimeWithPlural$3,
          h: "Ñ‡Ð°Ñ",
          hh: relativeTimeWithPlural$3,
          d: "Ð´ÐµÐ½ÑŒ",
          dd: relativeTimeWithPlural$3,
          w: "Ð½ÐµÐ´ÐµÐ»Ñ",
          ww: relativeTimeWithPlural$3,
          M: "Ð¼ÐµÑÑÑ†",
          MM: relativeTimeWithPlural$3,
          y: "Ð³Ð¾Ð´",
          yy: relativeTimeWithPlural$3
        },
        meridiemParse: /Ð½Ð¾Ñ‡Ð¸|ÑƒÑ‚Ñ€Ð°|Ð´Ð½Ñ|Ð²ÐµÑ‡ÐµÑ€Ð°/i,
        isPM: function(input) {
          return /^(Ð´Ð½Ñ|Ð²ÐµÑ‡ÐµÑ€Ð°)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "Ð½Ð¾Ñ‡Ð¸";
          } else if (hour < 12) {
            return "ÑƒÑ‚Ñ€Ð°";
          } else if (hour < 17) {
            return "Ð´Ð½Ñ";
          } else {
            return "Ð²ÐµÑ‡ÐµÑ€Ð°";
          }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(Ð¹|Ð³Ð¾|Ñ)/,
        ordinal: function(number2, period) {
          switch (period) {
            case "M":
            case "d":
            case "DDD":
              return number2 + "-Ð¹";
            case "D":
              return number2 + "-Ð³Ð¾";
            case "w":
            case "W":
              return number2 + "-Ñ";
            default:
              return number2;
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var months$9 = [
        "Ø¬Ù†ÙˆØ±ÙŠ",
        "ÙÙŠØ¨Ø±ÙˆØ±ÙŠ",
        "Ù…Ø§Ø±Ú†",
        "Ø§Ù¾Ø±ÙŠÙ„",
        "Ù…Ø¦ÙŠ",
        "Ø¬ÙˆÙ†",
        "Ø¬ÙˆÙ„Ø§Ø¡Ù",
        "Ø¢Ú¯Ø³Ù½",
        "Ø³ÙŠÙ¾Ù½Ù…Ø¨Ø±",
        "Ø¢ÚªÙ½ÙˆØ¨Ø±",
        "Ù†ÙˆÙ…Ø¨Ø±",
        "ÚŠØ³Ù…Ø¨Ø±"
      ], days$1 = ["Ø¢Ú†Ø±", "Ø³ÙˆÙ…Ø±", "Ø§Ú±Ø§Ø±Ùˆ", "Ø§Ø±Ø¨Ø¹", "Ø®Ù…ÙŠØ³", "Ø¬Ù…Ø¹", "Ú‡Ù†Ú‡Ø±"];
      hooks.defineLocale("sd", {
        months: months$9,
        monthsShort: months$9,
        weekdays: days$1,
        weekdaysShort: days$1,
        weekdaysMin: days$1,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "ddddØŒ D MMMM YYYY HH:mm"
        },
        meridiemParse: /ØµØ¨Ø­|Ø´Ø§Ù…/,
        isPM: function(input) {
          return "Ø´Ø§Ù…" === input;
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 12) {
            return "ØµØ¨Ø­";
          }
          return "Ø´Ø§Ù…";
        },
        calendar: {
          sameDay: "[Ø§Ú„] LT",
          nextDay: "[Ø³Ú€Ø§Ú»ÙŠ] LT",
          nextWeek: "dddd [Ø§Ú³ÙŠÙ† Ù‡ÙØªÙŠ ØªÙŠ] LT",
          lastDay: "[ÚªØ§Ù„Ù‡Ù‡] LT",
          lastWeek: "[Ú¯Ø²Ø±ÙŠÙ„ Ù‡ÙØªÙŠ] dddd [ØªÙŠ] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s Ù¾ÙˆØ¡",
          past: "%s Ø§Ú³",
          s: "Ú†Ù†Ø¯ Ø³ÙŠÚªÙ†ÚŠ",
          ss: "%d Ø³ÙŠÚªÙ†ÚŠ",
          m: "Ù‡Úª Ù…Ù†Ù½",
          mm: "%d Ù…Ù†Ù½",
          h: "Ù‡Úª ÚªÙ„Ø§Úª",
          hh: "%d ÚªÙ„Ø§Úª",
          d: "Ù‡Úª ÚÙŠÙ†Ù‡Ù†",
          dd: "%d ÚÙŠÙ†Ù‡Ù†",
          M: "Ù‡Úª Ù…Ù‡ÙŠÙ†Ùˆ",
          MM: "%d Ù…Ù‡ÙŠÙ†Ø§",
          y: "Ù‡Úª Ø³Ø§Ù„",
          yy: "%d Ø³Ø§Ù„"
        },
        preparse: function(string2) {
          return string2.replace(/ØŒ/g, ",");
        },
        postformat: function(string2) {
          return string2.replace(/,/g, "ØŒ");
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("se", {
        months: "oÄ‘Ä‘ajagemÃ¡nnu_guovvamÃ¡nnu_njukÄamÃ¡nnu_cuoÅ‹omÃ¡nnu_miessemÃ¡nnu_geassemÃ¡nnu_suoidnemÃ¡nnu_borgemÃ¡nnu_ÄakÄamÃ¡nnu_golggotmÃ¡nnu_skÃ¡bmamÃ¡nnu_juovlamÃ¡nnu".split(
          "_"
        ),
        monthsShort: "oÄ‘Ä‘j_guov_njuk_cuo_mies_geas_suoi_borg_ÄakÄ_golg_skÃ¡b_juov".split("_"),
        weekdays: "sotnabeaivi_vuossÃ¡rga_maÅ‹Å‹ebÃ¡rga_gaskavahkku_duorastat_bearjadat_lÃ¡vvardat".split(
          "_"
        ),
        weekdaysShort: "sotn_vuos_maÅ‹_gask_duor_bear_lÃ¡v".split("_"),
        weekdaysMin: "s_v_m_g_d_b_L".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "MMMM D. [b.] YYYY",
          LLL: "MMMM D. [b.] YYYY [ti.] HH:mm",
          LLLL: "dddd, MMMM D. [b.] YYYY [ti.] HH:mm"
        },
        calendar: {
          sameDay: "[otne ti] LT",
          nextDay: "[ihttin ti] LT",
          nextWeek: "dddd [ti] LT",
          lastDay: "[ikte ti] LT",
          lastWeek: "[ovddit] dddd [ti] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s geaÅ¾es",
          past: "maÅ‹it %s",
          s: "moadde sekunddat",
          ss: "%d sekunddat",
          m: "okta minuhta",
          mm: "%d minuhtat",
          h: "okta diimmu",
          hh: "%d diimmut",
          d: "okta beaivi",
          dd: "%d beaivvit",
          M: "okta mÃ¡nnu",
          MM: "%d mÃ¡nut",
          y: "okta jahki",
          yy: "%d jagit"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("si", {
        months: "à¶¢à¶±à·€à·à¶»à·’_à¶´à·™à¶¶à¶»à·€à·à¶»à·’_à¶¸à·à¶»à·Šà¶­à·”_à¶…à¶´à·Šâ€à¶»à·šà¶½à·Š_à¶¸à·à¶ºà·’_à¶¢à·–à¶±à·’_à¶¢à·–à¶½à·’_à¶…à¶œà·à·ƒà·Šà¶­à·”_à·ƒà·à¶´à·Šà¶­à·à¶¸à·Šà¶¶à¶»à·Š_à¶”à¶šà·Šà¶­à·à¶¶à¶»à·Š_à¶±à·œà·€à·à¶¸à·Šà¶¶à¶»à·Š_à¶¯à·™à·ƒà·à¶¸à·Šà¶¶à¶»à·Š".split(
          "_"
        ),
        monthsShort: "à¶¢à¶±_à¶´à·™à¶¶_à¶¸à·à¶»à·Š_à¶…à¶´à·Š_à¶¸à·à¶ºà·’_à¶¢à·–à¶±à·’_à¶¢à·–à¶½à·’_à¶…à¶œà·_à·ƒà·à¶´à·Š_à¶”à¶šà·Š_à¶±à·œà·€à·_à¶¯à·™à·ƒà·".split(
          "_"
        ),
        weekdays: "à¶‰à¶»à·’à¶¯à·_à·ƒà¶³à·”à¶¯à·_à¶…à¶Ÿà·„à¶»à·”à·€à·à¶¯à·_à¶¶à¶¯à·à¶¯à·_à¶¶à·Šâ€à¶»à·„à·ƒà·Šà¶´à¶­à·’à¶±à·Šà¶¯à·_à·ƒà·’à¶šà·”à¶»à·à¶¯à·_à·ƒà·™à¶±à·ƒà·”à¶»à·à¶¯à·".split(
          "_"
        ),
        weekdaysShort: "à¶‰à¶»à·’_à·ƒà¶³à·”_à¶…à¶Ÿ_à¶¶à¶¯à·_à¶¶à·Šâ€à¶»à·„_à·ƒà·’à¶šà·”_à·ƒà·™à¶±".split("_"),
        weekdaysMin: "à¶‰_à·ƒ_à¶…_à¶¶_à¶¶à·Šâ€à¶»_à·ƒà·’_à·ƒà·™".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "a h:mm",
          LTS: "a h:mm:ss",
          L: "YYYY/MM/DD",
          LL: "YYYY MMMM D",
          LLL: "YYYY MMMM D, a h:mm",
          LLLL: "YYYY MMMM D [à·€à·à¶±à·’] dddd, a h:mm:ss"
        },
        calendar: {
          sameDay: "[à¶…à¶¯] LT[à¶§]",
          nextDay: "[à·„à·™à¶§] LT[à¶§]",
          nextWeek: "dddd LT[à¶§]",
          lastDay: "[à¶Šà¶ºà·š] LT[à¶§]",
          lastWeek: "[à¶´à·ƒà·”à¶œà·’à¶º] dddd LT[à¶§]",
          sameElse: "L"
        },
        relativeTime: {
          future: "%sà¶šà·’à¶±à·Š",
          past: "%sà¶šà¶§ à¶´à·™à¶»",
          s: "à¶­à¶­à·Šà¶´à¶» à¶šà·’à·„à·’à¶´à¶º",
          ss: "à¶­à¶­à·Šà¶´à¶» %d",
          m: "à¶¸à·’à¶±à·’à¶­à·Šà¶­à·”à·€",
          mm: "à¶¸à·’à¶±à·’à¶­à·Šà¶­à·” %d",
          h: "à¶´à·à¶º",
          hh: "à¶´à·à¶º %d",
          d: "à¶¯à·’à¶±à¶º",
          dd: "à¶¯à·’à¶± %d",
          M: "à¶¸à·à·ƒà¶º",
          MM: "à¶¸à·à·ƒ %d",
          y: "à·€à·ƒà¶»",
          yy: "à·€à·ƒà¶» %d"
        },
        dayOfMonthOrdinalParse: /\d{1,2} à·€à·à¶±à·’/,
        ordinal: function(number2) {
          return number2 + " à·€à·à¶±à·’";
        },
        meridiemParse: /à¶´à·™à¶» à·€à¶»à·”|à¶´à·ƒà·Š à·€à¶»à·”|à¶´à·™.à·€|à¶´.à·€./,
        isPM: function(input) {
          return input === "à¶´.à·€." || input === "à¶´à·ƒà·Š à·€à¶»à·”";
        },
        meridiem: function(hours2, minutes2, isLower) {
          if (hours2 > 11) {
            return isLower ? "à¶´.à·€." : "à¶´à·ƒà·Š à·€à¶»à·”";
          } else {
            return isLower ? "à¶´à·™.à·€." : "à¶´à·™à¶» à·€à¶»à·”";
          }
        }
      });
      //! moment.js locale configuration
      var months$a = "januÃ¡r_februÃ¡r_marec_aprÃ­l_mÃ¡j_jÃºn_jÃºl_august_september_oktÃ³ber_november_december".split(
        "_"
      ), monthsShort$7 = "jan_feb_mar_apr_mÃ¡j_jÃºn_jÃºl_aug_sep_okt_nov_dec".split("_");
      function plural$5(n) {
        return n > 1 && n < 5;
      }
      function translate$9(number2, withoutSuffix, key, isFuture) {
        var result = number2 + " ";
        switch (key) {
          case "s":
            return withoutSuffix || isFuture ? "pÃ¡r sekÃºnd" : "pÃ¡r sekundami";
          case "ss":
            if (withoutSuffix || isFuture) {
              return result + (plural$5(number2) ? "sekundy" : "sekÃºnd");
            } else {
              return result + "sekundami";
            }
          case "m":
            return withoutSuffix ? "minÃºta" : isFuture ? "minÃºtu" : "minÃºtou";
          case "mm":
            if (withoutSuffix || isFuture) {
              return result + (plural$5(number2) ? "minÃºty" : "minÃºt");
            } else {
              return result + "minÃºtami";
            }
          case "h":
            return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";
          case "hh":
            if (withoutSuffix || isFuture) {
              return result + (plural$5(number2) ? "hodiny" : "hodÃ­n");
            } else {
              return result + "hodinami";
            }
          case "d":
            return withoutSuffix || isFuture ? "deÅˆ" : "dÅˆom";
          case "dd":
            if (withoutSuffix || isFuture) {
              return result + (plural$5(number2) ? "dni" : "dnÃ­");
            } else {
              return result + "dÅˆami";
            }
          case "M":
            return withoutSuffix || isFuture ? "mesiac" : "mesiacom";
          case "MM":
            if (withoutSuffix || isFuture) {
              return result + (plural$5(number2) ? "mesiace" : "mesiacov");
            } else {
              return result + "mesiacmi";
            }
          case "y":
            return withoutSuffix || isFuture ? "rok" : "rokom";
          case "yy":
            if (withoutSuffix || isFuture) {
              return result + (plural$5(number2) ? "roky" : "rokov");
            } else {
              return result + "rokmi";
            }
        }
      }
      hooks.defineLocale("sk", {
        months: months$a,
        monthsShort: monthsShort$7,
        weekdays: "nedeÄ¾a_pondelok_utorok_streda_Å¡tvrtok_piatok_sobota".split("_"),
        weekdaysShort: "ne_po_ut_st_Å¡t_pi_so".split("_"),
        weekdaysMin: "ne_po_ut_st_Å¡t_pi_so".split("_"),
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D. MMMM YYYY",
          LLL: "D. MMMM YYYY H:mm",
          LLLL: "dddd D. MMMM YYYY H:mm"
        },
        calendar: {
          sameDay: "[dnes o] LT",
          nextDay: "[zajtra o] LT",
          nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[v nedeÄ¾u o] LT";
              case 1:
              case 2:
                return "[v] dddd [o] LT";
              case 3:
                return "[v stredu o] LT";
              case 4:
                return "[vo Å¡tvrtok o] LT";
              case 5:
                return "[v piatok o] LT";
              case 6:
                return "[v sobotu o] LT";
            }
          },
          lastDay: "[vÄera o] LT",
          lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[minulÃº nedeÄ¾u o] LT";
              case 1:
              case 2:
                return "[minulÃ½] dddd [o] LT";
              case 3:
                return "[minulÃº stredu o] LT";
              case 4:
              case 5:
                return "[minulÃ½] dddd [o] LT";
              case 6:
                return "[minulÃº sobotu o] LT";
            }
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "za %s",
          past: "pred %s",
          s: translate$9,
          ss: translate$9,
          m: translate$9,
          mm: translate$9,
          h: translate$9,
          hh: translate$9,
          d: translate$9,
          dd: translate$9,
          M: translate$9,
          MM: translate$9,
          y: translate$9,
          yy: translate$9
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      function processRelativeTime$9(number2, withoutSuffix, key, isFuture) {
        var result = number2 + " ";
        switch (key) {
          case "s":
            return withoutSuffix || isFuture ? "nekaj sekund" : "nekaj sekundami";
          case "ss":
            if (number2 === 1) {
              result += withoutSuffix ? "sekundo" : "sekundi";
            } else if (number2 === 2) {
              result += withoutSuffix || isFuture ? "sekundi" : "sekundah";
            } else if (number2 < 5) {
              result += withoutSuffix || isFuture ? "sekunde" : "sekundah";
            } else {
              result += "sekund";
            }
            return result;
          case "m":
            return withoutSuffix ? "ena minuta" : "eno minuto";
          case "mm":
            if (number2 === 1) {
              result += withoutSuffix ? "minuta" : "minuto";
            } else if (number2 === 2) {
              result += withoutSuffix || isFuture ? "minuti" : "minutama";
            } else if (number2 < 5) {
              result += withoutSuffix || isFuture ? "minute" : "minutami";
            } else {
              result += withoutSuffix || isFuture ? "minut" : "minutami";
            }
            return result;
          case "h":
            return withoutSuffix ? "ena ura" : "eno uro";
          case "hh":
            if (number2 === 1) {
              result += withoutSuffix ? "ura" : "uro";
            } else if (number2 === 2) {
              result += withoutSuffix || isFuture ? "uri" : "urama";
            } else if (number2 < 5) {
              result += withoutSuffix || isFuture ? "ure" : "urami";
            } else {
              result += withoutSuffix || isFuture ? "ur" : "urami";
            }
            return result;
          case "d":
            return withoutSuffix || isFuture ? "en dan" : "enim dnem";
          case "dd":
            if (number2 === 1) {
              result += withoutSuffix || isFuture ? "dan" : "dnem";
            } else if (number2 === 2) {
              result += withoutSuffix || isFuture ? "dni" : "dnevoma";
            } else {
              result += withoutSuffix || isFuture ? "dni" : "dnevi";
            }
            return result;
          case "M":
            return withoutSuffix || isFuture ? "en mesec" : "enim mesecem";
          case "MM":
            if (number2 === 1) {
              result += withoutSuffix || isFuture ? "mesec" : "mesecem";
            } else if (number2 === 2) {
              result += withoutSuffix || isFuture ? "meseca" : "mesecema";
            } else if (number2 < 5) {
              result += withoutSuffix || isFuture ? "mesece" : "meseci";
            } else {
              result += withoutSuffix || isFuture ? "mesecev" : "meseci";
            }
            return result;
          case "y":
            return withoutSuffix || isFuture ? "eno leto" : "enim letom";
          case "yy":
            if (number2 === 1) {
              result += withoutSuffix || isFuture ? "leto" : "letom";
            } else if (number2 === 2) {
              result += withoutSuffix || isFuture ? "leti" : "letoma";
            } else if (number2 < 5) {
              result += withoutSuffix || isFuture ? "leta" : "leti";
            } else {
              result += withoutSuffix || isFuture ? "let" : "leti";
            }
            return result;
        }
      }
      hooks.defineLocale("sl", {
        months: "januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split(
          "_"
        ),
        monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "nedelja_ponedeljek_torek_sreda_Äetrtek_petek_sobota".split("_"),
        weekdaysShort: "ned._pon._tor._sre._Äet._pet._sob.".split("_"),
        weekdaysMin: "ne_po_to_sr_Äe_pe_so".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD. MM. YYYY",
          LL: "D. MMMM YYYY",
          LLL: "D. MMMM YYYY H:mm",
          LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
          sameDay: "[danes ob] LT",
          nextDay: "[jutri ob] LT",
          nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[v] [nedeljo] [ob] LT";
              case 3:
                return "[v] [sredo] [ob] LT";
              case 6:
                return "[v] [soboto] [ob] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[v] dddd [ob] LT";
            }
          },
          lastDay: "[vÄeraj ob] LT",
          lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[prejÅ¡njo] [nedeljo] [ob] LT";
              case 3:
                return "[prejÅ¡njo] [sredo] [ob] LT";
              case 6:
                return "[prejÅ¡njo] [soboto] [ob] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[prejÅ¡nji] dddd [ob] LT";
            }
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "Äez %s",
          past: "pred %s",
          s: processRelativeTime$9,
          ss: processRelativeTime$9,
          m: processRelativeTime$9,
          mm: processRelativeTime$9,
          h: processRelativeTime$9,
          hh: processRelativeTime$9,
          d: processRelativeTime$9,
          dd: processRelativeTime$9,
          M: processRelativeTime$9,
          MM: processRelativeTime$9,
          y: processRelativeTime$9,
          yy: processRelativeTime$9
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("sq", {
        months: "Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_NÃ«ntor_Dhjetor".split(
          "_"
        ),
        monthsShort: "Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_NÃ«n_Dhj".split("_"),
        weekdays: "E Diel_E HÃ«nÃ«_E MartÃ«_E MÃ«rkurÃ«_E Enjte_E Premte_E ShtunÃ«".split(
          "_"
        ),
        weekdaysShort: "Die_HÃ«n_Mar_MÃ«r_Enj_Pre_Sht".split("_"),
        weekdaysMin: "D_H_Ma_MÃ«_E_P_Sh".split("_"),
        weekdaysParseExact: true,
        meridiemParse: /PD|MD/,
        isPM: function(input) {
          return input.charAt(0) === "M";
        },
        meridiem: function(hours2, minutes2, isLower) {
          return hours2 < 12 ? "PD" : "MD";
        },
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Sot nÃ«] LT",
          nextDay: "[NesÃ«r nÃ«] LT",
          nextWeek: "dddd [nÃ«] LT",
          lastDay: "[Dje nÃ«] LT",
          lastWeek: "dddd [e kaluar nÃ«] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "nÃ« %s",
          past: "%s mÃ« parÃ«",
          s: "disa sekonda",
          ss: "%d sekonda",
          m: "njÃ« minutÃ«",
          mm: "%d minuta",
          h: "njÃ« orÃ«",
          hh: "%d orÃ«",
          d: "njÃ« ditÃ«",
          dd: "%d ditÃ«",
          M: "njÃ« muaj",
          MM: "%d muaj",
          y: "njÃ« vit",
          yy: "%d vite"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var translator$1 = {
        words: {
          //Different grammatical cases
          ss: ["ÑÐµÐºÑƒÐ½Ð´Ð°", "ÑÐµÐºÑƒÐ½Ð´Ðµ", "ÑÐµÐºÑƒÐ½Ð´Ð¸"],
          m: ["Ñ˜ÐµÐ´Ð°Ð½ Ð¼Ð¸Ð½ÑƒÑ‚", "Ñ˜ÐµÐ´Ð½Ð¾Ð³ Ð¼Ð¸Ð½ÑƒÑ‚Ð°"],
          mm: ["Ð¼Ð¸Ð½ÑƒÑ‚", "Ð¼Ð¸Ð½ÑƒÑ‚Ð°", "Ð¼Ð¸Ð½ÑƒÑ‚Ð°"],
          h: ["Ñ˜ÐµÐ´Ð°Ð½ ÑÐ°Ñ‚", "Ñ˜ÐµÐ´Ð½Ð¾Ð³ ÑÐ°Ñ‚Ð°"],
          hh: ["ÑÐ°Ñ‚", "ÑÐ°Ñ‚Ð°", "ÑÐ°Ñ‚Ð¸"],
          d: ["Ñ˜ÐµÐ´Ð°Ð½ Ð´Ð°Ð½", "Ñ˜ÐµÐ´Ð½Ð¾Ð³ Ð´Ð°Ð½Ð°"],
          dd: ["Ð´Ð°Ð½", "Ð´Ð°Ð½Ð°", "Ð´Ð°Ð½Ð°"],
          M: ["Ñ˜ÐµÐ´Ð°Ð½ Ð¼ÐµÑÐµÑ†", "Ñ˜ÐµÐ´Ð½Ð¾Ð³ Ð¼ÐµÑÐµÑ†Ð°"],
          MM: ["Ð¼ÐµÑÐµÑ†", "Ð¼ÐµÑÐµÑ†Ð°", "Ð¼ÐµÑÐµÑ†Ð¸"],
          y: ["Ñ˜ÐµÐ´Ð½Ñƒ Ð³Ð¾Ð´Ð¸Ð½Ñƒ", "Ñ˜ÐµÐ´Ð½Ðµ Ð³Ð¾Ð´Ð¸Ð½Ðµ"],
          yy: ["Ð³Ð¾Ð´Ð¸Ð½Ñƒ", "Ð³Ð¾Ð´Ð¸Ð½Ðµ", "Ð³Ð¾Ð´Ð¸Ð½Ð°"]
        },
        correctGrammaticalCase: function(number2, wordKey) {
          if (number2 % 10 >= 1 && number2 % 10 <= 4 && (number2 % 100 < 10 || number2 % 100 >= 20)) {
            return number2 % 10 === 1 ? wordKey[0] : wordKey[1];
          }
          return wordKey[2];
        },
        translate: function(number2, withoutSuffix, key, isFuture) {
          var wordKey = translator$1.words[key], word;
          if (key.length === 1) {
            if (key === "y" && withoutSuffix) return "Ñ˜ÐµÐ´Ð½Ð° Ð³Ð¾Ð´Ð¸Ð½Ð°";
            return isFuture || withoutSuffix ? wordKey[0] : wordKey[1];
          }
          word = translator$1.correctGrammaticalCase(number2, wordKey);
          if (key === "yy" && withoutSuffix && word === "Ð³Ð¾Ð´Ð¸Ð½Ñƒ") {
            return number2 + " Ð³Ð¾Ð´Ð¸Ð½Ð°";
          }
          return number2 + " " + word;
        }
      };
      hooks.defineLocale("sr-cyrl", {
        months: "Ñ˜Ð°Ð½ÑƒÐ°Ñ€_Ñ„ÐµÐ±Ñ€ÑƒÐ°Ñ€_Ð¼Ð°Ñ€Ñ‚_Ð°Ð¿Ñ€Ð¸Ð»_Ð¼Ð°Ñ˜_Ñ˜ÑƒÐ½_Ñ˜ÑƒÐ»_Ð°Ð²Ð³ÑƒÑÑ‚_ÑÐµÐ¿Ñ‚ÐµÐ¼Ð±Ð°Ñ€_Ð¾ÐºÑ‚Ð¾Ð±Ð°Ñ€_Ð½Ð¾Ð²ÐµÐ¼Ð±Ð°Ñ€_Ð´ÐµÑ†ÐµÐ¼Ð±Ð°Ñ€".split(
          "_"
        ),
        monthsShort: "Ñ˜Ð°Ð½._Ñ„ÐµÐ±._Ð¼Ð°Ñ€._Ð°Ð¿Ñ€._Ð¼Ð°Ñ˜_Ñ˜ÑƒÐ½_Ñ˜ÑƒÐ»_Ð°Ð²Ð³._ÑÐµÐ¿._Ð¾ÐºÑ‚._Ð½Ð¾Ð²._Ð´ÐµÑ†.".split("_"),
        monthsParseExact: true,
        weekdays: "Ð½ÐµÐ´ÐµÑ™Ð°_Ð¿Ð¾Ð½ÐµÐ´ÐµÑ™Ð°Ðº_ÑƒÑ‚Ð¾Ñ€Ð°Ðº_ÑÑ€ÐµÐ´Ð°_Ñ‡ÐµÑ‚Ð²Ñ€Ñ‚Ð°Ðº_Ð¿ÐµÑ‚Ð°Ðº_ÑÑƒÐ±Ð¾Ñ‚Ð°".split("_"),
        weekdaysShort: "Ð½ÐµÐ´._Ð¿Ð¾Ð½._ÑƒÑ‚Ð¾._ÑÑ€Ðµ._Ñ‡ÐµÑ‚._Ð¿ÐµÑ‚._ÑÑƒÐ±.".split("_"),
        weekdaysMin: "Ð½Ðµ_Ð¿Ð¾_ÑƒÑ‚_ÑÑ€_Ñ‡Ðµ_Ð¿Ðµ_ÑÑƒ".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "D. M. YYYY.",
          LL: "D. MMMM YYYY.",
          LLL: "D. MMMM YYYY. H:mm",
          LLLL: "dddd, D. MMMM YYYY. H:mm"
        },
        calendar: {
          sameDay: "[Ð´Ð°Ð½Ð°Ñ Ñƒ] LT",
          nextDay: "[ÑÑƒÑ‚Ñ€Ð° Ñƒ] LT",
          nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[Ñƒ] [Ð½ÐµÐ´ÐµÑ™Ñƒ] [Ñƒ] LT";
              case 3:
                return "[Ñƒ] [ÑÑ€ÐµÐ´Ñƒ] [Ñƒ] LT";
              case 6:
                return "[Ñƒ] [ÑÑƒÐ±Ð¾Ñ‚Ñƒ] [Ñƒ] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[Ñƒ] dddd [Ñƒ] LT";
            }
          },
          lastDay: "[Ñ˜ÑƒÑ‡Ðµ Ñƒ] LT",
          lastWeek: function() {
            var lastWeekDays = [
              "[Ð¿Ñ€Ð¾ÑˆÐ»Ðµ] [Ð½ÐµÐ´ÐµÑ™Ðµ] [Ñƒ] LT",
              "[Ð¿Ñ€Ð¾ÑˆÐ»Ð¾Ð³] [Ð¿Ð¾Ð½ÐµÐ´ÐµÑ™ÐºÐ°] [Ñƒ] LT",
              "[Ð¿Ñ€Ð¾ÑˆÐ»Ð¾Ð³] [ÑƒÑ‚Ð¾Ñ€ÐºÐ°] [Ñƒ] LT",
              "[Ð¿Ñ€Ð¾ÑˆÐ»Ðµ] [ÑÑ€ÐµÐ´Ðµ] [Ñƒ] LT",
              "[Ð¿Ñ€Ð¾ÑˆÐ»Ð¾Ð³] [Ñ‡ÐµÑ‚Ð²Ñ€Ñ‚ÐºÐ°] [Ñƒ] LT",
              "[Ð¿Ñ€Ð¾ÑˆÐ»Ð¾Ð³] [Ð¿ÐµÑ‚ÐºÐ°] [Ñƒ] LT",
              "[Ð¿Ñ€Ð¾ÑˆÐ»Ðµ] [ÑÑƒÐ±Ð¾Ñ‚Ðµ] [Ñƒ] LT"
            ];
            return lastWeekDays[this.day()];
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "Ð·Ð° %s",
          past: "Ð¿Ñ€Ðµ %s",
          s: "Ð½ÐµÐºÐ¾Ð»Ð¸ÐºÐ¾ ÑÐµÐºÑƒÐ½Ð´Ð¸",
          ss: translator$1.translate,
          m: translator$1.translate,
          mm: translator$1.translate,
          h: translator$1.translate,
          hh: translator$1.translate,
          d: translator$1.translate,
          dd: translator$1.translate,
          M: translator$1.translate,
          MM: translator$1.translate,
          y: translator$1.translate,
          yy: translator$1.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 1st is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var translator$2 = {
        words: {
          //Different grammatical cases
          ss: ["sekunda", "sekunde", "sekundi"],
          m: ["jedan minut", "jednog minuta"],
          mm: ["minut", "minuta", "minuta"],
          h: ["jedan sat", "jednog sata"],
          hh: ["sat", "sata", "sati"],
          d: ["jedan dan", "jednog dana"],
          dd: ["dan", "dana", "dana"],
          M: ["jedan mesec", "jednog meseca"],
          MM: ["mesec", "meseca", "meseci"],
          y: ["jednu godinu", "jedne godine"],
          yy: ["godinu", "godine", "godina"]
        },
        correctGrammaticalCase: function(number2, wordKey) {
          if (number2 % 10 >= 1 && number2 % 10 <= 4 && (number2 % 100 < 10 || number2 % 100 >= 20)) {
            return number2 % 10 === 1 ? wordKey[0] : wordKey[1];
          }
          return wordKey[2];
        },
        translate: function(number2, withoutSuffix, key, isFuture) {
          var wordKey = translator$2.words[key], word;
          if (key.length === 1) {
            if (key === "y" && withoutSuffix) return "jedna godina";
            return isFuture || withoutSuffix ? wordKey[0] : wordKey[1];
          }
          word = translator$2.correctGrammaticalCase(number2, wordKey);
          if (key === "yy" && withoutSuffix && word === "godinu") {
            return number2 + " godina";
          }
          return number2 + " " + word;
        }
      };
      hooks.defineLocale("sr", {
        months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split(
          "_"
        ),
        monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
        monthsParseExact: true,
        weekdays: "nedelja_ponedeljak_utorak_sreda_Äetvrtak_petak_subota".split(
          "_"
        ),
        weekdaysShort: "ned._pon._uto._sre._Äet._pet._sub.".split("_"),
        weekdaysMin: "ne_po_ut_sr_Äe_pe_su".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "D. M. YYYY.",
          LL: "D. MMMM YYYY.",
          LLL: "D. MMMM YYYY. H:mm",
          LLLL: "dddd, D. MMMM YYYY. H:mm"
        },
        calendar: {
          sameDay: "[danas u] LT",
          nextDay: "[sutra u] LT",
          nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[u] [nedelju] [u] LT";
              case 3:
                return "[u] [sredu] [u] LT";
              case 6:
                return "[u] [subotu] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[u] dddd [u] LT";
            }
          },
          lastDay: "[juÄe u] LT",
          lastWeek: function() {
            var lastWeekDays = [
              "[proÅ¡le] [nedelje] [u] LT",
              "[proÅ¡log] [ponedeljka] [u] LT",
              "[proÅ¡log] [utorka] [u] LT",
              "[proÅ¡le] [srede] [u] LT",
              "[proÅ¡log] [Äetvrtka] [u] LT",
              "[proÅ¡log] [petka] [u] LT",
              "[proÅ¡le] [subote] [u] LT"
            ];
            return lastWeekDays[this.day()];
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "za %s",
          past: "pre %s",
          s: "nekoliko sekundi",
          ss: translator$2.translate,
          m: translator$2.translate,
          mm: translator$2.translate,
          h: translator$2.translate,
          hh: translator$2.translate,
          d: translator$2.translate,
          dd: translator$2.translate,
          M: translator$2.translate,
          MM: translator$2.translate,
          y: translator$2.translate,
          yy: translator$2.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("ss", {
        months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split(
          "_"
        ),
        monthsShort: "Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo".split("_"),
        weekdays: "Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo".split(
          "_"
        ),
        weekdaysShort: "Lis_Umb_Lsb_Les_Lsi_Lsh_Umg".split("_"),
        weekdaysMin: "Li_Us_Lb_Lt_Ls_Lh_Ug".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "h:mm A",
          LTS: "h:mm:ss A",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY h:mm A",
          LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendar: {
          sameDay: "[Namuhla nga] LT",
          nextDay: "[Kusasa nga] LT",
          nextWeek: "dddd [nga] LT",
          lastDay: "[Itolo nga] LT",
          lastWeek: "dddd [leliphelile] [nga] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "nga %s",
          past: "wenteka nga %s",
          s: "emizuzwana lomcane",
          ss: "%d mzuzwana",
          m: "umzuzu",
          mm: "%d emizuzu",
          h: "lihora",
          hh: "%d emahora",
          d: "lilanga",
          dd: "%d emalanga",
          M: "inyanga",
          MM: "%d tinyanga",
          y: "umnyaka",
          yy: "%d iminyaka"
        },
        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
        meridiem: function(hours2, minutes2, isLower) {
          if (hours2 < 11) {
            return "ekuseni";
          } else if (hours2 < 15) {
            return "emini";
          } else if (hours2 < 19) {
            return "entsambama";
          } else {
            return "ebusuku";
          }
        },
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "ekuseni") {
            return hour;
          } else if (meridiem2 === "emini") {
            return hour >= 11 ? hour : hour + 12;
          } else if (meridiem2 === "entsambama" || meridiem2 === "ebusuku") {
            if (hour === 0) {
              return 0;
            }
            return hour + 12;
          }
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("sv", {
        months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split(
          "_"
        ),
        monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
        weekdays: "sÃ¶ndag_mÃ¥ndag_tisdag_onsdag_torsdag_fredag_lÃ¶rdag".split("_"),
        weekdaysShort: "sÃ¶n_mÃ¥n_tis_ons_tor_fre_lÃ¶r".split("_"),
        weekdaysMin: "sÃ¶_mÃ¥_ti_on_to_fr_lÃ¶".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "YYYY-MM-DD",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY [kl.] HH:mm",
          LLLL: "dddd D MMMM YYYY [kl.] HH:mm",
          lll: "D MMM YYYY HH:mm",
          llll: "ddd D MMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Idag] LT",
          nextDay: "[Imorgon] LT",
          lastDay: "[IgÃ¥r] LT",
          nextWeek: "[PÃ¥] dddd LT",
          lastWeek: "[I] dddd[s] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "om %s",
          past: "fÃ¶r %s sedan",
          s: "nÃ¥gra sekunder",
          ss: "%d sekunder",
          m: "en minut",
          mm: "%d minuter",
          h: "en timme",
          hh: "%d timmar",
          d: "en dag",
          dd: "%d dagar",
          M: "en mÃ¥nad",
          MM: "%d mÃ¥nader",
          y: "ett Ã¥r",
          yy: "%d Ã¥r"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/,
        ordinal: function(number2) {
          var b = number2 % 10, output = ~~(number2 % 100 / 10) === 1 ? ":e" : b === 1 ? ":a" : b === 2 ? ":a" : b === 3 ? ":e" : ":e";
          return number2 + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("sw", {
        months: "Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba".split(
          "_"
        ),
        monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des".split("_"),
        weekdays: "Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi".split(
          "_"
        ),
        weekdaysShort: "Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos".split("_"),
        weekdaysMin: "J2_J3_J4_J5_Al_Ij_J1".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "hh:mm A",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[leo saa] LT",
          nextDay: "[kesho saa] LT",
          nextWeek: "[wiki ijayo] dddd [saat] LT",
          lastDay: "[jana] LT",
          lastWeek: "[wiki iliyopita] dddd [saat] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s baadaye",
          past: "tokea %s",
          s: "hivi punde",
          ss: "sekunde %d",
          m: "dakika moja",
          mm: "dakika %d",
          h: "saa limoja",
          hh: "masaa %d",
          d: "siku moja",
          dd: "siku %d",
          M: "mwezi mmoja",
          MM: "miezi %d",
          y: "mwaka mmoja",
          yy: "miaka %d"
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var symbolMap$h = {
        1: "à¯§",
        2: "à¯¨",
        3: "à¯©",
        4: "à¯ª",
        5: "à¯«",
        6: "à¯¬",
        7: "à¯­",
        8: "à¯®",
        9: "à¯¯",
        0: "à¯¦"
      }, numberMap$g = {
        "à¯§": "1",
        "à¯¨": "2",
        "à¯©": "3",
        "à¯ª": "4",
        "à¯«": "5",
        "à¯¬": "6",
        "à¯­": "7",
        "à¯®": "8",
        "à¯¯": "9",
        "à¯¦": "0"
      };
      hooks.defineLocale("ta", {
        months: "à®œà®©à®µà®°à®¿_à®ªà®¿à®ªà¯à®°à®µà®°à®¿_à®®à®¾à®°à¯à®šà¯_à®à®ªà¯à®°à®²à¯_à®®à¯‡_à®œà¯‚à®©à¯_à®œà¯‚à®²à¯ˆ_à®†à®•à®¸à¯à®Ÿà¯_à®šà¯†à®ªà¯à®Ÿà¯†à®®à¯à®ªà®°à¯_à®…à®•à¯à®Ÿà¯‡à®¾à®ªà®°à¯_à®¨à®µà®®à¯à®ªà®°à¯_à®Ÿà®¿à®šà®®à¯à®ªà®°à¯".split(
          "_"
        ),
        monthsShort: "à®œà®©à®µà®°à®¿_à®ªà®¿à®ªà¯à®°à®µà®°à®¿_à®®à®¾à®°à¯à®šà¯_à®à®ªà¯à®°à®²à¯_à®®à¯‡_à®œà¯‚à®©à¯_à®œà¯‚à®²à¯ˆ_à®†à®•à®¸à¯à®Ÿà¯_à®šà¯†à®ªà¯à®Ÿà¯†à®®à¯à®ªà®°à¯_à®…à®•à¯à®Ÿà¯‡à®¾à®ªà®°à¯_à®¨à®µà®®à¯à®ªà®°à¯_à®Ÿà®¿à®šà®®à¯à®ªà®°à¯".split(
          "_"
        ),
        weekdays: "à®žà®¾à®¯à®¿à®±à¯à®±à¯à®•à¯à®•à®¿à®´à®®à¯ˆ_à®¤à®¿à®™à¯à®•à®Ÿà¯à®•à®¿à®´à®®à¯ˆ_à®šà¯†à®µà¯à®µà®¾à®¯à¯à®•à®¿à®´à®®à¯ˆ_à®ªà¯à®¤à®©à¯à®•à®¿à®´à®®à¯ˆ_à®µà®¿à®¯à®¾à®´à®•à¯à®•à®¿à®´à®®à¯ˆ_à®µà¯†à®³à¯à®³à®¿à®•à¯à®•à®¿à®´à®®à¯ˆ_à®šà®©à®¿à®•à¯à®•à®¿à®´à®®à¯ˆ".split(
          "_"
        ),
        weekdaysShort: "à®žà®¾à®¯à®¿à®±à¯_à®¤à®¿à®™à¯à®•à®³à¯_à®šà¯†à®µà¯à®µà®¾à®¯à¯_à®ªà¯à®¤à®©à¯_à®µà®¿à®¯à®¾à®´à®©à¯_à®µà¯†à®³à¯à®³à®¿_à®šà®©à®¿".split(
          "_"
        ),
        weekdaysMin: "à®žà®¾_à®¤à®¿_à®šà¯†_à®ªà¯_à®µà®¿_à®µà¯†_à®š".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY, HH:mm",
          LLLL: "dddd, D MMMM YYYY, HH:mm"
        },
        calendar: {
          sameDay: "[à®‡à®©à¯à®±à¯] LT",
          nextDay: "[à®¨à®¾à®³à¯ˆ] LT",
          nextWeek: "dddd, LT",
          lastDay: "[à®¨à¯‡à®±à¯à®±à¯] LT",
          lastWeek: "[à®•à®Ÿà®¨à¯à®¤ à®µà®¾à®°à®®à¯] dddd, LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s à®‡à®²à¯",
          past: "%s à®®à¯à®©à¯",
          s: "à®’à®°à¯ à®šà®¿à®² à®µà®¿à®¨à®¾à®Ÿà®¿à®•à®³à¯",
          ss: "%d à®µà®¿à®¨à®¾à®Ÿà®¿à®•à®³à¯",
          m: "à®’à®°à¯ à®¨à®¿à®®à®¿à®Ÿà®®à¯",
          mm: "%d à®¨à®¿à®®à®¿à®Ÿà®™à¯à®•à®³à¯",
          h: "à®’à®°à¯ à®®à®£à®¿ à®¨à¯‡à®°à®®à¯",
          hh: "%d à®®à®£à®¿ à®¨à¯‡à®°à®®à¯",
          d: "à®’à®°à¯ à®¨à®¾à®³à¯",
          dd: "%d à®¨à®¾à®Ÿà¯à®•à®³à¯",
          M: "à®’à®°à¯ à®®à®¾à®¤à®®à¯",
          MM: "%d à®®à®¾à®¤à®™à¯à®•à®³à¯",
          y: "à®’à®°à¯ à®µà®°à¯à®Ÿà®®à¯",
          yy: "%d à®†à®£à¯à®Ÿà¯à®•à®³à¯"
        },
        dayOfMonthOrdinalParse: /\d{1,2}à®µà®¤à¯/,
        ordinal: function(number2) {
          return number2 + "à®µà®¤à¯";
        },
        preparse: function(string2) {
          return string2.replace(/[à¯§à¯¨à¯©à¯ªà¯«à¯¬à¯­à¯®à¯¯à¯¦]/g, function(match) {
            return numberMap$g[match];
          });
        },
        postformat: function(string2) {
          return string2.replace(/\d/g, function(match) {
            return symbolMap$h[match];
          });
        },
        // refer http://ta.wikipedia.org/s/1er1
        meridiemParse: /à®¯à®¾à®®à®®à¯|à®µà¯ˆà®•à®±à¯ˆ|à®•à®¾à®²à¯ˆ|à®¨à®£à¯à®ªà®•à®²à¯|à®Žà®±à¯à®ªà®¾à®Ÿà¯|à®®à®¾à®²à¯ˆ/,
        meridiem: function(hour, minute, isLower) {
          if (hour < 2) {
            return " à®¯à®¾à®®à®®à¯";
          } else if (hour < 6) {
            return " à®µà¯ˆà®•à®±à¯ˆ";
          } else if (hour < 10) {
            return " à®•à®¾à®²à¯ˆ";
          } else if (hour < 14) {
            return " à®¨à®£à¯à®ªà®•à®²à¯";
          } else if (hour < 18) {
            return " à®Žà®±à¯à®ªà®¾à®Ÿà¯";
          } else if (hour < 22) {
            return " à®®à®¾à®²à¯ˆ";
          } else {
            return " à®¯à®¾à®®à®®à¯";
          }
        },
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "à®¯à®¾à®®à®®à¯") {
            return hour < 2 ? hour : hour + 12;
          } else if (meridiem2 === "à®µà¯ˆà®•à®±à¯ˆ" || meridiem2 === "à®•à®¾à®²à¯ˆ") {
            return hour;
          } else if (meridiem2 === "à®¨à®£à¯à®ªà®•à®²à¯") {
            return hour >= 10 ? hour : hour + 12;
          } else {
            return hour + 12;
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("te", {
        months: "à°œà°¨à°µà°°à°¿_à°«à°¿à°¬à±à°°à°µà°°à°¿_à°®à°¾à°°à±à°šà°¿_à°à°ªà±à°°à°¿à°²à±_à°®à±‡_à°œà±‚à°¨à±_à°œà±à°²à±ˆ_à°†à°—à°¸à±à°Ÿà±_à°¸à±†à°ªà±à°Ÿà±†à°‚à°¬à°°à±_à°…à°•à±à°Ÿà±‹à°¬à°°à±_à°¨à°µà°‚à°¬à°°à±_à°¡à°¿à°¸à±†à°‚à°¬à°°à±".split(
          "_"
        ),
        monthsShort: "à°œà°¨._à°«à°¿à°¬à±à°°._à°®à°¾à°°à±à°šà°¿_à°à°ªà±à°°à°¿._à°®à±‡_à°œà±‚à°¨à±_à°œà±à°²à±ˆ_à°†à°—._à°¸à±†à°ªà±._à°…à°•à±à°Ÿà±‹._à°¨à°µ._à°¡à°¿à°¸à±†.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "à°†à°¦à°¿à°µà°¾à°°à°‚_à°¸à±‹à°®à°µà°¾à°°à°‚_à°®à°‚à°—à°³à°µà°¾à°°à°‚_à°¬à±à°§à°µà°¾à°°à°‚_à°—à±à°°à±à°µà°¾à°°à°‚_à°¶à±à°•à±à°°à°µà°¾à°°à°‚_à°¶à°¨à°¿à°µà°¾à°°à°‚".split(
          "_"
        ),
        weekdaysShort: "à°†à°¦à°¿_à°¸à±‹à°®_à°®à°‚à°—à°³_à°¬à±à°§_à°—à±à°°à±_à°¶à±à°•à±à°°_à°¶à°¨à°¿".split("_"),
        weekdaysMin: "à°†_à°¸à±‹_à°®à°‚_à°¬à±_à°—à±_à°¶à±_à°¶".split("_"),
        longDateFormat: {
          LT: "A h:mm",
          LTS: "A h:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY, A h:mm",
          LLLL: "dddd, D MMMM YYYY, A h:mm"
        },
        calendar: {
          sameDay: "[à°¨à±‡à°¡à±] LT",
          nextDay: "[à°°à±‡à°ªà±] LT",
          nextWeek: "dddd, LT",
          lastDay: "[à°¨à°¿à°¨à±à°¨] LT",
          lastWeek: "[à°—à°¤] dddd, LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s à°²à±‹",
          past: "%s à°•à±à°°à°¿à°¤à°‚",
          s: "à°•à±Šà°¨à±à°¨à°¿ à°•à±à°·à°£à°¾à°²à±",
          ss: "%d à°¸à±†à°•à°¨à±à°²à±",
          m: "à°’à°• à°¨à°¿à°®à°¿à°·à°‚",
          mm: "%d à°¨à°¿à°®à°¿à°·à°¾à°²à±",
          h: "à°’à°• à°—à°‚à°Ÿ",
          hh: "%d à°—à°‚à°Ÿà°²à±",
          d: "à°’à°• à°°à±‹à°œà±",
          dd: "%d à°°à±‹à°œà±à°²à±",
          M: "à°’à°• à°¨à±†à°²",
          MM: "%d à°¨à±†à°²à°²à±",
          y: "à°’à°• à°¸à°‚à°µà°¤à±à°¸à°°à°‚",
          yy: "%d à°¸à°‚à°µà°¤à±à°¸à°°à°¾à°²à±"
        },
        dayOfMonthOrdinalParse: /\d{1,2}à°µ/,
        ordinal: "%dà°µ",
        meridiemParse: /à°°à°¾à°¤à±à°°à°¿|à°‰à°¦à°¯à°‚|à°®à°§à±à°¯à°¾à°¹à±à°¨à°‚|à°¸à°¾à°¯à°‚à°¤à±à°°à°‚/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "à°°à°¾à°¤à±à°°à°¿") {
            return hour < 4 ? hour : hour + 12;
          } else if (meridiem2 === "à°‰à°¦à°¯à°‚") {
            return hour;
          } else if (meridiem2 === "à°®à°§à±à°¯à°¾à°¹à±à°¨à°‚") {
            return hour >= 10 ? hour : hour + 12;
          } else if (meridiem2 === "à°¸à°¾à°¯à°‚à°¤à±à°°à°‚") {
            return hour + 12;
          }
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "à°°à°¾à°¤à±à°°à°¿";
          } else if (hour < 10) {
            return "à°‰à°¦à°¯à°‚";
          } else if (hour < 17) {
            return "à°®à°§à±à°¯à°¾à°¹à±à°¨à°‚";
          } else if (hour < 20) {
            return "à°¸à°¾à°¯à°‚à°¤à±à°°à°‚";
          } else {
            return "à°°à°¾à°¤à±à°°à°¿";
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("tet", {
        months: "Janeiru_Fevereiru_Marsu_Abril_Maiu_JuÃ±u_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru".split(
          "_"
        ),
        monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),
        weekdays: "Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu".split("_"),
        weekdaysShort: "Dom_Seg_Ters_Kua_Kint_Sest_Sab".split("_"),
        weekdaysMin: "Do_Seg_Te_Ku_Ki_Ses_Sa".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Ohin iha] LT",
          nextDay: "[Aban iha] LT",
          nextWeek: "dddd [iha] LT",
          lastDay: "[Horiseik iha] LT",
          lastWeek: "dddd [semana kotuk] [iha] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "iha %s",
          past: "%s liuba",
          s: "segundu balun",
          ss: "segundu %d",
          m: "minutu ida",
          mm: "minutu %d",
          h: "oras ida",
          hh: "oras %d",
          d: "loron ida",
          dd: "loron %d",
          M: "fulan ida",
          MM: "fulan %d",
          y: "tinan ida",
          yy: "tinan %d"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number2) {
          var b = number2 % 10, output = ~~(number2 % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number2 + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var suffixes$3 = {
        0: "-ÑƒÐ¼",
        1: "-ÑƒÐ¼",
        2: "-ÑŽÐ¼",
        3: "-ÑŽÐ¼",
        4: "-ÑƒÐ¼",
        5: "-ÑƒÐ¼",
        6: "-ÑƒÐ¼",
        7: "-ÑƒÐ¼",
        8: "-ÑƒÐ¼",
        9: "-ÑƒÐ¼",
        10: "-ÑƒÐ¼",
        12: "-ÑƒÐ¼",
        13: "-ÑƒÐ¼",
        20: "-ÑƒÐ¼",
        30: "-ÑŽÐ¼",
        40: "-ÑƒÐ¼",
        50: "-ÑƒÐ¼",
        60: "-ÑƒÐ¼",
        70: "-ÑƒÐ¼",
        80: "-ÑƒÐ¼",
        90: "-ÑƒÐ¼",
        100: "-ÑƒÐ¼"
      };
      hooks.defineLocale("tg", {
        months: {
          format: "ÑÐ½Ð²Ð°Ñ€Ð¸_Ñ„ÐµÐ²Ñ€Ð°Ð»Ð¸_Ð¼Ð°Ñ€Ñ‚Ð¸_Ð°Ð¿Ñ€ÐµÐ»Ð¸_Ð¼Ð°Ð¹Ð¸_Ð¸ÑŽÐ½Ð¸_Ð¸ÑŽÐ»Ð¸_Ð°Ð²Ð³ÑƒÑÑ‚Ð¸_ÑÐµÐ½Ñ‚ÑÐ±Ñ€Ð¸_Ð¾ÐºÑ‚ÑÐ±Ñ€Ð¸_Ð½Ð¾ÑÐ±Ñ€Ð¸_Ð´ÐµÐºÐ°Ð±Ñ€Ð¸".split(
            "_"
          ),
          standalone: "ÑÐ½Ð²Ð°Ñ€_Ñ„ÐµÐ²Ñ€Ð°Ð»_Ð¼Ð°Ñ€Ñ‚_Ð°Ð¿Ñ€ÐµÐ»_Ð¼Ð°Ð¹_Ð¸ÑŽÐ½_Ð¸ÑŽÐ»_Ð°Ð²Ð³ÑƒÑÑ‚_ÑÐµÐ½Ñ‚ÑÐ±Ñ€_Ð¾ÐºÑ‚ÑÐ±Ñ€_Ð½Ð¾ÑÐ±Ñ€_Ð´ÐµÐºÐ°Ð±Ñ€".split(
            "_"
          )
        },
        monthsShort: "ÑÐ½Ð²_Ñ„ÐµÐ²_Ð¼Ð°Ñ€_Ð°Ð¿Ñ€_Ð¼Ð°Ð¹_Ð¸ÑŽÐ½_Ð¸ÑŽÐ»_Ð°Ð²Ð³_ÑÐµÐ½_Ð¾ÐºÑ‚_Ð½Ð¾Ñ_Ð´ÐµÐº".split("_"),
        weekdays: "ÑÐºÑˆÐ°Ð½Ð±Ðµ_Ð´ÑƒÑˆÐ°Ð½Ð±Ðµ_ÑÐµÑˆÐ°Ð½Ð±Ðµ_Ñ‡Ð¾Ñ€ÑˆÐ°Ð½Ð±Ðµ_Ð¿Ð°Ð½Ò·ÑˆÐ°Ð½Ð±Ðµ_Ò·ÑƒÐ¼ÑŠÐ°_ÑˆÐ°Ð½Ð±Ðµ".split(
          "_"
        ),
        weekdaysShort: "ÑÑˆÐ±_Ð´ÑˆÐ±_ÑÑˆÐ±_Ñ‡ÑˆÐ±_Ð¿ÑˆÐ±_Ò·ÑƒÐ¼_ÑˆÐ½Ð±".split("_"),
        weekdaysMin: "ÑÑˆ_Ð´Ñˆ_ÑÑˆ_Ñ‡Ñˆ_Ð¿Ñˆ_Ò·Ð¼_ÑˆÐ±".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Ð˜Ð¼Ñ€Ó¯Ð· ÑÐ¾Ð°Ñ‚Ð¸] LT",
          nextDay: "[Ð¤Ð°Ñ€Ð´Ð¾ ÑÐ¾Ð°Ñ‚Ð¸] LT",
          lastDay: "[Ð”Ð¸Ñ€Ó¯Ð· ÑÐ¾Ð°Ñ‚Ð¸] LT",
          nextWeek: "dddd[Ð¸] [Ò³Ð°Ñ„Ñ‚Ð°Ð¸ Ð¾ÑÐ½Ð´Ð° ÑÐ¾Ð°Ñ‚Ð¸] LT",
          lastWeek: "dddd[Ð¸] [Ò³Ð°Ñ„Ñ‚Ð°Ð¸ Ð³ÑƒÐ·Ð°ÑˆÑ‚Ð° ÑÐ¾Ð°Ñ‚Ð¸] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "Ð±Ð°ÑŠÐ´Ð¸ %s",
          past: "%s Ð¿ÐµÑˆ",
          s: "ÑÐºÑ‡Ð°Ð½Ð´ ÑÐ¾Ð½Ð¸Ñ",
          m: "ÑÐº Ð´Ð°Ò›Ð¸Ò›Ð°",
          mm: "%d Ð´Ð°Ò›Ð¸Ò›Ð°",
          h: "ÑÐº ÑÐ¾Ð°Ñ‚",
          hh: "%d ÑÐ¾Ð°Ñ‚",
          d: "ÑÐº Ñ€Ó¯Ð·",
          dd: "%d Ñ€Ó¯Ð·",
          M: "ÑÐº Ð¼Ð¾Ò³",
          MM: "%d Ð¼Ð¾Ò³",
          y: "ÑÐº ÑÐ¾Ð»",
          yy: "%d ÑÐ¾Ð»"
        },
        meridiemParse: /ÑˆÐ°Ð±|ÑÑƒÐ±Ò³|Ñ€Ó¯Ð·|Ð±ÐµÐ³Ð¾Ò³/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "ÑˆÐ°Ð±") {
            return hour < 4 ? hour : hour + 12;
          } else if (meridiem2 === "ÑÑƒÐ±Ò³") {
            return hour;
          } else if (meridiem2 === "Ñ€Ó¯Ð·") {
            return hour >= 11 ? hour : hour + 12;
          } else if (meridiem2 === "Ð±ÐµÐ³Ð¾Ò³") {
            return hour + 12;
          }
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "ÑˆÐ°Ð±";
          } else if (hour < 11) {
            return "ÑÑƒÐ±Ò³";
          } else if (hour < 16) {
            return "Ñ€Ó¯Ð·";
          } else if (hour < 19) {
            return "Ð±ÐµÐ³Ð¾Ò³";
          } else {
            return "ÑˆÐ°Ð±";
          }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ÑƒÐ¼|ÑŽÐ¼)/,
        ordinal: function(number2) {
          var a = number2 % 10, b = number2 >= 100 ? 100 : null;
          return number2 + (suffixes$3[number2] || suffixes$3[a] || suffixes$3[b]);
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 1th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("th", {
        months: "à¸¡à¸à¸£à¸²à¸„à¸¡_à¸à¸¸à¸¡à¸ à¸²à¸žà¸±à¸™à¸˜à¹Œ_à¸¡à¸µà¸™à¸²à¸„à¸¡_à¹€à¸¡à¸©à¸²à¸¢à¸™_à¸žà¸¤à¸©à¸ à¸²à¸„à¸¡_à¸¡à¸´à¸–à¸¸à¸™à¸²à¸¢à¸™_à¸à¸£à¸à¸Žà¸²à¸„à¸¡_à¸ªà¸´à¸‡à¸«à¸²à¸„à¸¡_à¸à¸±à¸™à¸¢à¸²à¸¢à¸™_à¸•à¸¸à¸¥à¸²à¸„à¸¡_à¸žà¸¤à¸¨à¸ˆà¸´à¸à¸²à¸¢à¸™_à¸˜à¸±à¸™à¸§à¸²à¸„à¸¡".split(
          "_"
        ),
        monthsShort: "à¸¡.à¸„._à¸.à¸ž._à¸¡à¸µ.à¸„._à¹€à¸¡.à¸¢._à¸ž.à¸„._à¸¡à¸´.à¸¢._à¸.à¸„._à¸ª.à¸„._à¸.à¸¢._à¸•.à¸„._à¸ž.à¸¢._à¸˜.à¸„.".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "à¸­à¸²à¸—à¸´à¸•à¸¢à¹Œ_à¸ˆà¸±à¸™à¸—à¸£à¹Œ_à¸­à¸±à¸‡à¸„à¸²à¸£_à¸žà¸¸à¸˜_à¸žà¸¤à¸«à¸±à¸ªà¸šà¸”à¸µ_à¸¨à¸¸à¸à¸£à¹Œ_à¹€à¸ªà¸²à¸£à¹Œ".split("_"),
        weekdaysShort: "à¸­à¸²à¸—à¸´à¸•à¸¢à¹Œ_à¸ˆà¸±à¸™à¸—à¸£à¹Œ_à¸­à¸±à¸‡à¸„à¸²à¸£_à¸žà¸¸à¸˜_à¸žà¸¤à¸«à¸±à¸ª_à¸¨à¸¸à¸à¸£à¹Œ_à¹€à¸ªà¸²à¸£à¹Œ".split("_"),
        // yes, three characters difference
        weekdaysMin: "à¸­à¸²._à¸ˆ._à¸­._à¸ž._à¸žà¸¤._à¸¨._à¸ª.".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY à¹€à¸§à¸¥à¸² H:mm",
          LLLL: "à¸§à¸±à¸™ddddà¸—à¸µà¹ˆ D MMMM YYYY à¹€à¸§à¸¥à¸² H:mm"
        },
        meridiemParse: /à¸à¹ˆà¸­à¸™à¹€à¸—à¸µà¹ˆà¸¢à¸‡|à¸«à¸¥à¸±à¸‡à¹€à¸—à¸µà¹ˆà¸¢à¸‡/,
        isPM: function(input) {
          return input === "à¸«à¸¥à¸±à¸‡à¹€à¸—à¸µà¹ˆà¸¢à¸‡";
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 12) {
            return "à¸à¹ˆà¸­à¸™à¹€à¸—à¸µà¹ˆà¸¢à¸‡";
          } else {
            return "à¸«à¸¥à¸±à¸‡à¹€à¸—à¸µà¹ˆà¸¢à¸‡";
          }
        },
        calendar: {
          sameDay: "[à¸§à¸±à¸™à¸™à¸µà¹‰ à¹€à¸§à¸¥à¸²] LT",
          nextDay: "[à¸žà¸£à¸¸à¹ˆà¸‡à¸™à¸µà¹‰ à¹€à¸§à¸¥à¸²] LT",
          nextWeek: "dddd[à¸«à¸™à¹‰à¸² à¹€à¸§à¸¥à¸²] LT",
          lastDay: "[à¹€à¸¡à¸·à¹ˆà¸­à¸§à¸²à¸™à¸™à¸µà¹‰ à¹€à¸§à¸¥à¸²] LT",
          lastWeek: "[à¸§à¸±à¸™]dddd[à¸—à¸µà¹ˆà¹à¸¥à¹‰à¸§ à¹€à¸§à¸¥à¸²] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "à¸­à¸µà¸ %s",
          past: "%sà¸—à¸µà¹ˆà¹à¸¥à¹‰à¸§",
          s: "à¹„à¸¡à¹ˆà¸à¸µà¹ˆà¸§à¸´à¸™à¸²à¸—à¸µ",
          ss: "%d à¸§à¸´à¸™à¸²à¸—à¸µ",
          m: "1 à¸™à¸²à¸—à¸µ",
          mm: "%d à¸™à¸²à¸—à¸µ",
          h: "1 à¸Šà¸±à¹ˆà¸§à¹‚à¸¡à¸‡",
          hh: "%d à¸Šà¸±à¹ˆà¸§à¹‚à¸¡à¸‡",
          d: "1 à¸§à¸±à¸™",
          dd: "%d à¸§à¸±à¸™",
          w: "1 à¸ªà¸±à¸›à¸”à¸²à¸«à¹Œ",
          ww: "%d à¸ªà¸±à¸›à¸”à¸²à¸«à¹Œ",
          M: "1 à¹€à¸”à¸·à¸­à¸™",
          MM: "%d à¹€à¸”à¸·à¸­à¸™",
          y: "1 à¸›à¸µ",
          yy: "%d à¸›à¸µ"
        }
      });
      //! moment.js locale configuration
      var suffixes$4 = {
        1: "'inji",
        5: "'inji",
        8: "'inji",
        70: "'inji",
        80: "'inji",
        2: "'nji",
        7: "'nji",
        20: "'nji",
        50: "'nji",
        3: "'Ã¼nji",
        4: "'Ã¼nji",
        100: "'Ã¼nji",
        6: "'njy",
        9: "'unjy",
        10: "'unjy",
        30: "'unjy",
        60: "'ynjy",
        90: "'ynjy"
      };
      hooks.defineLocale("tk", {
        months: "Ãanwar_Fewral_Mart_Aprel_MaÃ½_IÃ½un_IÃ½ul_Awgust_SentÃ½abr_OktÃ½abr_NoÃ½abr_Dekabr".split(
          "_"
        ),
        monthsShort: "Ãan_Few_Mar_Apr_MaÃ½_IÃ½n_IÃ½l_Awg_Sen_Okt_NoÃ½_Dek".split("_"),
        weekdays: "ÃekÅŸenbe_DuÅŸenbe_SiÅŸenbe_Ã‡arÅŸenbe_PenÅŸenbe_Anna_Åženbe".split(
          "_"
        ),
        weekdaysShort: "Ãek_DuÅŸ_SiÅŸ_Ã‡ar_Pen_Ann_Åžen".split("_"),
        weekdaysMin: "Ãk_DÅŸ_SÅŸ_Ã‡r_Pn_An_Åžn".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[bugÃ¼n sagat] LT",
          nextDay: "[ertir sagat] LT",
          nextWeek: "[indiki] dddd [sagat] LT",
          lastDay: "[dÃ¼Ã½n] LT",
          lastWeek: "[geÃ§en] dddd [sagat] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s soÅˆ",
          past: "%s Ã¶Åˆ",
          s: "birnÃ¤Ã§e sekunt",
          m: "bir minut",
          mm: "%d minut",
          h: "bir sagat",
          hh: "%d sagat",
          d: "bir gÃ¼n",
          dd: "%d gÃ¼n",
          M: "bir aÃ½",
          MM: "%d aÃ½",
          y: "bir Ã½yl",
          yy: "%d Ã½yl"
        },
        ordinal: function(number2, period) {
          switch (period) {
            case "d":
            case "D":
            case "Do":
            case "DD":
              return number2;
            default:
              if (number2 === 0) {
                return number2 + "'unjy";
              }
              var a = number2 % 10, b = number2 % 100 - a, c = number2 >= 100 ? 100 : null;
              return number2 + (suffixes$4[a] || suffixes$4[b] || suffixes$4[c]);
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("tl-ph", {
        months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split(
          "_"
        ),
        monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
        weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split(
          "_"
        ),
        weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
        weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "MM/D/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY HH:mm",
          LLLL: "dddd, MMMM DD, YYYY HH:mm"
        },
        calendar: {
          sameDay: "LT [ngayong araw]",
          nextDay: "[Bukas ng] LT",
          nextWeek: "LT [sa susunod na] dddd",
          lastDay: "LT [kahapon]",
          lastWeek: "LT [noong nakaraang] dddd",
          sameElse: "L"
        },
        relativeTime: {
          future: "sa loob ng %s",
          past: "%s ang nakalipas",
          s: "ilang segundo",
          ss: "%d segundo",
          m: "isang minuto",
          mm: "%d minuto",
          h: "isang oras",
          hh: "%d oras",
          d: "isang araw",
          dd: "%d araw",
          M: "isang buwan",
          MM: "%d buwan",
          y: "isang taon",
          yy: "%d taon"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function(number2) {
          return number2;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var numbersNouns = "pagh_waâ€™_chaâ€™_wej_loS_vagh_jav_Soch_chorgh_Hut".split("_");
      function translateFuture(output) {
        var time = output;
        time = output.indexOf("jaj") !== -1 ? time.slice(0, -3) + "leS" : output.indexOf("jar") !== -1 ? time.slice(0, -3) + "waQ" : output.indexOf("DIS") !== -1 ? time.slice(0, -3) + "nem" : time + " pIq";
        return time;
      }
      function translatePast(output) {
        var time = output;
        time = output.indexOf("jaj") !== -1 ? time.slice(0, -3) + "Huâ€™" : output.indexOf("jar") !== -1 ? time.slice(0, -3) + "wen" : output.indexOf("DIS") !== -1 ? time.slice(0, -3) + "ben" : time + " ret";
        return time;
      }
      function translate$a(number2, withoutSuffix, string2, isFuture) {
        var numberNoun = numberAsNoun(number2);
        switch (string2) {
          case "ss":
            return numberNoun + " lup";
          case "mm":
            return numberNoun + " tup";
          case "hh":
            return numberNoun + " rep";
          case "dd":
            return numberNoun + " jaj";
          case "MM":
            return numberNoun + " jar";
          case "yy":
            return numberNoun + " DIS";
        }
      }
      function numberAsNoun(number2) {
        var hundred = Math.floor(number2 % 1e3 / 100), ten = Math.floor(number2 % 100 / 10), one2 = number2 % 10, word = "";
        if (hundred > 0) {
          word += numbersNouns[hundred] + "vatlh";
        }
        if (ten > 0) {
          word += (word !== "" ? " " : "") + numbersNouns[ten] + "maH";
        }
        if (one2 > 0) {
          word += (word !== "" ? " " : "") + numbersNouns[one2];
        }
        return word === "" ? "pagh" : word;
      }
      hooks.defineLocale("tlh", {
        months: "teraâ€™ jar waâ€™_teraâ€™ jar chaâ€™_teraâ€™ jar wej_teraâ€™ jar loS_teraâ€™ jar vagh_teraâ€™ jar jav_teraâ€™ jar Soch_teraâ€™ jar chorgh_teraâ€™ jar Hut_teraâ€™ jar waâ€™maH_teraâ€™ jar waâ€™maH waâ€™_teraâ€™ jar waâ€™maH chaâ€™".split(
          "_"
        ),
        monthsShort: "jar waâ€™_jar chaâ€™_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar waâ€™maH_jar waâ€™maH waâ€™_jar waâ€™maH chaâ€™".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split(
          "_"
        ),
        weekdaysShort: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
        weekdaysMin: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[DaHjaj] LT",
          nextDay: "[waâ€™leS] LT",
          nextWeek: "LLL",
          lastDay: "[waâ€™Huâ€™] LT",
          lastWeek: "LLL",
          sameElse: "L"
        },
        relativeTime: {
          future: translateFuture,
          past: translatePast,
          s: "puS lup",
          ss: translate$a,
          m: "waâ€™ tup",
          mm: translate$a,
          h: "waâ€™ rep",
          hh: translate$a,
          d: "waâ€™ jaj",
          dd: translate$a,
          M: "waâ€™ jar",
          MM: translate$a,
          y: "waâ€™ DIS",
          yy: translate$a
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var suffixes$5 = {
        1: "'inci",
        5: "'inci",
        8: "'inci",
        70: "'inci",
        80: "'inci",
        2: "'nci",
        7: "'nci",
        20: "'nci",
        50: "'nci",
        3: "'Ã¼ncÃ¼",
        4: "'Ã¼ncÃ¼",
        100: "'Ã¼ncÃ¼",
        6: "'ncÄ±",
        9: "'uncu",
        10: "'uncu",
        30: "'uncu",
        60: "'Ä±ncÄ±",
        90: "'Ä±ncÄ±"
      };
      hooks.defineLocale("tr", {
        months: "Ocak_Åžubat_Mart_Nisan_MayÄ±s_Haziran_Temmuz_AÄŸustos_EylÃ¼l_Ekim_KasÄ±m_AralÄ±k".split(
          "_"
        ),
        monthsShort: "Oca_Åžub_Mar_Nis_May_Haz_Tem_AÄŸu_Eyl_Eki_Kas_Ara".split("_"),
        weekdays: "Pazar_Pazartesi_SalÄ±_Ã‡arÅŸamba_PerÅŸembe_Cuma_Cumartesi".split(
          "_"
        ),
        weekdaysShort: "Paz_Pzt_Sal_Ã‡ar_Per_Cum_Cmt".split("_"),
        weekdaysMin: "Pz_Pt_Sa_Ã‡a_Pe_Cu_Ct".split("_"),
        meridiem: function(hours2, minutes2, isLower) {
          if (hours2 < 12) {
            return isLower ? "Ã¶Ã¶" : "Ã–Ã–";
          } else {
            return isLower ? "Ã¶s" : "Ã–S";
          }
        },
        meridiemParse: /Ã¶Ã¶|Ã–Ã–|Ã¶s|Ã–S/,
        isPM: function(input) {
          return input === "Ã¶s" || input === "Ã–S";
        },
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[bugÃ¼n saat] LT",
          nextDay: "[yarÄ±n saat] LT",
          nextWeek: "[gelecek] dddd [saat] LT",
          lastDay: "[dÃ¼n] LT",
          lastWeek: "[geÃ§en] dddd [saat] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s sonra",
          past: "%s Ã¶nce",
          s: "birkaÃ§ saniye",
          ss: "%d saniye",
          m: "bir dakika",
          mm: "%d dakika",
          h: "bir saat",
          hh: "%d saat",
          d: "bir gÃ¼n",
          dd: "%d gÃ¼n",
          w: "bir hafta",
          ww: "%d hafta",
          M: "bir ay",
          MM: "%d ay",
          y: "bir yÄ±l",
          yy: "%d yÄ±l"
        },
        ordinal: function(number2, period) {
          switch (period) {
            case "d":
            case "D":
            case "Do":
            case "DD":
              return number2;
            default:
              if (number2 === 0) {
                return number2 + "'Ä±ncÄ±";
              }
              var a = number2 % 10, b = number2 % 100 - a, c = number2 >= 100 ? 100 : null;
              return number2 + (suffixes$5[a] || suffixes$5[b] || suffixes$5[c]);
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("tzl", {
        months: "Januar_Fevraglh_MarÃ§_AvrÃ¯u_Mai_GÃ¼n_Julia_Guscht_Setemvar_ListopÃ¤ts_Noemvar_Zecemvar".split(
          "_"
        ),
        monthsShort: "Jan_Fev_Mar_Avr_Mai_GÃ¼n_Jul_Gus_Set_Lis_Noe_Zec".split("_"),
        weekdays: "SÃºladi_LÃºneÃ§i_Maitzi_MÃ¡rcuri_XhÃºadi_ViÃ©nerÃ§i_SÃ¡turi".split("_"),
        weekdaysShort: "SÃºl_LÃºn_Mai_MÃ¡r_XhÃº_ViÃ©_SÃ¡t".split("_"),
        weekdaysMin: "SÃº_LÃº_Ma_MÃ¡_Xh_Vi_SÃ¡".split("_"),
        longDateFormat: {
          LT: "HH.mm",
          LTS: "HH.mm.ss",
          L: "DD.MM.YYYY",
          LL: "D. MMMM [dallas] YYYY",
          LLL: "D. MMMM [dallas] YYYY HH.mm",
          LLLL: "dddd, [li] D. MMMM [dallas] YYYY HH.mm"
        },
        meridiemParse: /d\'o|d\'a/i,
        isPM: function(input) {
          return "d'o" === input.toLowerCase();
        },
        meridiem: function(hours2, minutes2, isLower) {
          if (hours2 > 11) {
            return isLower ? "d'o" : "D'O";
          } else {
            return isLower ? "d'a" : "D'A";
          }
        },
        calendar: {
          sameDay: "[oxhi Ã ] LT",
          nextDay: "[demÃ  Ã ] LT",
          nextWeek: "dddd [Ã ] LT",
          lastDay: "[ieiri Ã ] LT",
          lastWeek: "[sÃ¼r el] dddd [lasteu Ã ] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "osprei %s",
          past: "ja%s",
          s: processRelativeTime$a,
          ss: processRelativeTime$a,
          m: processRelativeTime$a,
          mm: processRelativeTime$a,
          h: processRelativeTime$a,
          hh: processRelativeTime$a,
          d: processRelativeTime$a,
          dd: processRelativeTime$a,
          M: processRelativeTime$a,
          MM: processRelativeTime$a,
          y: processRelativeTime$a,
          yy: processRelativeTime$a
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      function processRelativeTime$a(number2, withoutSuffix, key, isFuture) {
        var format2 = {
          s: ["viensas secunds", "'iensas secunds"],
          ss: [number2 + " secunds", "" + number2 + " secunds"],
          m: ["'n mÃ­ut", "'iens mÃ­ut"],
          mm: [number2 + " mÃ­uts", "" + number2 + " mÃ­uts"],
          h: ["'n Ã¾ora", "'iensa Ã¾ora"],
          hh: [number2 + " Ã¾oras", "" + number2 + " Ã¾oras"],
          d: ["'n ziua", "'iensa ziua"],
          dd: [number2 + " ziuas", "" + number2 + " ziuas"],
          M: ["'n mes", "'iens mes"],
          MM: [number2 + " mesen", "" + number2 + " mesen"],
          y: ["'n ar", "'iens ar"],
          yy: [number2 + " ars", "" + number2 + " ars"]
        };
        return isFuture ? format2[key][0] : withoutSuffix ? format2[key][0] : format2[key][1];
      }
      //! moment.js locale configuration
      hooks.defineLocale("tzm-latn", {
        months: "innayr_brË¤ayrË¤_marË¤sË¤_ibrir_mayyw_ywnyw_ywlywz_É£wÅ¡t_Å¡wtanbir_ktË¤wbrË¤_nwwanbir_dwjnbir".split(
          "_"
        ),
        monthsShort: "innayr_brË¤ayrË¤_marË¤sË¤_ibrir_mayyw_ywnyw_ywlywz_É£wÅ¡t_Å¡wtanbir_ktË¤wbrË¤_nwwanbir_dwjnbir".split(
          "_"
        ),
        weekdays: "asamas_aynas_asinas_akras_akwas_asimwas_asiá¸yas".split("_"),
        weekdaysShort: "asamas_aynas_asinas_akras_akwas_asimwas_asiá¸yas".split("_"),
        weekdaysMin: "asamas_aynas_asinas_akras_akwas_asimwas_asiá¸yas".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[asdkh g] LT",
          nextDay: "[aska g] LT",
          nextWeek: "dddd [g] LT",
          lastDay: "[assant g] LT",
          lastWeek: "dddd [g] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "dadkh s yan %s",
          past: "yan %s",
          s: "imik",
          ss: "%d imik",
          m: "minuá¸",
          mm: "%d minuá¸",
          h: "saÉ›a",
          hh: "%d tassaÉ›in",
          d: "ass",
          dd: "%d ossan",
          M: "ayowr",
          MM: "%d iyyirn",
          y: "asgas",
          yy: "%d isgasn"
        },
        week: {
          dow: 6,
          // Saturday is the first day of the week.
          doy: 12
          // The week that contains Jan 12th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("tzm", {
        months: "âµ‰âµâµâ´°âµ¢âµ”_â´±âµ•â´°âµ¢âµ•_âµŽâ´°âµ•âµš_âµ‰â´±âµ”âµ‰âµ”_âµŽâ´°âµ¢âµ¢âµ“_âµ¢âµ“âµâµ¢âµ“_âµ¢âµ“âµâµ¢âµ“âµ£_âµ–âµ“âµ›âµœ_âµ›âµ“âµœâ´°âµâ´±âµ‰âµ”_â´½âµŸâµ“â´±âµ•_âµâµ“âµ¡â´°âµâ´±âµ‰âµ”_â´·âµ“âµŠâµâ´±âµ‰âµ”".split(
          "_"
        ),
        monthsShort: "âµ‰âµâµâ´°âµ¢âµ”_â´±âµ•â´°âµ¢âµ•_âµŽâ´°âµ•âµš_âµ‰â´±âµ”âµ‰âµ”_âµŽâ´°âµ¢âµ¢âµ“_âµ¢âµ“âµâµ¢âµ“_âµ¢âµ“âµâµ¢âµ“âµ£_âµ–âµ“âµ›âµœ_âµ›âµ“âµœâ´°âµâ´±âµ‰âµ”_â´½âµŸâµ“â´±âµ•_âµâµ“âµ¡â´°âµâ´±âµ‰âµ”_â´·âµ“âµŠâµâ´±âµ‰âµ”".split(
          "_"
        ),
        weekdays: "â´°âµ™â´°âµŽâ´°âµ™_â´°âµ¢âµâ´°âµ™_â´°âµ™âµ‰âµâ´°âµ™_â´°â´½âµ”â´°âµ™_â´°â´½âµ¡â´°âµ™_â´°âµ™âµ‰âµŽâµ¡â´°âµ™_â´°âµ™âµ‰â´¹âµ¢â´°âµ™".split("_"),
        weekdaysShort: "â´°âµ™â´°âµŽâ´°âµ™_â´°âµ¢âµâ´°âµ™_â´°âµ™âµ‰âµâ´°âµ™_â´°â´½âµ”â´°âµ™_â´°â´½âµ¡â´°âµ™_â´°âµ™âµ‰âµŽâµ¡â´°âµ™_â´°âµ™âµ‰â´¹âµ¢â´°âµ™".split("_"),
        weekdaysMin: "â´°âµ™â´°âµŽâ´°âµ™_â´°âµ¢âµâ´°âµ™_â´°âµ™âµ‰âµâ´°âµ™_â´°â´½âµ”â´°âµ™_â´°â´½âµ¡â´°âµ™_â´°âµ™âµ‰âµŽâµ¡â´°âµ™_â´°âµ™âµ‰â´¹âµ¢â´°âµ™".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[â´°âµ™â´·âµ… â´´] LT",
          nextDay: "[â´°âµ™â´½â´° â´´] LT",
          nextWeek: "dddd [â´´] LT",
          lastDay: "[â´°âµšâ´°âµâµœ â´´] LT",
          lastWeek: "dddd [â´´] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "â´·â´°â´·âµ… âµ™ âµ¢â´°âµ %s",
          past: "âµ¢â´°âµ %s",
          s: "âµ‰âµŽâµ‰â´½",
          ss: "%d âµ‰âµŽâµ‰â´½",
          m: "âµŽâµ‰âµâµ“â´º",
          mm: "%d âµŽâµ‰âµâµ“â´º",
          h: "âµ™â´°âµ„â´°",
          hh: "%d âµœâ´°âµ™âµ™â´°âµ„âµ‰âµ",
          d: "â´°âµ™âµ™",
          dd: "%d oâµ™âµ™â´°âµ",
          M: "â´°âµ¢oâµ“âµ”",
          MM: "%d âµ‰âµ¢âµ¢âµ‰âµ”âµ",
          y: "â´°âµ™â´³â´°âµ™",
          yy: "%d âµ‰âµ™â´³â´°âµ™âµ"
        },
        week: {
          dow: 6,
          // Saturday is the first day of the week.
          doy: 12
          // The week that contains Jan 12th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("ug-cn", {
        months: "ÙŠØ§Ù†Û‹Ø§Ø±_ÙÛÛ‹Ø±Ø§Ù„_Ù…Ø§Ø±Øª_Ø¦Ø§Ù¾Ø±ÛÙ„_Ù…Ø§ÙŠ_Ø¦Ù‰ÙŠÛ‡Ù†_Ø¦Ù‰ÙŠÛ‡Ù„_Ø¦Ø§Û‹ØºÛ‡Ø³Øª_Ø³ÛÙ†ØªÛ•Ø¨Ù‰Ø±_Ø¦Û†ÙƒØªÛ•Ø¨Ù‰Ø±_Ù†ÙˆÙŠØ§Ø¨Ù‰Ø±_Ø¯ÛÙƒØ§Ø¨Ù‰Ø±".split(
          "_"
        ),
        monthsShort: "ÙŠØ§Ù†Û‹Ø§Ø±_ÙÛÛ‹Ø±Ø§Ù„_Ù…Ø§Ø±Øª_Ø¦Ø§Ù¾Ø±ÛÙ„_Ù…Ø§ÙŠ_Ø¦Ù‰ÙŠÛ‡Ù†_Ø¦Ù‰ÙŠÛ‡Ù„_Ø¦Ø§Û‹ØºÛ‡Ø³Øª_Ø³ÛÙ†ØªÛ•Ø¨Ù‰Ø±_Ø¦Û†ÙƒØªÛ•Ø¨Ù‰Ø±_Ù†ÙˆÙŠØ§Ø¨Ù‰Ø±_Ø¯ÛÙƒØ§Ø¨Ù‰Ø±".split(
          "_"
        ),
        weekdays: "ÙŠÛ•ÙƒØ´Û•Ù†Ø¨Û•_Ø¯ÛˆØ´Û•Ù†Ø¨Û•_Ø³Û•ÙŠØ´Û•Ù†Ø¨Û•_Ú†Ø§Ø±Ø´Û•Ù†Ø¨Û•_Ù¾Û•ÙŠØ´Û•Ù†Ø¨Û•_Ø¬ÛˆÙ…Û•_Ø´Û•Ù†Ø¨Û•".split(
          "_"
        ),
        weekdaysShort: "ÙŠÛ•_Ø¯Ûˆ_Ø³Û•_Ú†Ø§_Ù¾Û•_Ø¬Ûˆ_Ø´Û•".split("_"),
        weekdaysMin: "ÙŠÛ•_Ø¯Ûˆ_Ø³Û•_Ú†Ø§_Ù¾Û•_Ø¬Ûˆ_Ø´Û•".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "YYYY-MM-DD",
          LL: "YYYY-ÙŠÙ‰Ù„Ù‰M-Ø¦Ø§ÙŠÙ†Ù‰Ú­D-ÙƒÛˆÙ†Ù‰",
          LLL: "YYYY-ÙŠÙ‰Ù„Ù‰M-Ø¦Ø§ÙŠÙ†Ù‰Ú­D-ÙƒÛˆÙ†Ù‰ØŒ HH:mm",
          LLLL: "ddddØŒ YYYY-ÙŠÙ‰Ù„Ù‰M-Ø¦Ø§ÙŠÙ†Ù‰Ú­D-ÙƒÛˆÙ†Ù‰ØŒ HH:mm"
        },
        meridiemParse: /ÙŠÛØ±Ù‰Ù… ÙƒÛÚ†Û•|Ø³Û•Ú¾Û•Ø±|Ú†ÛˆØ´ØªÙ‰Ù† Ø¨Û‡Ø±Û‡Ù†|Ú†ÛˆØ´|Ú†ÛˆØ´ØªÙ‰Ù† ÙƒÛÙŠÙ‰Ù†|ÙƒÛ•Ú†/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "ÙŠÛØ±Ù‰Ù… ÙƒÛÚ†Û•" || meridiem2 === "Ø³Û•Ú¾Û•Ø±" || meridiem2 === "Ú†ÛˆØ´ØªÙ‰Ù† Ø¨Û‡Ø±Û‡Ù†") {
            return hour;
          } else if (meridiem2 === "Ú†ÛˆØ´ØªÙ‰Ù† ÙƒÛÙŠÙ‰Ù†" || meridiem2 === "ÙƒÛ•Ú†") {
            return hour + 12;
          } else {
            return hour >= 11 ? hour : hour + 12;
          }
        },
        meridiem: function(hour, minute, isLower) {
          var hm = hour * 100 + minute;
          if (hm < 600) {
            return "ÙŠÛØ±Ù‰Ù… ÙƒÛÚ†Û•";
          } else if (hm < 900) {
            return "Ø³Û•Ú¾Û•Ø±";
          } else if (hm < 1130) {
            return "Ú†ÛˆØ´ØªÙ‰Ù† Ø¨Û‡Ø±Û‡Ù†";
          } else if (hm < 1230) {
            return "Ú†ÛˆØ´";
          } else if (hm < 1800) {
            return "Ú†ÛˆØ´ØªÙ‰Ù† ÙƒÛÙŠÙ‰Ù†";
          } else {
            return "ÙƒÛ•Ú†";
          }
        },
        calendar: {
          sameDay: "[Ø¨ÛˆÚ¯ÛˆÙ† Ø³Ø§Ø¦Û•Øª] LT",
          nextDay: "[Ø¦Û•ØªÛ• Ø³Ø§Ø¦Û•Øª] LT",
          nextWeek: "[ÙƒÛÙ„Û•Ø±ÙƒÙ‰] dddd [Ø³Ø§Ø¦Û•Øª] LT",
          lastDay: "[ØªÛ†Ù†ÛˆÚ¯ÛˆÙ†] LT",
          lastWeek: "[Ø¦Ø§Ù„Ø¯Ù‰Ù†Ù‚Ù‰] dddd [Ø³Ø§Ø¦Û•Øª] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s ÙƒÛÙŠÙ‰Ù†",
          past: "%s Ø¨Û‡Ø±Û‡Ù†",
          s: "Ù†Û•Ú†Ú†Û• Ø³ÛÙƒÙˆÙ†Øª",
          ss: "%d Ø³ÛÙƒÙˆÙ†Øª",
          m: "Ø¨Ù‰Ø± Ù…Ù‰Ù†Û‡Øª",
          mm: "%d Ù…Ù‰Ù†Û‡Øª",
          h: "Ø¨Ù‰Ø± Ø³Ø§Ø¦Û•Øª",
          hh: "%d Ø³Ø§Ø¦Û•Øª",
          d: "Ø¨Ù‰Ø± ÙƒÛˆÙ†",
          dd: "%d ÙƒÛˆÙ†",
          M: "Ø¨Ù‰Ø± Ø¦Ø§ÙŠ",
          MM: "%d Ø¦Ø§ÙŠ",
          y: "Ø¨Ù‰Ø± ÙŠÙ‰Ù„",
          yy: "%d ÙŠÙ‰Ù„"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(-ÙƒÛˆÙ†Ù‰|-Ø¦Ø§ÙŠ|-Ú¾Û•Ù¾ØªÛ•)/,
        ordinal: function(number2, period) {
          switch (period) {
            case "d":
            case "D":
            case "DDD":
              return number2 + "-ÙƒÛˆÙ†Ù‰";
            case "w":
            case "W":
              return number2 + "-Ú¾Û•Ù¾ØªÛ•";
            default:
              return number2;
          }
        },
        preparse: function(string2) {
          return string2.replace(/ØŒ/g, ",");
        },
        postformat: function(string2) {
          return string2.replace(/,/g, "ØŒ");
        },
        week: {
          // GB/T 7408-1994ã€Šæ•°æ®å…ƒå’Œäº¤æ¢æ ¼å¼Â·ä¿¡æ¯äº¤æ¢Â·æ—¥æœŸå’Œæ—¶é—´è¡¨ç¤ºæ³•ã€‹ä¸ŽISO 8601:1988ç­‰æ•ˆ
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 1st is the first week of the year.
        }
      });
      //! moment.js locale configuration
      function plural$6(word, num) {
        var forms2 = word.split("_");
        return num % 10 === 1 && num % 100 !== 11 ? forms2[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms2[1] : forms2[2];
      }
      function relativeTimeWithPlural$4(number2, withoutSuffix, key) {
        var format2 = {
          ss: withoutSuffix ? "ÑÐµÐºÑƒÐ½Ð´Ð°_ÑÐµÐºÑƒÐ½Ð´Ð¸_ÑÐµÐºÑƒÐ½Ð´" : "ÑÐµÐºÑƒÐ½Ð´Ñƒ_ÑÐµÐºÑƒÐ½Ð´Ð¸_ÑÐµÐºÑƒÐ½Ð´",
          mm: withoutSuffix ? "Ñ…Ð²Ð¸Ð»Ð¸Ð½Ð°_Ñ…Ð²Ð¸Ð»Ð¸Ð½Ð¸_Ñ…Ð²Ð¸Ð»Ð¸Ð½" : "Ñ…Ð²Ð¸Ð»Ð¸Ð½Ñƒ_Ñ…Ð²Ð¸Ð»Ð¸Ð½Ð¸_Ñ…Ð²Ð¸Ð»Ð¸Ð½",
          hh: withoutSuffix ? "Ð³Ð¾Ð´Ð¸Ð½Ð°_Ð³Ð¾Ð´Ð¸Ð½Ð¸_Ð³Ð¾Ð´Ð¸Ð½" : "Ð³Ð¾Ð´Ð¸Ð½Ñƒ_Ð³Ð¾Ð´Ð¸Ð½Ð¸_Ð³Ð¾Ð´Ð¸Ð½",
          dd: "Ð´ÐµÐ½ÑŒ_Ð´Ð½Ñ–_Ð´Ð½Ñ–Ð²",
          MM: "Ð¼Ñ–ÑÑÑ†ÑŒ_Ð¼Ñ–ÑÑÑ†Ñ–_Ð¼Ñ–ÑÑÑ†Ñ–Ð²",
          yy: "Ñ€Ñ–Ðº_Ñ€Ð¾ÐºÐ¸_Ñ€Ð¾ÐºÑ–Ð²"
        };
        if (key === "m") {
          return withoutSuffix ? "Ñ…Ð²Ð¸Ð»Ð¸Ð½Ð°" : "Ñ…Ð²Ð¸Ð»Ð¸Ð½Ñƒ";
        } else if (key === "h") {
          return withoutSuffix ? "Ð³Ð¾Ð´Ð¸Ð½Ð°" : "Ð³Ð¾Ð´Ð¸Ð½Ñƒ";
        } else {
          return number2 + " " + plural$6(format2[key], +number2);
        }
      }
      function weekdaysCaseReplace(m2, format2) {
        var weekdays2 = {
          nominative: "Ð½ÐµÐ´Ñ–Ð»Ñ_Ð¿Ð¾Ð½ÐµÐ´Ñ–Ð»Ð¾Ðº_Ð²Ñ–Ð²Ñ‚Ð¾Ñ€Ð¾Ðº_ÑÐµÑ€ÐµÐ´Ð°_Ñ‡ÐµÑ‚Ð²ÐµÑ€_Ð¿â€™ÑÑ‚Ð½Ð¸Ñ†Ñ_ÑÑƒÐ±Ð¾Ñ‚Ð°".split(
            "_"
          ),
          accusative: "Ð½ÐµÐ´Ñ–Ð»ÑŽ_Ð¿Ð¾Ð½ÐµÐ´Ñ–Ð»Ð¾Ðº_Ð²Ñ–Ð²Ñ‚Ð¾Ñ€Ð¾Ðº_ÑÐµÑ€ÐµÐ´Ñƒ_Ñ‡ÐµÑ‚Ð²ÐµÑ€_Ð¿â€™ÑÑ‚Ð½Ð¸Ñ†ÑŽ_ÑÑƒÐ±Ð¾Ñ‚Ñƒ".split(
            "_"
          ),
          genitive: "Ð½ÐµÐ´Ñ–Ð»Ñ–_Ð¿Ð¾Ð½ÐµÐ´Ñ–Ð»ÐºÐ°_Ð²Ñ–Ð²Ñ‚Ð¾Ñ€ÐºÐ°_ÑÐµÑ€ÐµÐ´Ð¸_Ñ‡ÐµÑ‚Ð²ÐµÑ€Ð³Ð°_Ð¿â€™ÑÑ‚Ð½Ð¸Ñ†Ñ–_ÑÑƒÐ±Ð¾Ñ‚Ð¸".split(
            "_"
          )
        }, nounCase;
        if (m2 === true) {
          return weekdays2["nominative"].slice(1, 7).concat(weekdays2["nominative"].slice(0, 1));
        }
        if (!m2) {
          return weekdays2["nominative"];
        }
        nounCase = /(\[[Ð’Ð²Ð£Ñƒ]\]) ?dddd/.test(format2) ? "accusative" : /\[?(?:Ð¼Ð¸Ð½ÑƒÐ»Ð¾Ñ—|Ð½Ð°ÑÑ‚ÑƒÐ¿Ð½Ð¾Ñ—)? ?\] ?dddd/.test(format2) ? "genitive" : "nominative";
        return weekdays2[nounCase][m2.day()];
      }
      function processHoursFunction(str) {
        return function() {
          return str + "Ð¾" + (this.hours() === 11 ? "Ð±" : "") + "] LT";
        };
      }
      hooks.defineLocale("uk", {
        months: {
          format: "ÑÑ–Ñ‡Ð½Ñ_Ð»ÑŽÑ‚Ð¾Ð³Ð¾_Ð±ÐµÑ€ÐµÐ·Ð½Ñ_ÐºÐ²Ñ–Ñ‚Ð½Ñ_Ñ‚Ñ€Ð°Ð²Ð½Ñ_Ñ‡ÐµÑ€Ð²Ð½Ñ_Ð»Ð¸Ð¿Ð½Ñ_ÑÐµÑ€Ð¿Ð½Ñ_Ð²ÐµÑ€ÐµÑÐ½Ñ_Ð¶Ð¾Ð²Ñ‚Ð½Ñ_Ð»Ð¸ÑÑ‚Ð¾Ð¿Ð°Ð´Ð°_Ð³Ñ€ÑƒÐ´Ð½Ñ".split(
            "_"
          ),
          standalone: "ÑÑ–Ñ‡ÐµÐ½ÑŒ_Ð»ÑŽÑ‚Ð¸Ð¹_Ð±ÐµÑ€ÐµÐ·ÐµÐ½ÑŒ_ÐºÐ²Ñ–Ñ‚ÐµÐ½ÑŒ_Ñ‚Ñ€Ð°Ð²ÐµÐ½ÑŒ_Ñ‡ÐµÑ€Ð²ÐµÐ½ÑŒ_Ð»Ð¸Ð¿ÐµÐ½ÑŒ_ÑÐµÑ€Ð¿ÐµÐ½ÑŒ_Ð²ÐµÑ€ÐµÑÐµÐ½ÑŒ_Ð¶Ð¾Ð²Ñ‚ÐµÐ½ÑŒ_Ð»Ð¸ÑÑ‚Ð¾Ð¿Ð°Ð´_Ð³Ñ€ÑƒÐ´ÐµÐ½ÑŒ".split(
            "_"
          )
        },
        monthsShort: "ÑÑ–Ñ‡_Ð»ÑŽÑ‚_Ð±ÐµÑ€_ÐºÐ²Ñ–Ñ‚_Ñ‚Ñ€Ð°Ð²_Ñ‡ÐµÑ€Ð²_Ð»Ð¸Ð¿_ÑÐµÑ€Ð¿_Ð²ÐµÑ€_Ð¶Ð¾Ð²Ñ‚_Ð»Ð¸ÑÑ‚_Ð³Ñ€ÑƒÐ´".split(
          "_"
        ),
        weekdays: weekdaysCaseReplace,
        weekdaysShort: "Ð½Ð´_Ð¿Ð½_Ð²Ñ‚_ÑÑ€_Ñ‡Ñ‚_Ð¿Ñ‚_ÑÐ±".split("_"),
        weekdaysMin: "Ð½Ð´_Ð¿Ð½_Ð²Ñ‚_ÑÑ€_Ñ‡Ñ‚_Ð¿Ñ‚_ÑÐ±".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY Ñ€.",
          LLL: "D MMMM YYYY Ñ€., HH:mm",
          LLLL: "dddd, D MMMM YYYY Ñ€., HH:mm"
        },
        calendar: {
          sameDay: processHoursFunction("[Ð¡ÑŒÐ¾Ð³Ð¾Ð´Ð½Ñ– "),
          nextDay: processHoursFunction("[Ð—Ð°Ð²Ñ‚Ñ€Ð° "),
          lastDay: processHoursFunction("[Ð’Ñ‡Ð¾Ñ€Ð° "),
          nextWeek: processHoursFunction("[Ð£] dddd ["),
          lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
              case 5:
              case 6:
                return processHoursFunction("[ÐœÐ¸Ð½ÑƒÐ»Ð¾Ñ—] dddd [").call(this);
              case 1:
              case 2:
              case 4:
                return processHoursFunction("[ÐœÐ¸Ð½ÑƒÐ»Ð¾Ð³Ð¾] dddd [").call(this);
            }
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "Ð·Ð° %s",
          past: "%s Ñ‚Ð¾Ð¼Ñƒ",
          s: "Ð´ÐµÐºÑ–Ð»ÑŒÐºÐ° ÑÐµÐºÑƒÐ½Ð´",
          ss: relativeTimeWithPlural$4,
          m: relativeTimeWithPlural$4,
          mm: relativeTimeWithPlural$4,
          h: "Ð³Ð¾Ð´Ð¸Ð½Ñƒ",
          hh: relativeTimeWithPlural$4,
          d: "Ð´ÐµÐ½ÑŒ",
          dd: relativeTimeWithPlural$4,
          M: "Ð¼Ñ–ÑÑÑ†ÑŒ",
          MM: relativeTimeWithPlural$4,
          y: "Ñ€Ñ–Ðº",
          yy: relativeTimeWithPlural$4
        },
        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
        meridiemParse: /Ð½Ð¾Ñ‡Ñ–|Ñ€Ð°Ð½ÐºÑƒ|Ð´Ð½Ñ|Ð²ÐµÑ‡Ð¾Ñ€Ð°/,
        isPM: function(input) {
          return /^(Ð´Ð½Ñ|Ð²ÐµÑ‡Ð¾Ñ€Ð°)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "Ð½Ð¾Ñ‡Ñ–";
          } else if (hour < 12) {
            return "Ñ€Ð°Ð½ÐºÑƒ";
          } else if (hour < 17) {
            return "Ð´Ð½Ñ";
          } else {
            return "Ð²ÐµÑ‡Ð¾Ñ€Ð°";
          }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(Ð¹|Ð³Ð¾)/,
        ordinal: function(number2, period) {
          switch (period) {
            case "M":
            case "d":
            case "DDD":
            case "w":
            case "W":
              return number2 + "-Ð¹";
            case "D":
              return number2 + "-Ð³Ð¾";
            default:
              return number2;
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      var months$b = [
        "Ø¬Ù†ÙˆØ±ÛŒ",
        "ÙØ±ÙˆØ±ÛŒ",
        "Ù…Ø§Ø±Ú†",
        "Ø§Ù¾Ø±ÛŒÙ„",
        "Ù…Ø¦ÛŒ",
        "Ø¬ÙˆÙ†",
        "Ø¬ÙˆÙ„Ø§Ø¦ÛŒ",
        "Ø§Ú¯Ø³Øª",
        "Ø³ØªÙ…Ø¨Ø±",
        "Ø§Ú©ØªÙˆØ¨Ø±",
        "Ù†ÙˆÙ…Ø¨Ø±",
        "Ø¯Ø³Ù…Ø¨Ø±"
      ], days$2 = ["Ø§ØªÙˆØ§Ø±", "Ù¾ÛŒØ±", "Ù…Ù†Ú¯Ù„", "Ø¨Ø¯Ú¾", "Ø¬Ù…Ø¹Ø±Ø§Øª", "Ø¬Ù…Ø¹Û", "ÛÙØªÛ"];
      hooks.defineLocale("ur", {
        months: months$b,
        monthsShort: months$b,
        weekdays: days$2,
        weekdaysShort: days$2,
        weekdaysMin: days$2,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "ddddØŒ D MMMM YYYY HH:mm"
        },
        meridiemParse: /ØµØ¨Ø­|Ø´Ø§Ù…/,
        isPM: function(input) {
          return "Ø´Ø§Ù…" === input;
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 12) {
            return "ØµØ¨Ø­";
          }
          return "Ø´Ø§Ù…";
        },
        calendar: {
          sameDay: "[Ø¢Ø¬ Ø¨ÙˆÙ‚Øª] LT",
          nextDay: "[Ú©Ù„ Ø¨ÙˆÙ‚Øª] LT",
          nextWeek: "dddd [Ø¨ÙˆÙ‚Øª] LT",
          lastDay: "[Ú¯Ø°Ø´ØªÛ Ø±ÙˆØ² Ø¨ÙˆÙ‚Øª] LT",
          lastWeek: "[Ú¯Ø°Ø´ØªÛ] dddd [Ø¨ÙˆÙ‚Øª] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s Ø¨Ø¹Ø¯",
          past: "%s Ù‚Ø¨Ù„",
          s: "Ú†Ù†Ø¯ Ø³ÛŒÚ©Ù†Úˆ",
          ss: "%d Ø³ÛŒÚ©Ù†Úˆ",
          m: "Ø§ÛŒÚ© Ù…Ù†Ù¹",
          mm: "%d Ù…Ù†Ù¹",
          h: "Ø§ÛŒÚ© Ú¯Ú¾Ù†Ù¹Û",
          hh: "%d Ú¯Ú¾Ù†Ù¹Û’",
          d: "Ø§ÛŒÚ© Ø¯Ù†",
          dd: "%d Ø¯Ù†",
          M: "Ø§ÛŒÚ© Ù…Ø§Û",
          MM: "%d Ù…Ø§Û",
          y: "Ø§ÛŒÚ© Ø³Ø§Ù„",
          yy: "%d Ø³Ø§Ù„"
        },
        preparse: function(string2) {
          return string2.replace(/ØŒ/g, ",");
        },
        postformat: function(string2) {
          return string2.replace(/,/g, "ØŒ");
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("uz-latn", {
        months: "Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr".split(
          "_"
        ),
        monthsShort: "Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek".split("_"),
        weekdays: "Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba".split(
          "_"
        ),
        weekdaysShort: "Yak_Dush_Sesh_Chor_Pay_Jum_Shan".split("_"),
        weekdaysMin: "Ya_Du_Se_Cho_Pa_Ju_Sha".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "D MMMM YYYY, dddd HH:mm"
        },
        calendar: {
          sameDay: "[Bugun soat] LT [da]",
          nextDay: "[Ertaga] LT [da]",
          nextWeek: "dddd [kuni soat] LT [da]",
          lastDay: "[Kecha soat] LT [da]",
          lastWeek: "[O'tgan] dddd [kuni soat] LT [da]",
          sameElse: "L"
        },
        relativeTime: {
          future: "Yaqin %s ichida",
          past: "Bir necha %s oldin",
          s: "soniya",
          ss: "%d soniya",
          m: "bir daqiqa",
          mm: "%d daqiqa",
          h: "bir soat",
          hh: "%d soat",
          d: "bir kun",
          dd: "%d kun",
          M: "bir oy",
          MM: "%d oy",
          y: "bir yil",
          yy: "%d yil"
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("uz", {
        months: "ÑÐ½Ð²Ð°Ñ€_Ñ„ÐµÐ²Ñ€Ð°Ð»_Ð¼Ð°Ñ€Ñ‚_Ð°Ð¿Ñ€ÐµÐ»_Ð¼Ð°Ð¹_Ð¸ÑŽÐ½_Ð¸ÑŽÐ»_Ð°Ð²Ð³ÑƒÑÑ‚_ÑÐµÐ½Ñ‚ÑÐ±Ñ€_Ð¾ÐºÑ‚ÑÐ±Ñ€_Ð½Ð¾ÑÐ±Ñ€_Ð´ÐµÐºÐ°Ð±Ñ€".split(
          "_"
        ),
        monthsShort: "ÑÐ½Ð²_Ñ„ÐµÐ²_Ð¼Ð°Ñ€_Ð°Ð¿Ñ€_Ð¼Ð°Ð¹_Ð¸ÑŽÐ½_Ð¸ÑŽÐ»_Ð°Ð²Ð³_ÑÐµÐ½_Ð¾ÐºÑ‚_Ð½Ð¾Ñ_Ð´ÐµÐº".split("_"),
        weekdays: "Ð¯ÐºÑˆÐ°Ð½Ð±Ð°_Ð”ÑƒÑˆÐ°Ð½Ð±Ð°_Ð¡ÐµÑˆÐ°Ð½Ð±Ð°_Ð§Ð¾Ñ€ÑˆÐ°Ð½Ð±Ð°_ÐŸÐ°Ð¹ÑˆÐ°Ð½Ð±Ð°_Ð–ÑƒÐ¼Ð°_Ð¨Ð°Ð½Ð±Ð°".split("_"),
        weekdaysShort: "Ð¯ÐºÑˆ_Ð”ÑƒÑˆ_Ð¡ÐµÑˆ_Ð§Ð¾Ñ€_ÐŸÐ°Ð¹_Ð–ÑƒÐ¼_Ð¨Ð°Ð½".split("_"),
        weekdaysMin: "Ð¯Ðº_Ð”Ñƒ_Ð¡Ðµ_Ð§Ð¾_ÐŸÐ°_Ð–Ñƒ_Ð¨Ð°".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "D MMMM YYYY, dddd HH:mm"
        },
        calendar: {
          sameDay: "[Ð‘ÑƒÐ³ÑƒÐ½ ÑÐ¾Ð°Ñ‚] LT [Ð´Ð°]",
          nextDay: "[Ð­Ñ€Ñ‚Ð°Ð³Ð°] LT [Ð´Ð°]",
          nextWeek: "dddd [ÐºÑƒÐ½Ð¸ ÑÐ¾Ð°Ñ‚] LT [Ð´Ð°]",
          lastDay: "[ÐšÐµÑ‡Ð° ÑÐ¾Ð°Ñ‚] LT [Ð´Ð°]",
          lastWeek: "[Ð£Ñ‚Ð³Ð°Ð½] dddd [ÐºÑƒÐ½Ð¸ ÑÐ¾Ð°Ñ‚] LT [Ð´Ð°]",
          sameElse: "L"
        },
        relativeTime: {
          future: "Ð¯ÐºÐ¸Ð½ %s Ð¸Ñ‡Ð¸Ð´Ð°",
          past: "Ð‘Ð¸Ñ€ Ð½ÐµÑ‡Ð° %s Ð¾Ð»Ð´Ð¸Ð½",
          s: "Ñ„ÑƒÑ€ÑÐ°Ñ‚",
          ss: "%d Ñ„ÑƒÑ€ÑÐ°Ñ‚",
          m: "Ð±Ð¸Ñ€ Ð´Ð°ÐºÐ¸ÐºÐ°",
          mm: "%d Ð´Ð°ÐºÐ¸ÐºÐ°",
          h: "Ð±Ð¸Ñ€ ÑÐ¾Ð°Ñ‚",
          hh: "%d ÑÐ¾Ð°Ñ‚",
          d: "Ð±Ð¸Ñ€ ÐºÑƒÐ½",
          dd: "%d ÐºÑƒÐ½",
          M: "Ð±Ð¸Ñ€ Ð¾Ð¹",
          MM: "%d Ð¾Ð¹",
          y: "Ð±Ð¸Ñ€ Ð¹Ð¸Ð»",
          yy: "%d Ð¹Ð¸Ð»"
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("vi", {
        months: "thÃ¡ng 1_thÃ¡ng 2_thÃ¡ng 3_thÃ¡ng 4_thÃ¡ng 5_thÃ¡ng 6_thÃ¡ng 7_thÃ¡ng 8_thÃ¡ng 9_thÃ¡ng 10_thÃ¡ng 11_thÃ¡ng 12".split(
          "_"
        ),
        monthsShort: "Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "chá»§ nháº­t_thá»© hai_thá»© ba_thá»© tÆ°_thá»© nÄƒm_thá»© sÃ¡u_thá»© báº£y".split(
          "_"
        ),
        weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"),
        weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"),
        weekdaysParseExact: true,
        meridiemParse: /sa|ch/i,
        isPM: function(input) {
          return /^ch$/i.test(input);
        },
        meridiem: function(hours2, minutes2, isLower) {
          if (hours2 < 12) {
            return isLower ? "sa" : "SA";
          } else {
            return isLower ? "ch" : "CH";
          }
        },
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM [nÄƒm] YYYY",
          LLL: "D MMMM [nÄƒm] YYYY HH:mm",
          LLLL: "dddd, D MMMM [nÄƒm] YYYY HH:mm",
          l: "DD/M/YYYY",
          ll: "D MMM YYYY",
          lll: "D MMM YYYY HH:mm",
          llll: "ddd, D MMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[HÃ´m nay lÃºc] LT",
          nextDay: "[NgÃ y mai lÃºc] LT",
          nextWeek: "dddd [tuáº§n tá»›i lÃºc] LT",
          lastDay: "[HÃ´m qua lÃºc] LT",
          lastWeek: "dddd [tuáº§n trÆ°á»›c lÃºc] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s tá»›i",
          past: "%s trÆ°á»›c",
          s: "vÃ i giÃ¢y",
          ss: "%d giÃ¢y",
          m: "má»™t phÃºt",
          mm: "%d phÃºt",
          h: "má»™t giá»",
          hh: "%d giá»",
          d: "má»™t ngÃ y",
          dd: "%d ngÃ y",
          w: "má»™t tuáº§n",
          ww: "%d tuáº§n",
          M: "má»™t thÃ¡ng",
          MM: "%d thÃ¡ng",
          y: "má»™t nÄƒm",
          yy: "%d nÄƒm"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function(number2) {
          return number2;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("x-pseudo", {
        months: "J~Ã¡Ã±ÃºÃ¡~rÃ½_F~Ã©brÃº~Ã¡rÃ½_~MÃ¡rc~h_Ãp~rÃ­l_~MÃ¡Ã½_~JÃºÃ±Ã©~_JÃºl~Ã½_ÃÃº~gÃºst~_SÃ©p~tÃ©mb~Ã©r_Ã“~ctÃ³b~Ã©r_Ã‘~Ã³vÃ©m~bÃ©r_~DÃ©cÃ©~mbÃ©r".split(
          "_"
        ),
        monthsShort: "J~Ã¡Ã±_~FÃ©b_~MÃ¡r_~Ãpr_~MÃ¡Ã½_~JÃºÃ±_~JÃºl_~ÃÃºg_~SÃ©p_~Ã“ct_~Ã‘Ã³v_~DÃ©c".split(
          "_"
        ),
        monthsParseExact: true,
        weekdays: "S~ÃºÃ±dÃ¡~Ã½_MÃ³~Ã±dÃ¡Ã½~_TÃºÃ©~sdÃ¡Ã½~_WÃ©d~Ã±Ã©sd~Ã¡Ã½_T~hÃºrs~dÃ¡Ã½_~FrÃ­d~Ã¡Ã½_S~Ã¡tÃºr~dÃ¡Ã½".split(
          "_"
        ),
        weekdaysShort: "S~ÃºÃ±_~MÃ³Ã±_~TÃºÃ©_~WÃ©d_~ThÃº_~FrÃ­_~SÃ¡t".split("_"),
        weekdaysMin: "S~Ãº_MÃ³~_TÃº_~WÃ©_T~h_Fr~_SÃ¡".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[T~Ã³dÃ¡~Ã½ Ã¡t] LT",
          nextDay: "[T~Ã³mÃ³~rrÃ³~w Ã¡t] LT",
          nextWeek: "dddd [Ã¡t] LT",
          lastDay: "[Ã~Ã©st~Ã©rdÃ¡~Ã½ Ã¡t] LT",
          lastWeek: "[L~Ã¡st] dddd [Ã¡t] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "Ã­~Ã± %s",
          past: "%s Ã¡~gÃ³",
          s: "Ã¡ ~fÃ©w ~sÃ©cÃ³~Ã±ds",
          ss: "%d s~Ã©cÃ³Ã±~ds",
          m: "Ã¡ ~mÃ­Ã±~ÃºtÃ©",
          mm: "%d m~Ã­Ã±Ãº~tÃ©s",
          h: "Ã¡~Ã± hÃ³~Ãºr",
          hh: "%d h~Ã³Ãºrs",
          d: "Ã¡ ~dÃ¡Ã½",
          dd: "%d d~Ã¡Ã½s",
          M: "Ã¡ ~mÃ³Ã±~th",
          MM: "%d m~Ã³Ã±t~hs",
          y: "Ã¡ ~Ã½Ã©Ã¡r",
          yy: "%d Ã½~Ã©Ã¡rs"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number2) {
          var b = number2 % 10, output = ~~(number2 % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number2 + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("yo", {
        months: "Sáº¹Ìráº¹Ì_EÌ€reÌ€leÌ€_áº¸ráº¹Ì€naÌ€_IÌ€gbeÌ_EÌ€bibi_OÌ€kuÌ€du_Agáº¹mo_OÌ€guÌn_Owewe_á»ŒÌ€waÌ€raÌ€_BeÌluÌ_á»ŒÌ€páº¹Ì€Ì€".split(
          "_"
        ),
        monthsShort: "Sáº¹Ìr_EÌ€rl_áº¸rn_IÌ€gb_EÌ€bi_OÌ€kuÌ€_Agáº¹_OÌ€guÌ_Owe_á»ŒÌ€waÌ€_BeÌl_á»ŒÌ€páº¹Ì€Ì€".split("_"),
        weekdays: "AÌ€iÌ€kuÌ_AjeÌ_IÌ€sáº¹Ìgun_á»Œjá»ÌruÌ_á»Œjá»Ìbá»_áº¸tiÌ€_AÌ€baÌmáº¹Ìta".split("_"),
        weekdaysShort: "AÌ€iÌ€k_AjeÌ_IÌ€sáº¹Ì_á»Œjr_á»Œjb_áº¸tiÌ€_AÌ€baÌ".split("_"),
        weekdaysMin: "AÌ€iÌ€_Aj_IÌ€s_á»Œr_á»Œb_áº¸t_AÌ€b".split("_"),
        longDateFormat: {
          LT: "h:mm A",
          LTS: "h:mm:ss A",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY h:mm A",
          LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendar: {
          sameDay: "[OÌ€niÌ€ ni] LT",
          nextDay: "[á»ŒÌ€la ni] LT",
          nextWeek: "dddd [á»Œsáº¹Ì€ toÌn'bá»] [ni] LT",
          lastDay: "[AÌ€na ni] LT",
          lastWeek: "dddd [á»Œsáº¹Ì€ toÌlá»Ì] [ni] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "niÌ %s",
          past: "%s ká»jaÌ",
          s: "iÌ€sáº¹juÌ aayaÌ die",
          ss: "aayaÌ %d",
          m: "iÌ€sáº¹juÌ kan",
          mm: "iÌ€sáº¹juÌ %d",
          h: "waÌkati kan",
          hh: "waÌkati %d",
          d: "á»já»Ì kan",
          dd: "á»já»Ì %d",
          M: "osuÌ€ kan",
          MM: "osuÌ€ %d",
          y: "á»duÌn kan",
          yy: "á»duÌn %d"
        },
        dayOfMonthOrdinalParse: /á»já»Ì\s\d{1,2}/,
        ordinal: "á»já»Ì %d",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("zh-cn", {
        months: "ä¸€æœˆ_äºŒæœˆ_ä¸‰æœˆ_å››æœˆ_äº”æœˆ_å…­æœˆ_ä¸ƒæœˆ_å…«æœˆ_ä¹æœˆ_åæœˆ_åä¸€æœˆ_åäºŒæœˆ".split(
          "_"
        ),
        monthsShort: "1æœˆ_2æœˆ_3æœˆ_4æœˆ_5æœˆ_6æœˆ_7æœˆ_8æœˆ_9æœˆ_10æœˆ_11æœˆ_12æœˆ".split(
          "_"
        ),
        weekdays: "æ˜ŸæœŸæ—¥_æ˜ŸæœŸä¸€_æ˜ŸæœŸäºŒ_æ˜ŸæœŸä¸‰_æ˜ŸæœŸå››_æ˜ŸæœŸäº”_æ˜ŸæœŸå…­".split("_"),
        weekdaysShort: "å‘¨æ—¥_å‘¨ä¸€_å‘¨äºŒ_å‘¨ä¸‰_å‘¨å››_å‘¨äº”_å‘¨å…­".split("_"),
        weekdaysMin: "æ—¥_ä¸€_äºŒ_ä¸‰_å››_äº”_å…­".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "YYYY/MM/DD",
          LL: "YYYYå¹´MæœˆDæ—¥",
          LLL: "YYYYå¹´MæœˆDæ—¥Ahç‚¹mmåˆ†",
          LLLL: "YYYYå¹´MæœˆDæ—¥ddddAhç‚¹mmåˆ†",
          l: "YYYY/M/D",
          ll: "YYYYå¹´MæœˆDæ—¥",
          lll: "YYYYå¹´MæœˆDæ—¥ HH:mm",
          llll: "YYYYå¹´MæœˆDæ—¥dddd HH:mm"
        },
        meridiemParse: /å‡Œæ™¨|æ—©ä¸Š|ä¸Šåˆ|ä¸­åˆ|ä¸‹åˆ|æ™šä¸Š/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "å‡Œæ™¨" || meridiem2 === "æ—©ä¸Š" || meridiem2 === "ä¸Šåˆ") {
            return hour;
          } else if (meridiem2 === "ä¸‹åˆ" || meridiem2 === "æ™šä¸Š") {
            return hour + 12;
          } else {
            return hour >= 11 ? hour : hour + 12;
          }
        },
        meridiem: function(hour, minute, isLower) {
          var hm = hour * 100 + minute;
          if (hm < 600) {
            return "å‡Œæ™¨";
          } else if (hm < 900) {
            return "æ—©ä¸Š";
          } else if (hm < 1130) {
            return "ä¸Šåˆ";
          } else if (hm < 1230) {
            return "ä¸­åˆ";
          } else if (hm < 1800) {
            return "ä¸‹åˆ";
          } else {
            return "æ™šä¸Š";
          }
        },
        calendar: {
          sameDay: "[ä»Šå¤©]LT",
          nextDay: "[æ˜Žå¤©]LT",
          nextWeek: function(now2) {
            if (now2.week() !== this.week()) {
              return "[ä¸‹]dddLT";
            } else {
              return "[æœ¬]dddLT";
            }
          },
          lastDay: "[æ˜¨å¤©]LT",
          lastWeek: function(now2) {
            if (this.week() !== now2.week()) {
              return "[ä¸Š]dddLT";
            } else {
              return "[æœ¬]dddLT";
            }
          },
          sameElse: "L"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(æ—¥|æœˆ|å‘¨)/,
        ordinal: function(number2, period) {
          switch (period) {
            case "d":
            case "D":
            case "DDD":
              return number2 + "æ—¥";
            case "M":
              return number2 + "æœˆ";
            case "w":
            case "W":
              return number2 + "å‘¨";
            default:
              return number2;
          }
        },
        relativeTime: {
          future: "%såŽ",
          past: "%så‰",
          s: "å‡ ç§’",
          ss: "%d ç§’",
          m: "1 åˆ†é’Ÿ",
          mm: "%d åˆ†é’Ÿ",
          h: "1 å°æ—¶",
          hh: "%d å°æ—¶",
          d: "1 å¤©",
          dd: "%d å¤©",
          w: "1 å‘¨",
          ww: "%d å‘¨",
          M: "1 ä¸ªæœˆ",
          MM: "%d ä¸ªæœˆ",
          y: "1 å¹´",
          yy: "%d å¹´"
        },
        week: {
          // GB/T 7408-1994ã€Šæ•°æ®å…ƒå’Œäº¤æ¢æ ¼å¼Â·ä¿¡æ¯äº¤æ¢Â·æ—¥æœŸå’Œæ—¶é—´è¡¨ç¤ºæ³•ã€‹ä¸ŽISO 8601:1988ç­‰æ•ˆ
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("zh-hk", {
        months: "ä¸€æœˆ_äºŒæœˆ_ä¸‰æœˆ_å››æœˆ_äº”æœˆ_å…­æœˆ_ä¸ƒæœˆ_å…«æœˆ_ä¹æœˆ_åæœˆ_åä¸€æœˆ_åäºŒæœˆ".split(
          "_"
        ),
        monthsShort: "1æœˆ_2æœˆ_3æœˆ_4æœˆ_5æœˆ_6æœˆ_7æœˆ_8æœˆ_9æœˆ_10æœˆ_11æœˆ_12æœˆ".split(
          "_"
        ),
        weekdays: "æ˜ŸæœŸæ—¥_æ˜ŸæœŸä¸€_æ˜ŸæœŸäºŒ_æ˜ŸæœŸä¸‰_æ˜ŸæœŸå››_æ˜ŸæœŸäº”_æ˜ŸæœŸå…­".split("_"),
        weekdaysShort: "é€±æ—¥_é€±ä¸€_é€±äºŒ_é€±ä¸‰_é€±å››_é€±äº”_é€±å…­".split("_"),
        weekdaysMin: "æ—¥_ä¸€_äºŒ_ä¸‰_å››_äº”_å…­".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "YYYY/MM/DD",
          LL: "YYYYå¹´MæœˆDæ—¥",
          LLL: "YYYYå¹´MæœˆDæ—¥ HH:mm",
          LLLL: "YYYYå¹´MæœˆDæ—¥dddd HH:mm",
          l: "YYYY/M/D",
          ll: "YYYYå¹´MæœˆDæ—¥",
          lll: "YYYYå¹´MæœˆDæ—¥ HH:mm",
          llll: "YYYYå¹´MæœˆDæ—¥dddd HH:mm"
        },
        meridiemParse: /å‡Œæ™¨|æ—©ä¸Š|ä¸Šåˆ|ä¸­åˆ|ä¸‹åˆ|æ™šä¸Š/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "å‡Œæ™¨" || meridiem2 === "æ—©ä¸Š" || meridiem2 === "ä¸Šåˆ") {
            return hour;
          } else if (meridiem2 === "ä¸­åˆ") {
            return hour >= 11 ? hour : hour + 12;
          } else if (meridiem2 === "ä¸‹åˆ" || meridiem2 === "æ™šä¸Š") {
            return hour + 12;
          }
        },
        meridiem: function(hour, minute, isLower) {
          var hm = hour * 100 + minute;
          if (hm < 600) {
            return "å‡Œæ™¨";
          } else if (hm < 900) {
            return "æ—©ä¸Š";
          } else if (hm < 1200) {
            return "ä¸Šåˆ";
          } else if (hm === 1200) {
            return "ä¸­åˆ";
          } else if (hm < 1800) {
            return "ä¸‹åˆ";
          } else {
            return "æ™šä¸Š";
          }
        },
        calendar: {
          sameDay: "[ä»Šå¤©]LT",
          nextDay: "[æ˜Žå¤©]LT",
          nextWeek: "[ä¸‹]ddddLT",
          lastDay: "[æ˜¨å¤©]LT",
          lastWeek: "[ä¸Š]ddddLT",
          sameElse: "L"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(æ—¥|æœˆ|é€±)/,
        ordinal: function(number2, period) {
          switch (period) {
            case "d":
            case "D":
            case "DDD":
              return number2 + "æ—¥";
            case "M":
              return number2 + "æœˆ";
            case "w":
            case "W":
              return number2 + "é€±";
            default:
              return number2;
          }
        },
        relativeTime: {
          future: "%så¾Œ",
          past: "%så‰",
          s: "å¹¾ç§’",
          ss: "%d ç§’",
          m: "1 åˆ†é˜",
          mm: "%d åˆ†é˜",
          h: "1 å°æ™‚",
          hh: "%d å°æ™‚",
          d: "1 å¤©",
          dd: "%d å¤©",
          M: "1 å€‹æœˆ",
          MM: "%d å€‹æœˆ",
          y: "1 å¹´",
          yy: "%d å¹´"
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("zh-mo", {
        months: "ä¸€æœˆ_äºŒæœˆ_ä¸‰æœˆ_å››æœˆ_äº”æœˆ_å…­æœˆ_ä¸ƒæœˆ_å…«æœˆ_ä¹æœˆ_åæœˆ_åä¸€æœˆ_åäºŒæœˆ".split(
          "_"
        ),
        monthsShort: "1æœˆ_2æœˆ_3æœˆ_4æœˆ_5æœˆ_6æœˆ_7æœˆ_8æœˆ_9æœˆ_10æœˆ_11æœˆ_12æœˆ".split(
          "_"
        ),
        weekdays: "æ˜ŸæœŸæ—¥_æ˜ŸæœŸä¸€_æ˜ŸæœŸäºŒ_æ˜ŸæœŸä¸‰_æ˜ŸæœŸå››_æ˜ŸæœŸäº”_æ˜ŸæœŸå…­".split("_"),
        weekdaysShort: "é€±æ—¥_é€±ä¸€_é€±äºŒ_é€±ä¸‰_é€±å››_é€±äº”_é€±å…­".split("_"),
        weekdaysMin: "æ—¥_ä¸€_äºŒ_ä¸‰_å››_äº”_å…­".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "YYYYå¹´MæœˆDæ—¥",
          LLL: "YYYYå¹´MæœˆDæ—¥ HH:mm",
          LLLL: "YYYYå¹´MæœˆDæ—¥dddd HH:mm",
          l: "D/M/YYYY",
          ll: "YYYYå¹´MæœˆDæ—¥",
          lll: "YYYYå¹´MæœˆDæ—¥ HH:mm",
          llll: "YYYYå¹´MæœˆDæ—¥dddd HH:mm"
        },
        meridiemParse: /å‡Œæ™¨|æ—©ä¸Š|ä¸Šåˆ|ä¸­åˆ|ä¸‹åˆ|æ™šä¸Š/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "å‡Œæ™¨" || meridiem2 === "æ—©ä¸Š" || meridiem2 === "ä¸Šåˆ") {
            return hour;
          } else if (meridiem2 === "ä¸­åˆ") {
            return hour >= 11 ? hour : hour + 12;
          } else if (meridiem2 === "ä¸‹åˆ" || meridiem2 === "æ™šä¸Š") {
            return hour + 12;
          }
        },
        meridiem: function(hour, minute, isLower) {
          var hm = hour * 100 + minute;
          if (hm < 600) {
            return "å‡Œæ™¨";
          } else if (hm < 900) {
            return "æ—©ä¸Š";
          } else if (hm < 1130) {
            return "ä¸Šåˆ";
          } else if (hm < 1230) {
            return "ä¸­åˆ";
          } else if (hm < 1800) {
            return "ä¸‹åˆ";
          } else {
            return "æ™šä¸Š";
          }
        },
        calendar: {
          sameDay: "[ä»Šå¤©] LT",
          nextDay: "[æ˜Žå¤©] LT",
          nextWeek: "[ä¸‹]dddd LT",
          lastDay: "[æ˜¨å¤©] LT",
          lastWeek: "[ä¸Š]dddd LT",
          sameElse: "L"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(æ—¥|æœˆ|é€±)/,
        ordinal: function(number2, period) {
          switch (period) {
            case "d":
            case "D":
            case "DDD":
              return number2 + "æ—¥";
            case "M":
              return number2 + "æœˆ";
            case "w":
            case "W":
              return number2 + "é€±";
            default:
              return number2;
          }
        },
        relativeTime: {
          future: "%så…§",
          past: "%så‰",
          s: "å¹¾ç§’",
          ss: "%d ç§’",
          m: "1 åˆ†é˜",
          mm: "%d åˆ†é˜",
          h: "1 å°æ™‚",
          hh: "%d å°æ™‚",
          d: "1 å¤©",
          dd: "%d å¤©",
          M: "1 å€‹æœˆ",
          MM: "%d å€‹æœˆ",
          y: "1 å¹´",
          yy: "%d å¹´"
        }
      });
      //! moment.js locale configuration
      hooks.defineLocale("zh-tw", {
        months: "ä¸€æœˆ_äºŒæœˆ_ä¸‰æœˆ_å››æœˆ_äº”æœˆ_å…­æœˆ_ä¸ƒæœˆ_å…«æœˆ_ä¹æœˆ_åæœˆ_åä¸€æœˆ_åäºŒæœˆ".split(
          "_"
        ),
        monthsShort: "1æœˆ_2æœˆ_3æœˆ_4æœˆ_5æœˆ_6æœˆ_7æœˆ_8æœˆ_9æœˆ_10æœˆ_11æœˆ_12æœˆ".split(
          "_"
        ),
        weekdays: "æ˜ŸæœŸæ—¥_æ˜ŸæœŸä¸€_æ˜ŸæœŸäºŒ_æ˜ŸæœŸä¸‰_æ˜ŸæœŸå››_æ˜ŸæœŸäº”_æ˜ŸæœŸå…­".split("_"),
        weekdaysShort: "é€±æ—¥_é€±ä¸€_é€±äºŒ_é€±ä¸‰_é€±å››_é€±äº”_é€±å…­".split("_"),
        weekdaysMin: "æ—¥_ä¸€_äºŒ_ä¸‰_å››_äº”_å…­".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "YYYY/MM/DD",
          LL: "YYYYå¹´MæœˆDæ—¥",
          LLL: "YYYYå¹´MæœˆDæ—¥ HH:mm",
          LLLL: "YYYYå¹´MæœˆDæ—¥dddd HH:mm",
          l: "YYYY/M/D",
          ll: "YYYYå¹´MæœˆDæ—¥",
          lll: "YYYYå¹´MæœˆDæ—¥ HH:mm",
          llll: "YYYYå¹´MæœˆDæ—¥dddd HH:mm"
        },
        meridiemParse: /å‡Œæ™¨|æ—©ä¸Š|ä¸Šåˆ|ä¸­åˆ|ä¸‹åˆ|æ™šä¸Š/,
        meridiemHour: function(hour, meridiem2) {
          if (hour === 12) {
            hour = 0;
          }
          if (meridiem2 === "å‡Œæ™¨" || meridiem2 === "æ—©ä¸Š" || meridiem2 === "ä¸Šåˆ") {
            return hour;
          } else if (meridiem2 === "ä¸­åˆ") {
            return hour >= 11 ? hour : hour + 12;
          } else if (meridiem2 === "ä¸‹åˆ" || meridiem2 === "æ™šä¸Š") {
            return hour + 12;
          }
        },
        meridiem: function(hour, minute, isLower) {
          var hm = hour * 100 + minute;
          if (hm < 600) {
            return "å‡Œæ™¨";
          } else if (hm < 900) {
            return "æ—©ä¸Š";
          } else if (hm < 1130) {
            return "ä¸Šåˆ";
          } else if (hm < 1230) {
            return "ä¸­åˆ";
          } else if (hm < 1800) {
            return "ä¸‹åˆ";
          } else {
            return "æ™šä¸Š";
          }
        },
        calendar: {
          sameDay: "[ä»Šå¤©] LT",
          nextDay: "[æ˜Žå¤©] LT",
          nextWeek: "[ä¸‹]dddd LT",
          lastDay: "[æ˜¨å¤©] LT",
          lastWeek: "[ä¸Š]dddd LT",
          sameElse: "L"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(æ—¥|æœˆ|é€±)/,
        ordinal: function(number2, period) {
          switch (period) {
            case "d":
            case "D":
            case "DDD":
              return number2 + "æ—¥";
            case "M":
              return number2 + "æœˆ";
            case "w":
            case "W":
              return number2 + "é€±";
            default:
              return number2;
          }
        },
        relativeTime: {
          future: "%så¾Œ",
          past: "%så‰",
          s: "å¹¾ç§’",
          ss: "%d ç§’",
          m: "1 åˆ†é˜",
          mm: "%d åˆ†é˜",
          h: "1 å°æ™‚",
          hh: "%d å°æ™‚",
          d: "1 å¤©",
          dd: "%d å¤©",
          M: "1 å€‹æœˆ",
          MM: "%d å€‹æœˆ",
          y: "1 å¹´",
          yy: "%d å¹´"
        }
      });
      hooks.locale("en");
      return hooks;
    });
  })(momentWithLocales$1);
  return momentWithLocales$1.exports;
}
var momentWithLocalesExports = requireMomentWithLocales();
const moment = /* @__PURE__ */ getDefaultExportFromCjs(momentWithLocalesExports);
const locale = getLocale();
const translations = { "ar": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["Ø«ÙˆØ§Ù†Ù"] } } } }, "ast": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["segundos"] } } } }, "az": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["saniyÉ™"] } } } }, "be": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["ÑÐµÐºÑƒÐ½Ð´Ñ‹"] } } } }, "br": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["eilennoÃ¹"] } } } }, "ca": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["segons"] } } } }, "cs": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekund(y)"] } } } }, "cs_CZ": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekund(y)"] } } } }, "da": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekunder"] } } } }, "de": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["Sekunden"] } } } }, "de_DE": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["Sekunden"] } } } }, "el": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["Î´ÎµÏ…Ï„ÎµÏÏŒÎ»ÎµÏ€Ï„Î±"] } } } }, "en_GB": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["seconds"] } } } }, "eo": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekundoj"] } } } }, "es": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["segundos"] } } } }, "es_AR": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["segundos"] } } } }, "es_CL": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["segundos"] } } } }, "es_MX": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["segundos"] } } } }, "et_EE": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekundid"] } } } }, "eu": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["segundo"] } } } }, "fa": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["Ø«Ø§Ù†ÛŒÙ‡"] } } } }, "fi": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekuntia"] } } } }, "fi_FI": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekuntia"] } } } }, "fr": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["secondes"] } } } }, "ga": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["soicindÃ­"] } } } }, "gl": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["segundos"] } } } }, "he": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["×©× ×™×•×ª"] } } } }, "hr": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekunde"] } } } }, "hu": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["mÃ¡sodperc"] } } } }, "hu_HU": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["mÃ¡sodperc"] } } } }, "id": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["detik"] } } } }, "is": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekÃºndur"] } } } }, "it": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["secondi"] } } } }, "ja": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["ç§’å¾Œ"] } } } }, "ja_JP": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["ç§’"] } } } }, "kab": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["tasinin"] } } } }, "ko": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["ì´ˆ"] } } } }, "lo": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["àº§àº´àº™àº²àº—àºµ"] } } } }, "lt_LT": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sek."] } } } }, "lv": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekundes"] } } } }, "mk": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["ÑÐµÐºÑƒÐ½Ð´Ð¸"] } } } }, "mn": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["ÑÐµÐºÑƒÐ½Ð´"] } } } }, "ms_MY": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["saat"] } } } }, "my": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["á€…á€€á€¹á€€á€”á€ºá€·"] } } } }, "nb": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekunder"] } } } }, "nb_NO": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekunder"] } } } }, "nl": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["seconden"] } } } }, "oc": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["segondas"] } } } }, "pl": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekundy"] } } } }, "pt_BR": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["segundos"] } } } }, "pt_PT": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["segundos"] } } } }, "ro": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["secunde"] } } } }, "ru": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["ÑÐµÐºÑƒÐ½Ð´Ñ‹"] } } } }, "si": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["à¶­à¶­à·Šà¶´à¶»"] } } } }, "sk": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekÃºnd"] } } } }, "sk_SK": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekundy"] } } } }, "sl": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekunde"] } } } }, "sq": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekonda"] } } } }, "sr": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["ÑÐµÐºÑƒÐ½Ð´Ðµ"] } } } }, "sv": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["sekunder"] } } } }, "th_TH": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["à¸§à¸´à¸™à¸²à¸—à¸µ"] } } } }, "tr": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["saniye"] } } } }, "uk": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["ÑÐµÐºÑƒÐ½Ð´"] } } } }, "uz": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["ikkinchi"] } } } }, "vi": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["giÃ¢y"] } } } }, "zh_CN": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["ç§’"] } } } }, "zh_HK": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["ç§’"] } } } }, "zh_TW": { "charset": "utf-8", "translations": { "": { "seconds": { "msgid": "seconds", "msgstr": ["ç§’"] } } } } };
moment.locale(locale);
if (locale === "en" || locale in translations) {
  const gt = getGettextBuilder().setLanguage(locale).addTranslation(locale, translations[locale]).build();
  moment.updateLocale(moment.locale(), {
    relativeTime: {
      s: gt.gettext("seconds")
    }
  });
}
const logger = getLoggerBuilder().detectUser().setApp("@nextcloud/vue").build();
const _hoisted_1$j = {
  class: "empty-content",
  role: "note"
};
const _hoisted_2$d = {
  key: 0,
  class: "empty-content__icon",
  "aria-hidden": "true"
};
const _hoisted_3$c = {
  key: 0,
  class: "empty-content__name"
};
const _hoisted_4$a = {
  key: 1,
  class: "empty-content__description"
};
const _hoisted_5$6 = {
  key: 2,
  class: "empty-content__action"
};
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "NcEmptyContent",
  props: {
    description: { default: "" },
    name: { default: "" }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$j, [
        _ctx.$slots.icon ? (openBlock(), createElementBlock("div", _hoisted_2$d, [
          renderSlot(_ctx.$slots, "icon", {}, void 0, true)
        ])) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "name", {}, () => [
          _ctx.name !== "" ? (openBlock(), createElementBlock("span", _hoisted_3$c, toDisplayString(_ctx.name), 1)) : createCommentVNode("", true)
        ], true),
        _ctx.description !== "" || _ctx.$slots.description ? (openBlock(), createElementBlock("p", _hoisted_4$a, [
          renderSlot(_ctx.$slots, "description", {}, () => [
            createTextVNode(toDisplayString(_ctx.description), 1)
          ], true)
        ])) : createCommentVNode("", true),
        _ctx.$slots.action ? (openBlock(), createElementBlock("div", _hoisted_5$6, [
          renderSlot(_ctx.$slots, "action", {}, void 0, true)
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
const NcEmptyContent = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__scopeId", "data-v-697cfd8f"]]);
const ActionGlobalMixin = {
  beforeUpdate() {
    this.text = this.getText();
  },
  data() {
    return {
      // $slots are not reactive.
      // We need to update  the content manually
      text: this.getText()
    };
  },
  computed: {
    isLongText() {
      return this.text && this.text.trim().length > 20;
    }
  },
  methods: {
    getText() {
      return this.$slots.default?.()[0].children?.trim?.() || "";
    }
  }
};
const ActionTextMixin = {
  mixins: [ActionGlobalMixin],
  props: {
    /**
     * Icon to show with the action, can be either a CSS class or an URL
     */
    icon: {
      type: String,
      default: ""
    },
    /**
     * The main text content of the entry.
     */
    name: {
      type: String,
      default: ""
    },
    /**
     * The title attribute of the element.
     */
    title: {
      type: String,
      default: ""
    },
    /**
     * Whether we close the Actions menu after the click
     */
    closeAfterClick: {
      type: Boolean,
      default: false
    },
    /**
     * Aria label for the button. Not needed if the button has text.
     */
    ariaLabel: {
      type: String,
      default: null
    }
  },
  inject: {
    closeMenu: {
      from: NC_ACTIONS_CLOSE_MENU
    }
  },
  emits: [
    "click"
  ],
  created() {
    if ("ariaHidden" in this.$attrs) {
      warn("[NcAction*]: Do not set the ariaHidden attribute as the root element will inherit the incorrect aria-hidden.");
    }
  },
  computed: {
    /**
     * Check if icon prop is an URL
     * @return {boolean} Whether the icon prop is an URL
     */
    isIconUrl() {
      try {
        return !!new URL(this.icon, this.icon.startsWith("/") ? window.location.origin : void 0);
      } catch (error) {
        return false;
      }
    }
  },
  methods: {
    onClick(event) {
      this.$emit("click", event);
      if (this.closeAfterClick) {
        this.closeMenu(false);
      }
    }
  }
};
const _sfc_main$o = {
  name: "NcActionLink",
  mixins: [ActionTextMixin],
  inject: {
    isInSemanticMenu: {
      from: NC_ACTIONS_IS_SEMANTIC_MENU,
      default: false
    }
  },
  props: {
    /**
     * destionation to link to
     */
    href: {
      type: String,
      default: "#",
      required: true,
      validator: (value) => {
        try {
          return new URL(value);
        } catch (error) {
          return value.startsWith("#") || value.startsWith("/");
        }
      }
    },
    /**
     * download the link instead of opening
     */
    download: {
      type: String,
      default: null
    },
    /**
     * target to open the link
     */
    target: {
      type: String,
      default: "_self",
      validator: (value) => {
        return value && (!value.startsWith("_") || ["_blank", "_self", "_parent", "_top"].indexOf(value) > -1);
      }
    },
    /**
     * Declares a native tooltip when not null
     */
    title: {
      type: String,
      default: null
    }
  }
};
const _hoisted_1$i = ["role"];
const _hoisted_2$c = ["download", "href", "aria-label", "target", "title", "role"];
const _hoisted_3$b = {
  key: 0,
  class: "action-link__longtext-wrapper"
};
const _hoisted_4$9 = { class: "action-link__name" };
const _hoisted_5$5 = ["textContent"];
const _hoisted_6$4 = ["textContent"];
const _hoisted_7$1 = {
  key: 2,
  class: "action-link__text"
};
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    class: "action",
    role: $options.isInSemanticMenu && "presentation"
  }, [
    createBaseVNode("a", {
      download: $props.download,
      href: $props.href,
      "aria-label": _ctx.ariaLabel,
      target: $props.target,
      title: $props.title,
      class: "action-link focusable",
      rel: "nofollow noreferrer noopener",
      role: $options.isInSemanticMenu && "menuitem",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, [
      renderSlot(_ctx.$slots, "icon", {}, () => [
        createBaseVNode("span", {
          class: normalizeClass([[_ctx.isIconUrl ? "action-link__icon--url" : _ctx.icon], "action-link__icon"]),
          style: normalizeStyle({ backgroundImage: _ctx.isIconUrl ? `url(${_ctx.icon})` : null }),
          "aria-hidden": "true"
        }, null, 6)
      ], true),
      _ctx.name ? (openBlock(), createElementBlock("span", _hoisted_3$b, [
        createBaseVNode("strong", _hoisted_4$9, toDisplayString(_ctx.name), 1),
        _cache[1] || (_cache[1] = createBaseVNode("br", null, null, -1)),
        createBaseVNode("span", {
          class: "action-link__longtext",
          textContent: toDisplayString(_ctx.text)
        }, null, 8, _hoisted_5$5)
      ])) : _ctx.isLongText ? (openBlock(), createElementBlock("span", {
        key: 1,
        class: "action-link__longtext",
        textContent: toDisplayString(_ctx.text)
      }, null, 8, _hoisted_6$4)) : (openBlock(), createElementBlock("span", _hoisted_7$1, toDisplayString(_ctx.text), 1)),
      createCommentVNode("", true)
    ], 8, _hoisted_2$c)
  ], 8, _hoisted_1$i);
}
const NcActionLink = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$m], ["__scopeId", "data-v-786624ec"]]);
const _sfc_main$n = {
  name: "NcActionRouter",
  mixins: [ActionTextMixin],
  inject: {
    isInSemanticMenu: {
      from: NC_ACTIONS_IS_SEMANTIC_MENU,
      default: false
    }
  },
  props: {
    /**
     * router-link to prop [https://router.vuejs.org/api/#to](https://router.vuejs.org/api/#to)
     */
    to: {
      type: [String, Object],
      default: "",
      required: true
    }
  }
};
const _hoisted_1$h = ["role"];
const _hoisted_2$b = {
  key: 0,
  class: "action-router__longtext-wrapper"
};
const _hoisted_3$a = { class: "action-router__name" };
const _hoisted_4$8 = ["textContent"];
const _hoisted_5$4 = ["textContent"];
const _hoisted_6$3 = {
  key: 2,
  class: "action-router__text"
};
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_RouterLink = resolveComponent("RouterLink");
  return openBlock(), createElementBlock("li", {
    class: "action",
    role: $options.isInSemanticMenu && "presentation"
  }, [
    createVNode(_component_RouterLink, {
      to: $props.to,
      "aria-label": _ctx.ariaLabel,
      title: _ctx.title,
      class: "action-router focusable",
      rel: "nofollow noreferrer noopener",
      role: $options.isInSemanticMenu && "menuitem",
      onClick: _ctx.onClick
    }, {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "icon", {}, () => [
          createBaseVNode("span", {
            class: normalizeClass([[_ctx.isIconUrl ? "action-router__icon--url" : _ctx.icon], "action-router__icon"]),
            style: normalizeStyle({ backgroundImage: _ctx.isIconUrl ? `url(${_ctx.icon})` : null }),
            "aria-hidden": "true"
          }, null, 6)
        ], true),
        _ctx.name ? (openBlock(), createElementBlock("span", _hoisted_2$b, [
          createBaseVNode("strong", _hoisted_3$a, toDisplayString(_ctx.name), 1),
          _cache[0] || (_cache[0] = createBaseVNode("br", null, null, -1)),
          createBaseVNode("span", {
            class: "action-router__longtext",
            textContent: toDisplayString(_ctx.text)
          }, null, 8, _hoisted_4$8)
        ])) : _ctx.isLongText ? (openBlock(), createElementBlock("span", {
          key: 1,
          class: "action-router__longtext",
          textContent: toDisplayString(_ctx.text)
        }, null, 8, _hoisted_5$4)) : (openBlock(), createElementBlock("span", _hoisted_6$3, toDisplayString(_ctx.text), 1)),
        createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["to", "aria-label", "title", "role", "onClick"])
  ], 8, _hoisted_1$h);
}
const NcActionRouter = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$l], ["__scopeId", "data-v-d4dc7cdf"]]);
const _sfc_main$m = {
  name: "NcActionText",
  mixins: [ActionTextMixin],
  inject: {
    isInSemanticMenu: {
      from: NC_ACTIONS_IS_SEMANTIC_MENU,
      default: false
    }
  }
};
const _hoisted_1$g = ["role"];
const _hoisted_2$a = {
  key: 0,
  class: "action-text__longtext-wrapper"
};
const _hoisted_3$9 = { class: "action-text__name" };
const _hoisted_4$7 = ["textContent"];
const _hoisted_5$3 = ["textContent"];
const _hoisted_6$2 = {
  key: 2,
  class: "action-text__text"
};
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    class: "action",
    role: $options.isInSemanticMenu && "presentation"
  }, [
    createBaseVNode("span", {
      class: "action-text",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, [
      renderSlot(_ctx.$slots, "icon", {}, () => [
        _ctx.icon !== "" ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass([[_ctx.isIconUrl ? "action-text__icon--url" : _ctx.icon], "action-text__icon"]),
          "aria-hidden": "true",
          style: normalizeStyle({ backgroundImage: _ctx.isIconUrl ? `url(${_ctx.icon})` : null })
        }, null, 6)) : createCommentVNode("", true)
      ], true),
      _ctx.name ? (openBlock(), createElementBlock("span", _hoisted_2$a, [
        createBaseVNode("strong", _hoisted_3$9, toDisplayString(_ctx.name), 1),
        _cache[1] || (_cache[1] = createBaseVNode("br", null, null, -1)),
        createBaseVNode("span", {
          class: "action-text__longtext",
          textContent: toDisplayString(_ctx.text)
        }, null, 8, _hoisted_4$7)
      ])) : _ctx.isLongText ? (openBlock(), createElementBlock("span", {
        key: 1,
        class: "action-text__longtext",
        textContent: toDisplayString(_ctx.text)
      }, null, 8, _hoisted_5$3)) : (openBlock(), createElementBlock("span", _hoisted_6$2, toDisplayString(_ctx.text), 1)),
      createCommentVNode("", true)
    ])
  ], 8, _hoisted_1$g);
}
const NcActionText = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$k], ["__scopeId", "data-v-a8e61e98"]]);
function e() {
  try {
    return loadState("core", "capabilities");
  } catch {
    return console.debug("Could not find capabilities initial state fall back to _oc_capabilities"), "_oc_capabilities" in window ? window._oc_capabilities : {};
  }
}
register(t10);
const getUserStatusText = (status) => {
  switch (status) {
    case "away":
      return t("away");
    // TRANSLATORS: User status if the user is currently away from keyboard
    case "busy":
      return t("busy");
    case "dnd":
      return t("do not disturb");
    case "online":
      return t("online");
    case "invisible":
      return t("invisible");
    case "offline":
      return t("offline");
    default:
      return status;
  }
};
register();
const onlineSvg = '<!--\n  - SPDX-FileCopyrightText: 2020 Google Inc.\n  - SPDX-License-Identifier: Apache-2.0\n-->\n<svg viewBox="0 0 16 16" width="16" height="16" xmlns="http://www.w3.org/2000/svg">\n	<path fill="var(--color-success)" d="M4.8 11.2h6.4V4.8H4.8v6.4zM8 0C3.6 0 0 3.6 0 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8z" />\n</svg>\n';
const awaySvg = '<!--\n  - SPDX-FileCopyrightText: 2020 Google Inc.\n  - SPDX-License-Identifier: Apache-2.0\n-->\n<svg viewBox="0 0 16 16" width="16" height="16" xmlns="http://www.w3.org/2000/svg">\n	<path fill="none" d="M-4-4h24v24H-4z" />\n	<path fill="var(--color-warning)" d="M6.9.1C3 .6-.1 4-.1 8c0 4.4 3.6 8 8 8 4 0 7.4-3 8-6.9-1.2 1.3-2.9 2.1-4.7 2.1-3.5 0-6.4-2.9-6.4-6.4 0-1.9.8-3.6 2.1-4.7z" />\n</svg>\n';
const dndSvg = '<!--\n  - SPDX-FileCopyrightText: 2020 Google Inc.\n  - SPDX-License-Identifier: Apache-2.0\n-->\n<svg viewBox="0 0 16 16" width="16" height="16" xmlns="http://www.w3.org/2000/svg">\n	<path fill="none" d="M-4-4h24v24H-4V-4z" />\n	<path fill="var(--color-error)" d="M8 0C3.6 0 0 3.6 0 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8z" />\n	<path fill="#fdffff" d="M5 6.5h6c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5H5c-.8 0-1.5-.7-1.5-1.5S4.2 6.5 5 6.5z" />\n</svg>\n';
const invisibleSvg = '<!--\n  - SPDX-FileCopyrightText: 2020 Google Inc.\n  - SPDX-License-Identifier: Apache-2.0\n-->\n<svg viewBox="0 0 16 16" width="16" height="16" xmlns="http://www.w3.org/2000/svg">\n	<path fill="none" d="M-4-4h24v24H-4V-4z" />\n	<path d="M8 0C3.6 0 0 3.6 0 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zm0 3.2c2.7 0 4.8 2.1 4.8 4.8s-2.1 4.8-4.8 4.8S3.2 10.7 3.2 8 5.3 3.2 8 3.2z" />\n</svg>\n';
const _hoisted_1$f = ["aria-hidden", "aria-label", "innerHTML"];
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "NcUserStatusIcon",
  props: /* @__PURE__ */ mergeModels({
    user: { default: void 0 },
    ariaHidden: { type: [Boolean, String], default: false }
  }, {
    "status": {},
    "statusModifiers": {}
  }),
  emits: ["update:status"],
  setup(__props) {
    const props = __props;
    const status = useModel(__props, "status");
    const isInvisible = computed(() => status.value && ["invisible", "offline"].includes(status.value));
    const ariaLabel = computed(() => status.value && (!props.ariaHidden || props.ariaHidden === "false") ? t("User status: {status}", { status: getUserStatusText(status.value) }) : void 0);
    watch(() => props.user, async (user) => {
      if (!status.value && user && e()?.user_status?.enabled) {
        try {
          const { data } = await cancelableClient.get(v("/apps/user_status/api/v1/statuses/{user}", { user }));
          status.value = data.ocs?.data?.status;
        } catch (error) {
          logger.debug("Error while fetching user status", { error });
        }
      }
    }, { immediate: true });
    const matchSvg = {
      online: onlineSvg,
      away: awaySvg,
      busy: awaySvg,
      dnd: dndSvg,
      invisible: invisibleSvg,
      offline: invisibleSvg
    };
    const activeSvg = computed(() => status.value && matchSvg[status.value]);
    return (_ctx, _cache) => {
      return status.value ? (openBlock(), createElementBlock("span", {
        key: 0,
        class: normalizeClass(["user-status-icon", {
          "user-status-icon--invisible": isInvisible.value
        }]),
        "aria-hidden": !ariaLabel.value || void 0,
        "aria-label": ariaLabel.value,
        role: "img",
        innerHTML: activeSvg.value
      }, null, 10, _hoisted_1$f)) : createCommentVNode("", true);
    };
  }
});
const NcUserStatusIcon = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__scopeId", "data-v-350f3d1c"]]);
const _sfc_main$k = {
  name: "NcActionButton",
  components: {
    NcIconSvgWrapper
  },
  mixins: [ActionTextMixin],
  inject: {
    isInSemanticMenu: {
      from: NC_ACTIONS_IS_SEMANTIC_MENU,
      default: false
    }
  },
  props: {
    /**
     * disabled state of the action button
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * If this is a menu, a chevron icon will
     * be added at the end of the line
     */
    isMenu: {
      type: Boolean,
      default: false
    },
    /**
     * The button's behavior, by default the button acts like a normal button with optional toggle button behavior if `modelValue` is `true` or `false`.
     * But you can also set to checkbox button behavior with tri-state or radio button like behavior.
     * This extends the native HTML button type attribute.
     */
    type: {
      type: String,
      default: "button",
      validator: (behavior) => ["button", "checkbox", "radio", "reset", "submit"].includes(behavior)
    },
    /**
     * The buttons state if `type` is 'checkbox' or 'radio' (meaning if it is pressed / selected).
     * For checkbox and toggle button behavior - boolean value.
     * For radio button behavior - could be a boolean checked or a string with the value of the button.
     * Note: Unlike native radio buttons, NcActionButton are not grouped by name, so you need to connect them by bind correct modelValue.
     *
     *  **This is not availabe for `type='submit'` or `type='reset'`**
     *
     * If using `type='checkbox'` a `model-value` of `true` means checked, `false` means unchecked and `null` means indeterminate (tri-state)
     * For `type='radio'` `null` is equal to `false`
     */
    modelValue: {
      type: [Boolean, String],
      default: null
    },
    /**
     * The value used for the `modelValue` when this component is used with radio behavior
     * Similar to the `value` attribute of `<input type="radio">`
     */
    value: {
      type: String,
      default: null
    },
    /**
     * Small underlying text content of the entry
     */
    description: {
      type: String,
      default: ""
    }
  },
  emits: ["update:modelValue"],
  setup() {
    return {
      mdiCheck,
      mdiChevronRight
    };
  },
  computed: {
    /**
     * determines if the action is focusable
     *
     * @return {boolean} is the action focusable ?
     */
    isFocusable() {
      return !this.disabled;
    },
    /**
     * The current "checked" or "pressed" state for the model behavior
     */
    isChecked() {
      if (this.type === "radio" && typeof this.modelValue !== "boolean") {
        return this.modelValue === this.value;
      }
      return this.modelValue;
    },
    /**
     * The native HTML type to set on the button
     */
    nativeType() {
      if (this.type === "submit" || this.type === "reset") {
        return this.type;
      }
      return "button";
    },
    /**
     * HTML attributes to bind to the <button>
     */
    buttonAttributes() {
      const attributes = {};
      if (this.isInSemanticMenu) {
        attributes.role = "menuitem";
        if (this.type === "radio") {
          attributes.role = "menuitemradio";
          attributes["aria-checked"] = this.isChecked ? "true" : "false";
        } else if (this.type === "checkbox" || this.nativeType === "button" && this.modelValue !== null) {
          attributes.role = "menuitemcheckbox";
          attributes["aria-checked"] = this.modelValue === null ? "mixed" : this.modelValue ? "true" : "false";
        }
      } else if (this.modelValue !== null && this.nativeType === "button") {
        attributes["aria-pressed"] = this.modelValue ? "true" : "false";
      }
      return attributes;
    }
  },
  methods: {
    /**
     * Forward click event, let mixin handle the close-after-click and emit new modelValue if needed
     * @param {MouseEvent} event The click event
     */
    handleClick(event) {
      this.onClick(event);
      if (this.modelValue !== null || this.type !== "button") {
        if (this.type === "radio") {
          if (typeof this.modelValue !== "boolean") {
            if (!this.isChecked) {
              this.$emit("update:modelValue", this.value);
            }
          } else {
            this.$emit("update:modelValue", !this.isChecked);
          }
        } else {
          this.$emit("update:modelValue", !this.isChecked);
        }
      }
    }
  }
};
const _hoisted_1$e = ["role"];
const _hoisted_2$9 = ["aria-label", "disabled", "title", "type"];
const _hoisted_3$8 = { class: "action-button__longtext-wrapper" };
const _hoisted_4$6 = {
  key: 0,
  class: "action-button__name"
};
const _hoisted_5$2 = ["textContent"];
const _hoisted_6$1 = {
  key: 2,
  class: "action-button__text"
};
const _hoisted_7 = ["textContent"];
const _hoisted_8 = {
  key: 2,
  class: "action-button__pressed-icon material-design-icon"
};
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_NcIconSvgWrapper = resolveComponent("NcIconSvgWrapper");
  return openBlock(), createElementBlock("li", {
    class: normalizeClass(["action", { "action--disabled": $props.disabled }]),
    role: $options.isInSemanticMenu && "presentation"
  }, [
    createBaseVNode("button", mergeProps({
      "aria-label": _ctx.ariaLabel,
      class: ["action-button button-vue", {
        "action-button--active": $options.isChecked,
        focusable: $options.isFocusable
      }],
      disabled: $props.disabled,
      title: _ctx.title,
      type: $options.nativeType
    }, $options.buttonAttributes, {
      onClick: _cache[0] || (_cache[0] = (...args) => $options.handleClick && $options.handleClick(...args))
    }), [
      renderSlot(_ctx.$slots, "icon", {}, () => [
        createBaseVNode("span", {
          class: normalizeClass([[_ctx.isIconUrl ? "action-button__icon--url" : _ctx.icon], "action-button__icon"]),
          style: normalizeStyle({ backgroundImage: _ctx.isIconUrl ? `url(${_ctx.icon})` : null }),
          "aria-hidden": "true"
        }, null, 6)
      ], true),
      createBaseVNode("span", _hoisted_3$8, [
        _ctx.name ? (openBlock(), createElementBlock("strong", _hoisted_4$6, toDisplayString(_ctx.name), 1)) : createCommentVNode("", true),
        _ctx.isLongText ? (openBlock(), createElementBlock("span", {
          key: 1,
          class: "action-button__longtext",
          textContent: toDisplayString(_ctx.text)
        }, null, 8, _hoisted_5$2)) : (openBlock(), createElementBlock("span", _hoisted_6$1, toDisplayString(_ctx.text), 1)),
        $props.description ? (openBlock(), createElementBlock("span", {
          key: 3,
          class: "action-button__description",
          textContent: toDisplayString($props.description)
        }, null, 8, _hoisted_7)) : createCommentVNode("", true)
      ]),
      $props.isMenu ? (openBlock(), createBlock(_component_NcIconSvgWrapper, {
        key: 0,
        class: "action-button__menu-icon",
        directional: "",
        path: $setup.mdiChevronRight
      }, null, 8, ["path"])) : $options.isChecked ? (openBlock(), createBlock(_component_NcIconSvgWrapper, {
        key: 1,
        path: $setup.mdiCheck,
        class: "action-button__pressed-icon"
      }, null, 8, ["path"])) : $options.isChecked === false ? (openBlock(), createElementBlock("span", _hoisted_8)) : createCommentVNode("", true),
      createCommentVNode("", true)
    ], 16, _hoisted_2$9)
  ], 10, _hoisted_1$e);
}
const NcActionButton = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$j], ["__scopeId", "data-v-992f2357"]]);
register(t3);
class Color {
  /**
   * @param r - The red value
   * @param g - The green value
   * @param b - The blue value
   * @param name - The name of the color
   */
  constructor(r, g, b, name2) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.name = name2;
    this.r = Math.min(r, 255);
    this.g = Math.min(g, 255);
    this.b = Math.min(b, 255);
    this.name = name2;
  }
  /**
   * The hexadecimal color string.
   */
  get color() {
    const toHex = (int) => `00${int.toString(16)}`.slice(-2);
    return `#${toHex(this.r)}${toHex(this.g)}${toHex(this.b)}`;
  }
}
function calculateStepIncrement(steps, color1, color2) {
  return {
    r: (color2.r - color1.r) / steps,
    g: (color2.g - color1.g) / steps,
    b: (color2.b - color1.b) / steps
  };
}
function mixPalette(steps, color1, color2) {
  const palette = [];
  palette.push(color1);
  const increment2 = calculateStepIncrement(steps, color1, color2);
  for (let i = 1; i < steps; i++) {
    const r = Math.floor(color1.r + increment2.r * i);
    const g = Math.floor(color1.g + increment2.g * i);
    const b = Math.floor(color1.b + increment2.b * i);
    palette.push(new Color(r, g, b));
  }
  return palette;
}
[
  new Color(182, 70, 157, t("Purple")),
  new Color(
    191,
    103,
    139,
    t("Rosy brown")
    // TRANSLATORS: A color name for RGB(191, 103, 139)
  ),
  new Color(
    201,
    136,
    121,
    t("Feldspar")
    // TRANSLATORS: A color name for RGB(201, 136, 121)
  ),
  new Color(
    211,
    169,
    103,
    t("Whiskey")
    // TRANSLATORS: A color name for RGB(211, 169, 103)
  ),
  new Color(
    221,
    203,
    85,
    t("Gold")
  ),
  new Color(
    165,
    184,
    114,
    t("Olivine")
    // TRANSLATORS: A color name for RGB(165, 184, 114)
  ),
  new Color(
    110,
    166,
    143,
    t("Acapulco")
    // TRANSLATORS: A color name for RGB(110, 166, 143)
  ),
  new Color(
    55,
    148,
    172,
    t("Boston Blue")
    // TRANSLATORS: A color name for RGB(55, 148, 172)
  ),
  new Color(
    0,
    130,
    201,
    t("Nextcloud blue")
  ),
  new Color(
    45,
    115,
    190,
    t("Mariner")
    // TRANSLATORS: A color name for RGB(45, 115, 190)
  ),
  new Color(
    91,
    100,
    179,
    t("Blue Violet")
    // TRANSLATORS: A color name for RGB(91, 100, 179)
  ),
  new Color(
    136,
    85,
    168,
    t("Deluge")
    // TRANSLATORS: A color name for RGB(136, 85, 168)
  )
];
function generatePalette(steps) {
  const red = new Color(182, 70, 157, t("Purple"));
  const yellow = new Color(221, 203, 85, t("Gold"));
  const blue = new Color(0, 130, 201, t("Nextcloud blue"));
  const palette1 = mixPalette(steps, red, yellow);
  const palette2 = mixPalette(steps, yellow, blue);
  const palette3 = mixPalette(steps, blue, red);
  return palette1.concat(palette2).concat(palette3);
}
function hashCode(str) {
  let hash = 0;
  if (str.length === 0) {
    return hash;
  }
  for (let i = 0; i < str.length; i++) {
    const chr = str.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
  }
  return Math.abs(hash);
}
function usernameToColor(username) {
  const steps = 6;
  const finalPalette = generatePalette(steps);
  const hash = hashCode(username.toLocaleLowerCase());
  return finalPalette[hash % finalPalette.length];
}
function getEnabledContactsMenuActions(entry) {
  if (!window._nc_contacts_menu_hooks) {
    return [];
  }
  return Object.values(window._nc_contacts_menu_hooks).filter((action) => action.enabled(entry));
}
const getAvatarUrl = (user, size, isGuest) => {
  const darkTheme = window.getComputedStyle(document.body).getPropertyValue("--background-invert-if-dark") === "invert(100%)";
  return _("/avatar" + (isGuest ? "/guest" : "") + "/{user}/{size}" + (darkTheme ? "/dark" : ""), {
    user,
    size
  });
};
var striptags$1 = { exports: {} };
var striptags = striptags$1.exports;
var hasRequiredStriptags;
function requireStriptags() {
  if (hasRequiredStriptags) return striptags$1.exports;
  hasRequiredStriptags = 1;
  (function(module) {
    (function(global) {
      if (typeof Symbol2 !== "function") {
        var Symbol2 = function(name2) {
          return name2;
        };
        Symbol2.nonNative = true;
      }
      const STATE_PLAINTEXT = Symbol2("plaintext");
      const STATE_HTML = Symbol2("html");
      const STATE_COMMENT = Symbol2("comment");
      const ALLOWED_TAGS_REGEX = /<(\w*)>/g;
      const NORMALIZE_TAG_REGEX = /<\/?([^\s\/>]+)/;
      function striptags2(html2, allowable_tags, tag_replacement) {
        html2 = html2 || "";
        allowable_tags = allowable_tags || [];
        tag_replacement = tag_replacement || "";
        let context = init_context(allowable_tags, tag_replacement);
        return striptags_internal(html2, context);
      }
      function init_striptags_stream(allowable_tags, tag_replacement) {
        allowable_tags = allowable_tags || [];
        tag_replacement = tag_replacement || "";
        let context = init_context(allowable_tags, tag_replacement);
        return function striptags_stream(html2) {
          return striptags_internal(html2 || "", context);
        };
      }
      striptags2.init_streaming_mode = init_striptags_stream;
      function init_context(allowable_tags, tag_replacement) {
        allowable_tags = parse_allowable_tags(allowable_tags);
        return {
          allowable_tags,
          tag_replacement,
          state: STATE_PLAINTEXT,
          tag_buffer: "",
          depth: 0,
          in_quote_char: ""
        };
      }
      function striptags_internal(html2, context) {
        if (typeof html2 != "string") {
          throw new TypeError("'html' parameter must be a string");
        }
        let allowable_tags = context.allowable_tags;
        let tag_replacement = context.tag_replacement;
        let state = context.state;
        let tag_buffer = context.tag_buffer;
        let depth = context.depth;
        let in_quote_char = context.in_quote_char;
        let output = "";
        for (let idx = 0, length = html2.length; idx < length; idx++) {
          let char = html2[idx];
          if (state === STATE_PLAINTEXT) {
            switch (char) {
              case "<":
                state = STATE_HTML;
                tag_buffer += char;
                break;
              default:
                output += char;
                break;
            }
          } else if (state === STATE_HTML) {
            switch (char) {
              case "<":
                if (in_quote_char) {
                  break;
                }
                depth++;
                break;
              case ">":
                if (in_quote_char) {
                  break;
                }
                if (depth) {
                  depth--;
                  break;
                }
                in_quote_char = "";
                state = STATE_PLAINTEXT;
                tag_buffer += ">";
                if (allowable_tags.has(normalize_tag(tag_buffer))) {
                  output += tag_buffer;
                } else {
                  output += tag_replacement;
                }
                tag_buffer = "";
                break;
              case '"':
              case "'":
                if (char === in_quote_char) {
                  in_quote_char = "";
                } else {
                  in_quote_char = in_quote_char || char;
                }
                tag_buffer += char;
                break;
              case "-":
                if (tag_buffer === "<!-") {
                  state = STATE_COMMENT;
                }
                tag_buffer += char;
                break;
              case " ":
              case "\n":
                if (tag_buffer === "<") {
                  state = STATE_PLAINTEXT;
                  output += "< ";
                  tag_buffer = "";
                  break;
                }
                tag_buffer += char;
                break;
              default:
                tag_buffer += char;
                break;
            }
          } else if (state === STATE_COMMENT) {
            switch (char) {
              case ">":
                if (tag_buffer.slice(-2) == "--") {
                  state = STATE_PLAINTEXT;
                }
                tag_buffer = "";
                break;
              default:
                tag_buffer += char;
                break;
            }
          }
        }
        context.state = state;
        context.tag_buffer = tag_buffer;
        context.depth = depth;
        context.in_quote_char = in_quote_char;
        return output;
      }
      function parse_allowable_tags(allowable_tags) {
        let tag_set = /* @__PURE__ */ new Set();
        if (typeof allowable_tags === "string") {
          let match;
          while (match = ALLOWED_TAGS_REGEX.exec(allowable_tags)) {
            tag_set.add(match[1]);
          }
        } else if (!Symbol2.nonNative && typeof allowable_tags[Symbol2.iterator] === "function") {
          tag_set = new Set(allowable_tags);
        } else if (typeof allowable_tags.forEach === "function") {
          allowable_tags.forEach(tag_set.add, tag_set);
        }
        return tag_set;
      }
      function normalize_tag(tag_buffer) {
        let match = NORMALIZE_TAG_REGEX.exec(tag_buffer);
        return match ? match[1].toLowerCase() : null;
      }
      if (module.exports) {
        module.exports = striptags2;
      } else {
        global.striptags = striptags2;
      }
    })(striptags);
  })(striptags$1);
  return striptags$1.exports;
}
requireStriptags();
function u(type, props, value) {
  const node2 = { type: String(type) };
  if ((value === void 0 || value === null) && (typeof props === "string" || Array.isArray(props))) {
    value = props;
  } else {
    Object.assign(node2, props);
  }
  if (Array.isArray(value)) {
    node2.children = value;
  } else if (value !== void 0 && value !== null) {
    node2.value = String(value);
  }
  return node2;
}
const convert$1 = (
  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok$3;
    }
    if (typeof test === "function") {
      return castFactory$2(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory$2(test) : propsFactory$1(test);
    }
    if (typeof test === "string") {
      return typeFactory$1(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory$2(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert$1(tests[index2]);
  }
  return castFactory$2(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, parameters)) return true;
    }
    return false;
  }
}
function propsFactory$1(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory$2(all2);
  function all2(node2) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node2
    );
    let key;
    for (key in check) {
      if (nodeAsRecord[key] !== checkAsRecord[key]) return false;
    }
    return true;
  }
}
function typeFactory$1(check) {
  return castFactory$2(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory$2(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeANode$1(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function ok$3() {
  return true;
}
function looksLikeANode$1(value) {
  return value !== null && typeof value === "object" && "type" in value;
}
function color$1(d) {
  return d;
}
const empty$2 = [];
const CONTINUE$1 = true;
const EXIT$1 = false;
const SKIP$1 = "skip";
function visitParents$1(tree, test, visitor, reverse) {
  let check;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
  } else {
    check = test;
  }
  const is = convert$1(check);
  const step = reverse ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node2, index2, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node2 && typeof node2 === "object" ? node2 : {}
    );
    if (typeof value.type === "string") {
      const name2 = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit2, "name", {
        value: "node (" + color$1(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = empty$2;
      let subresult;
      let offset;
      let grandparents;
      if (!test || is(node2, index2, parents[parents.length - 1] || void 0)) {
        result = toResult$1(visitor(node2, parents));
        if (result[0] === EXIT$1) {
          return result;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node2
        );
        if (nodeAsParent.children && result[0] !== SKIP$1) {
          offset = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset];
            subresult = factory(child, offset, grandparents)();
            if (subresult[0] === EXIT$1) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult$1(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE$1, value];
  }
  return value === null || value === void 0 ? empty$2 : [value];
}
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents$1(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index2 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index2, parent);
  }
}
const URL_PATTERN = /(\s|^)(https?:\/\/)([-A-Z0-9+_.]+(?::[0-9]+)?(?:\/[-A-Z0-9+&@#%?=~_|!:,.;()]*)*)(\s|$)/ig;
const URL_PATTERN_AUTOLINK = /(\s|\(|^)((https?:\/\/)([-A-Z0-9+_.]+[-A-Z0-9]+(?::[0-9]+)?(?:\/[-A-Z0-9+&@#%?=~_|!:,.;()]*)*))(?=\s|\)|$)/ig;
const NcLink = defineComponent({
  name: "NcLink",
  props: {
    href: {
      type: String,
      required: true
    }
  },
  render() {
    return h("a", {
      href: this.href,
      rel: "noopener noreferrer",
      target: "_blank",
      class: "rich-text--external-link"
    }, [this.href.trim()]);
  }
});
const remarkAutolink = function({ autolink: autolink2, useMarkdown, useExtendedMarkdown }) {
  return function(tree) {
    if (useExtendedMarkdown || !useMarkdown || !autolink2) {
      return;
    }
    visit(tree, (node2) => node2.type === "text", (node2, index2, parent) => {
      let parsed = parseUrl(node2.value);
      if (typeof parsed === "string") {
        parsed = [u("text", parsed)];
      } else {
        parsed = parsed.map((n) => {
          if (typeof n === "string") {
            return u("text", n);
          }
          return u("link", {
            url: n.props.href
          }, [u("text", n.props.href)]);
        }).filter((x2) => x2).flat();
      }
      parent.children.splice(index2, 1, ...parsed);
      return [SKIP$1, (index2 ?? 0) + parsed.length];
    });
  };
};
const parseUrl = (text2) => {
  let match = URL_PATTERN_AUTOLINK.exec(text2);
  const list2 = [];
  let start = 0;
  while (match !== null) {
    let href = match[2];
    let textAfter;
    let textBefore = text2.substring(start, match.index + match[1].length);
    if (href[0] === " ") {
      textBefore += href[0];
      href = href.substring(1).trim();
    }
    const lastChar = href[href.length - 1];
    if (lastChar === "." || lastChar === "," || lastChar === ";" || match[0][0] === "(" && lastChar === ")") {
      href = href.substring(0, href.length - 1);
      textAfter = lastChar;
    }
    list2.push(textBefore);
    list2.push({ component: NcLink, props: { href } });
    if (textAfter) {
      list2.push(textAfter);
    }
    start = match.index + match[0].length;
    match = URL_PATTERN_AUTOLINK.exec(text2);
  }
  list2.push(text2.substring(start));
  const joinedText = list2.map((item) => typeof item === "string" ? item : item.props.href).join("");
  if (text2 === joinedText) {
    return list2;
  }
  console.error("Failed to reassemble the chunked text: " + text2);
  return text2;
};
const getRoute = (router, url) => {
  const removePrefix = (str, prefix) => str.startsWith(prefix) ? str.slice(prefix.length) : str;
  const removePrefixes = (str, ...prefixes) => prefixes.reduce((acc, prefix) => removePrefix(acc, prefix), str);
  if (!router) {
    return null;
  }
  const isAbsoluteURL = /^https?:\/\//.test(url);
  const isNonHttpLink = /^[a-z][a-z0-9+.-]*:.+/.test(url);
  if (!isAbsoluteURL && isNonHttpLink) {
    return null;
  }
  if (isAbsoluteURL && !url.startsWith(w())) {
    return null;
  }
  if (!isAbsoluteURL && !url.startsWith("/")) {
    return null;
  }
  const relativeUrl = isAbsoluteURL ? removePrefixes(url, w(), "/index.php") : url;
  const relativeRouterBase = removePrefixes(router.options.history.base, f$1(), "/index.php");
  const potentialRouterPath = removePrefixes(relativeUrl, relativeRouterBase) || "/";
  const route = router.resolve(potentialRouterPath);
  if (!route.matched.length) {
    return null;
  }
  return route.fullPath;
};
const defaultWindow = isClient ? window : void 0;
function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
function useEventListener(...args) {
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register2 = (el, event, listener, options) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const firstParamTargets = computed(() => {
    const test = toArray(toValue(args[0])).filter((e2) => e2 != null);
    return test.every((e2) => typeof e2 !== "string") ? test : void 0;
  });
  const stopWatch = watchImmediate(
    () => {
      var _a, _b;
      return [
        (_b = (_a = firstParamTargets.value) == null ? void 0 : _a.map((e2) => unrefElement(e2))) != null ? _b : [defaultWindow].filter((e2) => e2 != null),
        toArray(toValue(firstParamTargets.value ? args[1] : args[0])),
        toArray(unref(firstParamTargets.value ? args[2] : args[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue(firstParamTargets.value ? args[3] : args[2])
      ];
    },
    ([raw_targets, raw_events, raw_listeners, raw_options]) => {
      cleanup();
      if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length))
        return;
      const optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;
      cleanups.push(
        ...raw_targets.flatMap(
          (el) => raw_events.flatMap(
            (event) => raw_listeners.map((listener) => register2(el, event, listener, optionsClone))
          )
        )
      );
    },
    { flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(cleanup);
  return stop;
}
let _iOSWorkaround = false;
function onClickOutside(target, handler, options = {}) {
  const { window: window2 = defaultWindow, ignore: ignore2 = [], capture = true, detectIframe = false, controls = false } = options;
  if (!window2) {
    return controls ? { stop: noop, cancel: noop, trigger: noop } : noop;
  }
  if (isIOS && !_iOSWorkaround) {
    _iOSWorkaround = true;
    const listenerOptions = { passive: true };
    Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop, listenerOptions));
    window2.document.documentElement.addEventListener("click", noop, listenerOptions);
  }
  let shouldListen = true;
  const shouldIgnore = (event) => {
    return toValue(ignore2).some((target2) => {
      if (typeof target2 === "string") {
        return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
      } else {
        const el = unrefElement(target2);
        return el && (event.target === el || event.composedPath().includes(el));
      }
    });
  };
  function hasMultipleRoots(target2) {
    const vm = toValue(target2);
    return vm && vm.$.subTree.shapeFlag === 16;
  }
  function checkMultipleRoots(target2, event) {
    const vm = toValue(target2);
    const children = vm.$.subTree && vm.$.subTree.children;
    if (children == null || !Array.isArray(children))
      return false;
    return children.some((child) => child.el === event.target || event.composedPath().includes(child.el));
  }
  const listener = (event) => {
    const el = unrefElement(target);
    if (event.target == null)
      return;
    if (!(el instanceof Element) && hasMultipleRoots(target) && checkMultipleRoots(target, event))
      return;
    if (!el || el === event.target || event.composedPath().includes(el))
      return;
    if ("detail" in event && event.detail === 0)
      shouldListen = !shouldIgnore(event);
    if (!shouldListen) {
      shouldListen = true;
      return;
    }
    handler(event);
  };
  let isProcessingClick = false;
  const cleanup = [
    useEventListener(window2, "click", (event) => {
      if (!isProcessingClick) {
        isProcessingClick = true;
        setTimeout(() => {
          isProcessingClick = false;
        }, 0);
        listener(event);
      }
    }, { passive: true, capture }),
    useEventListener(window2, "pointerdown", (e2) => {
      const el = unrefElement(target);
      shouldListen = !shouldIgnore(e2) && !!(el && !e2.composedPath().includes(el));
    }, { passive: true }),
    detectIframe && useEventListener(window2, "blur", (event) => {
      setTimeout(() => {
        var _a;
        const el = unrefElement(target);
        if (((_a = window2.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement))) {
          handler(event);
        }
      }, 0);
    }, { passive: true })
  ].filter(Boolean);
  const stop = () => cleanup.forEach((fn) => fn());
  if (controls) {
    return {
      stop,
      cancel: () => {
        shouldListen = false;
      },
      trigger: (event) => {
        shouldListen = true;
        listener(event);
        shouldListen = false;
      }
    };
  }
  return stop;
}
const stopClickOutsideMap = /* @__PURE__ */ new WeakMap();
const vOnClickOutside = {
  mounted(el, binding) {
    const capture = !binding.modifiers.bubble;
    let stop;
    if (typeof binding.value === "function") {
      stop = onClickOutside(el, binding.value, { capture });
    } else {
      const [handler, options] = binding.value;
      stop = onClickOutside(el, handler, Object.assign({ capture }, options));
    }
    stopClickOutsideMap.set(el, stop);
  },
  unmounted(el) {
    const stop = stopClickOutsideMap.get(el);
    if (stop && typeof stop === "function") {
      stop();
    } else {
      stop == null ? void 0 : stop.stop();
    }
    stopClickOutsideMap.delete(el);
  }
};
function resolveElement(el) {
  if (typeof Window !== "undefined" && el instanceof Window)
    return el.document.documentElement;
  if (typeof Document !== "undefined" && el instanceof Document)
    return el.documentElement;
  return el;
}
function checkOverflowScroll(ele) {
  const style = window.getComputedStyle(ele);
  if (style.overflowX === "scroll" || style.overflowY === "scroll" || style.overflowX === "auto" && ele.clientWidth < ele.scrollWidth || style.overflowY === "auto" && ele.clientHeight < ele.scrollHeight) {
    return true;
  } else {
    const parent = ele.parentNode;
    if (!parent || parent.tagName === "BODY")
      return false;
    return checkOverflowScroll(parent);
  }
}
function preventDefault(rawEvent) {
  const e2 = rawEvent || window.event;
  const _target = e2.target;
  if (checkOverflowScroll(_target))
    return false;
  if (e2.touches.length > 1)
    return true;
  if (e2.preventDefault)
    e2.preventDefault();
  return false;
}
const elInitialOverflow = /* @__PURE__ */ new WeakMap();
function useScrollLock(element2, initialState = false) {
  const isLocked = shallowRef(initialState);
  let stopTouchMoveListener = null;
  let initialOverflow = "";
  watch(toRef(element2), (el) => {
    const target = resolveElement(toValue(el));
    if (target) {
      const ele = target;
      if (!elInitialOverflow.get(ele))
        elInitialOverflow.set(ele, ele.style.overflow);
      if (ele.style.overflow !== "hidden")
        initialOverflow = ele.style.overflow;
      if (ele.style.overflow === "hidden")
        return isLocked.value = true;
      if (isLocked.value)
        return ele.style.overflow = "hidden";
    }
  }, {
    immediate: true
  });
  const lock = () => {
    const el = resolveElement(toValue(element2));
    if (!el || isLocked.value)
      return;
    if (isIOS) {
      stopTouchMoveListener = useEventListener(
        el,
        "touchmove",
        (e2) => {
          preventDefault(e2);
        },
        { passive: false }
      );
    }
    el.style.overflow = "hidden";
    isLocked.value = true;
  };
  const unlock = () => {
    const el = resolveElement(toValue(element2));
    if (!el || !isLocked.value)
      return;
    if (isIOS)
      stopTouchMoveListener == null ? void 0 : stopTouchMoveListener();
    el.style.overflow = initialOverflow;
    elInitialOverflow.delete(el);
    isLocked.value = false;
  };
  tryOnScopeDispose(unlock);
  return computed({
    get() {
      return isLocked.value;
    },
    set(v2) {
      if (v2)
        lock();
      else unlock();
    }
  });
}
function onScrollLock() {
  let isMounted = false;
  const state = shallowRef(false);
  return (el, binding) => {
    state.value = binding.value;
    if (isMounted)
      return;
    isMounted = true;
    const isLocked = useScrollLock(el, binding.value);
    watch(state, (v2) => isLocked.value = v2);
  };
}
onScrollLock();
const userStatus = {
  data() {
    return {
      hasStatus: false,
      userStatus: {
        status: null,
        message: null,
        icon: null
      }
    };
  },
  methods: {
    /**
     * Fetches the user-status from the server
     *
     * @param {string} userId UserId of the user to fetch the status for
     *
     * @return {Promise<void>}
     */
    async fetchUserStatus(userId) {
      if (!userId) {
        return;
      }
      const capabilities = e();
      if (!Object.prototype.hasOwnProperty.call(capabilities, "user_status") || !capabilities.user_status.enabled) {
        return;
      }
      if (!getCurrentUser()) {
        return;
      }
      try {
        const { data } = await cancelableClient.get(v("apps/user_status/api/v1/statuses/{userId}", { userId }));
        const {
          status,
          message,
          icon
        } = data.ocs.data;
        this.userStatus.status = status;
        this.userStatus.message = message || "";
        this.userStatus.icon = icon || "";
        this.hasStatus = true;
      } catch (e2) {
        if (e2.response.status === 404 && e2.response.data.ocs?.data?.length === 0) {
          return;
        }
        console.error(e2);
      }
    }
  }
};
register(t9);
const browserStorage = distExports.getBuilder("nextcloud").persist().build();
function getUserHasAvatar(userId) {
  const flag = browserStorage.getItem("user-has-avatar." + userId);
  if (typeof flag === "string") {
    return Boolean(flag);
  }
  return null;
}
function setUserHasAvatar(userId, flag) {
  if (userId) {
    browserStorage.setItem("user-has-avatar." + userId, flag);
  }
}
const _sfc_main$j = {
  name: "NcAvatar",
  directives: {
    ClickOutside: vOnClickOutside
  },
  components: {
    DotsHorizontal,
    NcActions,
    NcButton,
    NcIconSvgWrapper,
    NcLoadingIcon,
    NcUserStatusIcon
  },
  mixins: [userStatus],
  props: {
    /**
     * Set a custom url to the avatar image
     * either the url, user or displayName property must be defined
     */
    url: {
      type: String,
      default: void 0
    },
    /**
     * Set a css icon-class for an icon to be used instead of the avatar.
     */
    iconClass: {
      type: String,
      default: void 0
    },
    /**
     * Set the user id to fetch the avatar
     * either the url, user or displayName property must be defined
     */
    user: {
      type: String,
      default: void 0
    },
    /**
     * Do not show the user status on the avatar.
     */
    hideStatus: {
      type: Boolean,
      default: false
    },
    /**
     * Show the verbose user status (e.g. "online" / "away") instead of just the status icon.
     */
    verboseStatus: {
      type: Boolean,
      default: false
    },
    /**
     * When the user status was preloaded via another source it can be handed in with this property to save the request.
     * If this property is not set the status will be fetched automatically.
     * If a preloaded no-status is available provide this object with properties "status", "icon" and "message" set to null.
     */
    preloadedUserStatus: {
      type: Object,
      default: void 0
    },
    /**
     * Is the user a guest user (then we have to user a different endpoint)
     */
    isGuest: {
      type: Boolean,
      default: false
    },
    /**
     * Set a display name that will be rendered as a tooltip
     * either the url, user or displayName property must be defined
     * specify just the displayname to generate a placeholder avatar without
     * trying to fetch the avatar based on the user id
     */
    displayName: {
      type: String,
      default: void 0
    },
    /**
     * Set a size in px for the rendered avatar
     */
    size: {
      type: Number,
      default: 32
    },
    /**
     * Do not automatically generate a placeholder avatars if there is no real avatar is available.
     */
    noPlaceholder: {
      type: Boolean,
      default: false
    },
    /**
     * Disable the tooltip
     */
    disableTooltip: {
      type: Boolean,
      default: false
    },
    /**
     * Disable the menu
     */
    disableMenu: {
      type: Boolean,
      default: false
    },
    /**
     * Declares a custom tooltip when not null
     * Fallback will be the displayName
     *
     * requires disableTooltip not to be set to true
     */
    tooltipMessage: {
      type: String,
      default: null
    },
    /**
     * Declares username is not a user's name, when true.
     * Prevents loading user's avatar from server and forces generating colored initials,
     * i.e. if the user is a group
     */
    isNoUser: {
      type: Boolean,
      default: false
    },
    /**
     * Selector for the popover menu container
     */
    menuContainer: {
      type: [String, Object, Element, Boolean],
      default: "body"
    }
  },
  data() {
    return {
      avatarUrlLoaded: null,
      avatarSrcSetLoaded: null,
      userDoesNotExist: false,
      isAvatarLoaded: false,
      isMenuLoaded: false,
      contactsMenuLoading: false,
      contactsMenuData: {},
      contactsMenuActions: [],
      contactsMenuOpenState: false
    };
  },
  computed: {
    avatarAriaLabel() {
      if (!this.hasMenu) {
        return;
      }
      if (this.canDisplayUserStatus || this.showUserStatusIconOnAvatar) {
        return t("Avatar of {displayName}, {status}", { displayName: this.displayName ?? this.user, status: getUserStatusText(this.userStatus.status) });
      }
      return t("Avatar of {displayName}", { displayName: this.displayName ?? this.user });
    },
    canDisplayUserStatus() {
      return !this.hideStatus && this.hasStatus && ["online", "away", "busy", "dnd"].includes(this.userStatus.status);
    },
    showUserStatusIconOnAvatar() {
      return !this.hideStatus && !this.verboseStatus && this.hasStatus && this.userStatus.status !== "dnd" && this.userStatus.icon;
    },
    /**
     * The user identifier, either the display name if set or the user property
     * If both properties are not set an empty string is returned
     */
    userIdentifier() {
      if (this.isDisplayNameDefined) {
        return this.displayName;
      }
      if (this.isUserDefined) {
        return this.user;
      }
      return "";
    },
    isUserDefined() {
      return typeof this.user !== "undefined";
    },
    isDisplayNameDefined() {
      return typeof this.displayName !== "undefined";
    },
    isUrlDefined() {
      return typeof this.url !== "undefined";
    },
    hasMenu() {
      if (this.disableMenu) {
        return false;
      }
      if (this.isMenuLoaded) {
        return this.menu.length > 0;
      }
      return !(this.user === getCurrentUser()?.uid || this.userDoesNotExist || this.url);
    },
    /**
     * True if initials should be shown as the user icon fallback
     */
    showInitials() {
      return !this.noPlaceholder && this.userDoesNotExist && !(this.iconClass || this.$slots.icon?.());
    },
    avatarStyle() {
      return {
        "--size": this.size + "px",
        lineHeight: this.showInitials ? this.size + "px" : 0,
        fontSize: Math.round(this.size * 0.45) + "px"
      };
    },
    initialsWrapperStyle() {
      const { r, g, b } = usernameToColor(this.userIdentifier);
      return {
        backgroundColor: `rgba(${r}, ${g}, ${b}, 0.1)`
      };
    },
    initialsStyle() {
      const { r, g, b } = usernameToColor(this.userIdentifier);
      return {
        color: `rgb(${r}, ${g}, ${b})`
      };
    },
    tooltip() {
      if (this.disableTooltip) {
        return null;
      }
      if (this.tooltipMessage) {
        return this.tooltipMessage;
      }
      return this.displayName;
    },
    /**
     * Get the (max. two) initials of the user as uppcase string
     */
    initials() {
      let initials = "?";
      if (this.showInitials) {
        const user = this.userIdentifier.trim();
        if (user === "") {
          return initials;
        }
        const filteredChars = user.match(/[\p{L}\p{N}\s]/gu);
        if (filteredChars == null) {
          return initials;
        }
        const filtered = filteredChars.join("");
        const idx = filtered.lastIndexOf(" ");
        initials = String.fromCodePoint(filtered.codePointAt(0));
        if (idx !== -1) {
          initials = initials.concat(String.fromCodePoint(filtered.codePointAt(idx + 1)));
        }
      }
      return initials.toLocaleUpperCase();
    },
    menu() {
      const actions = this.contactsMenuActions.map((item) => {
        const route = getRoute(this.$router, item.hyperlink);
        return {
          ncActionComponent: route ? NcActionRouter : NcActionLink,
          ncActionComponentProps: route ? {
            to: route,
            icon: item.icon
          } : {
            href: item.hyperlink,
            icon: item.icon
          },
          text: item.title
        };
      });
      for (const action of getEnabledContactsMenuActions(this.contactsMenuData)) {
        try {
          actions.push({
            ncActionComponent: NcActionButton,
            ncActionComponentProps: {
              onClick: () => action.callback(this.contactsMenuData)
            },
            text: action.displayName(this.contactsMenuData),
            iconSvg: action.iconSvg(this.contactsMenuData)
          });
        } catch (error) {
          logger.error(`Failed to render ContactsMenu action ${action.id}`, {
            error,
            action
          });
        }
      }
      function escape(html2) {
        const text2 = document.createTextNode(html2);
        const p = document.createElement("p");
        p.appendChild(text2);
        return p.innerHTML;
      }
      if (!this.hideStatus && (this.userStatus.icon || this.userStatus.message)) {
        const emojiIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
					<text x="50%" y="50%" text-anchor="middle" style="dominant-baseline: central; font-size: 85%">${escape(this.userStatus.icon)}</text>
				</svg>`;
        return [{
          ncActionComponent: NcActionText,
          ncActionComponentProps: {},
          iconSvg: this.userStatus.icon ? emojiIcon : void 0,
          text: `${this.userStatus.message}`
        }].concat(actions);
      }
      return actions;
    }
  },
  watch: {
    url() {
      this.userDoesNotExist = false;
      this.loadAvatarUrl();
    },
    user() {
      this.userDoesNotExist = false;
      this.isMenuLoaded = false;
      this.loadAvatarUrl();
    }
  },
  mounted() {
    this.loadAvatarUrl();
    subscribe("settings:avatar:updated", this.loadAvatarUrl);
    subscribe("settings:display-name:updated", this.loadAvatarUrl);
    if (!this.hideStatus && this.user && !this.isNoUser) {
      if (!this.preloadedUserStatus) {
        this.fetchUserStatus(this.user);
      } else {
        this.userStatus.status = this.preloadedUserStatus.status || "";
        this.userStatus.message = this.preloadedUserStatus.message || "";
        this.userStatus.icon = this.preloadedUserStatus.icon || "";
        this.hasStatus = this.preloadedUserStatus.status !== null;
      }
      subscribe("user_status:status.updated", this.handleUserStatusUpdated);
    }
  },
  beforeUnmount() {
    unsubscribe("settings:avatar:updated", this.loadAvatarUrl);
    unsubscribe("settings:display-name:updated", this.loadAvatarUrl);
    if (!this.hideStatus && this.user && !this.isNoUser) {
      unsubscribe("user_status:status.updated", this.handleUserStatusUpdated);
    }
  },
  methods: {
    t,
    handleUserStatusUpdated(state) {
      if (this.user === state.userId) {
        this.userStatus = {
          status: state.status,
          icon: state.icon,
          message: state.message
        };
      }
    },
    /**
     * Toggle the popover menu on click or enter
     * @param {KeyboardEvent|MouseEvent} event the UI event
     */
    async toggleMenu(event) {
      if (event.type === "keydown" && event.key !== "Enter") {
        return;
      }
      if (!this.contactsMenuOpenState) {
        await this.fetchContactsMenu();
      }
      this.contactsMenuOpenState = !this.contactsMenuOpenState;
    },
    closeMenu() {
      this.contactsMenuOpenState = false;
    },
    async fetchContactsMenu() {
      this.contactsMenuLoading = true;
      try {
        const user = encodeURIComponent(this.user);
        const { data } = await cancelableClient.post(_("contactsmenu/findOne"), `shareType=0&shareWith=${user}`);
        this.contactsMenuData = data;
        this.contactsMenuActions = data.topAction ? [data.topAction].concat(data.actions) : data.actions;
      } catch (e2) {
        this.contactsMenuOpenState = false;
      }
      this.contactsMenuLoading = false;
      this.isMenuLoaded = true;
    },
    /**
     * Handle avatar loading if user or url defined
     */
    loadAvatarUrl() {
      this.isAvatarLoaded = false;
      if (!this.isUrlDefined && (!this.isUserDefined || this.isNoUser || this.iconClass)) {
        this.isAvatarLoaded = true;
        this.userDoesNotExist = true;
        return;
      }
      if (this.isUrlDefined) {
        this.updateImageIfValid(this.url);
        return;
      }
      if (this.size <= 64) {
        const avatarUrl = this.avatarUrlGenerator(this.user, 64);
        const srcset = [
          avatarUrl + " 1x",
          this.avatarUrlGenerator(this.user, 512) + " 8x"
        ].join(", ");
        this.updateImageIfValid(avatarUrl, srcset);
      } else {
        const avatarUrl = this.avatarUrlGenerator(this.user, 512);
        this.updateImageIfValid(avatarUrl);
      }
    },
    /**
     * Generate an avatar url from the server's avatar endpoint
     *
     * @param {string} user the user id
     * @param {number} size the desired size
     * @return {string}
     */
    avatarUrlGenerator(user, size) {
      let avatarUrl = getAvatarUrl(user, size, this.isGuest);
      if (user === getCurrentUser()?.uid && typeof oc_userconfig !== "undefined") {
        avatarUrl += "?v=" + oc_userconfig.avatar.version;
      }
      return avatarUrl;
    },
    /**
     * Check if the provided url is valid and update Avatar if so
     *
     * @param {string} url the avatar url
     * @param {Array} srcset the avatar srcset
     */
    updateImageIfValid(url, srcset = null) {
      const userHasAvatar = getUserHasAvatar(this.user);
      if (this.isUserDefined && typeof userHasAvatar === "boolean") {
        this.isAvatarLoaded = true;
        this.avatarUrlLoaded = url;
        if (srcset) {
          this.avatarSrcSetLoaded = srcset;
        }
        if (userHasAvatar === false) {
          this.userDoesNotExist = true;
        }
        return;
      }
      const img = new Image();
      img.onload = () => {
        this.avatarUrlLoaded = url;
        if (srcset) {
          this.avatarSrcSetLoaded = srcset;
        }
        this.isAvatarLoaded = true;
        setUserHasAvatar(this.user, true);
      };
      img.onerror = () => {
        console.debug("Invalid avatar url", url);
        this.avatarUrlLoaded = null;
        this.avatarSrcSetLoaded = null;
        this.userDoesNotExist = true;
        this.isAvatarLoaded = false;
        setUserHasAvatar(this.user, false);
      };
      if (srcset) {
        img.srcset = srcset;
      }
      img.src = url;
    }
  }
};
const _hoisted_1$d = ["title", "tabindex", "aria-label", "role"];
const _hoisted_2$8 = ["src", "srcset"];
const _hoisted_3$7 = {
  key: 2,
  class: "avatardiv__user-status avatardiv__user-status--icon"
};
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_NcLoadingIcon = resolveComponent("NcLoadingIcon");
  const _component_DotsHorizontal = resolveComponent("DotsHorizontal");
  const _component_NcButton = resolveComponent("NcButton");
  const _component_NcIconSvgWrapper = resolveComponent("NcIconSvgWrapper");
  const _component_NcActions = resolveComponent("NcActions");
  const _component_NcUserStatusIcon = resolveComponent("NcUserStatusIcon");
  const _directive_click_outside = resolveDirective("click-outside");
  return withDirectives((openBlock(), createElementBlock("span", mergeProps({
    ref: "main",
    title: $options.tooltip,
    class: [{
      "avatardiv--unknown": $data.userDoesNotExist,
      "avatardiv--with-menu": $options.hasMenu,
      "avatardiv--with-menu-loading": $data.contactsMenuLoading
    }, "avatardiv popovermenu-wrapper"],
    style: $options.avatarStyle,
    tabindex: $options.hasMenu ? "0" : void 0,
    "aria-label": $options.avatarAriaLabel,
    role: $options.hasMenu ? "button" : void 0
  }, toHandlers($options.hasMenu ? {
    click: $options.toggleMenu,
    keydown: $options.toggleMenu
  } : {}, true)), [
    renderSlot(_ctx.$slots, "icon", {}, () => [
      $props.iconClass ? (openBlock(), createElementBlock("span", {
        key: 0,
        class: normalizeClass([$props.iconClass, "avatar-class-icon"])
      }, null, 2)) : $data.isAvatarLoaded && !$data.userDoesNotExist ? (openBlock(), createElementBlock("img", {
        key: 1,
        src: $data.avatarUrlLoaded,
        srcset: $data.avatarSrcSetLoaded,
        alt: ""
      }, null, 8, _hoisted_2$8)) : createCommentVNode("", true)
    ], true),
    $options.hasMenu && $options.menu.length === 0 ? (openBlock(), createBlock(_component_NcButton, {
      key: 0,
      "aria-label": $options.avatarAriaLabel,
      class: "action-item action-item__menutoggle",
      variant: "tertiary-no-background",
      onClick: $options.toggleMenu
    }, {
      icon: withCtx(() => [
        $data.contactsMenuLoading ? (openBlock(), createBlock(_component_NcLoadingIcon, { key: 0 })) : (openBlock(), createBlock(_component_DotsHorizontal, {
          key: 1,
          size: 20
        }))
      ]),
      _: 1
    }, 8, ["aria-label", "onClick"])) : $options.hasMenu ? (openBlock(), createBlock(_component_NcActions, {
      key: 1,
      open: $data.contactsMenuOpenState,
      "onUpdate:open": _cache[0] || (_cache[0] = ($event) => $data.contactsMenuOpenState = $event),
      "aria-label": $options.avatarAriaLabel,
      container: $props.menuContainer,
      "force-menu": "",
      "manual-open": "",
      variant: "tertiary-no-background",
      onClick: $options.toggleMenu
    }, createSlots({
      default: withCtx(() => [
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.menu, (item, key) => {
          return openBlock(), createBlock(resolveDynamicComponent(item.ncActionComponent), mergeProps({
            key,
            ref_for: true
          }, item.ncActionComponentProps), createSlots({
            default: withCtx(() => [
              createTextVNode(" " + toDisplayString(item.text), 1)
            ]),
            _: 2
          }, [
            item.iconSvg ? {
              name: "icon",
              fn: withCtx(() => [
                createVNode(_component_NcIconSvgWrapper, {
                  svg: item.iconSvg
                }, null, 8, ["svg"])
              ]),
              key: "0"
            } : void 0
          ]), 1040);
        }), 128))
      ]),
      _: 2
    }, [
      $data.contactsMenuLoading ? {
        name: "icon",
        fn: withCtx(() => [
          createVNode(_component_NcLoadingIcon)
        ]),
        key: "0"
      } : void 0
    ]), 1032, ["open", "aria-label", "container", "onClick"])) : createCommentVNode("", true),
    $options.showUserStatusIconOnAvatar ? (openBlock(), createElementBlock("span", _hoisted_3$7, toDisplayString(_ctx.userStatus.icon), 1)) : $options.canDisplayUserStatus ? (openBlock(), createBlock(_component_NcUserStatusIcon, {
      key: 3,
      class: "avatardiv__user-status",
      status: _ctx.userStatus.status,
      "aria-hidden": String($options.hasMenu)
    }, null, 8, ["status", "aria-hidden"])) : createCommentVNode("", true),
    $options.showInitials ? (openBlock(), createElementBlock("span", {
      key: 4,
      style: normalizeStyle($options.initialsWrapperStyle),
      class: "avatardiv__initials-wrapper"
    }, [
      createBaseVNode("span", {
        style: normalizeStyle($options.initialsStyle),
        class: "avatardiv__initials"
      }, toDisplayString($options.initials), 5)
    ], 4)) : createCommentVNode("", true)
  ], 16, _hoisted_1$d)), [
    [_directive_click_outside, $options.closeMenu]
  ]);
}
const NcAvatar = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$i], ["__scopeId", "data-v-af2d3203"]]);
register(t2);
const FEW_SECONDS_AGO = {
  long: t("a few seconds ago"),
  short: t("seconds ago"),
  // FOR TRANSLATORS: Shorter version of 'a few seconds ago'
  narrow: t("sec. ago")
  // FOR TRANSLATORS: If possible in your language an even shorter version of 'a few seconds ago'
};
function useFormatDateTime(timestamp = Date.now(), opts = {}) {
  const currentTime = ref(Date.now());
  let intervalId;
  const options = ref({
    format: {
      timeStyle: "medium",
      dateStyle: "short"
    },
    relativeTime: "long",
    ignoreSeconds: false,
    ...toValue(opts)
  });
  const wrappedOptions = computed(() => ({ ...toValue(opts), ...options.value }));
  const date = computed(() => new Date(toValue(timestamp)));
  const formattedFullTime = computed(() => {
    const formatter = new Intl.DateTimeFormat(getCanonicalLocale(), wrappedOptions.value.format);
    return formatter.format(date.value);
  });
  const formattedTime = computed(() => {
    if (wrappedOptions.value.relativeTime !== false) {
      const formatter = new Intl.RelativeTimeFormat(getLanguage(), { numeric: "auto", style: wrappedOptions.value.relativeTime });
      const diff = date.value.getTime() - currentTime.value;
      const seconds = diff / 1e3;
      if (Math.abs(seconds) <= 90) {
        if (wrappedOptions.value.ignoreSeconds) {
          return FEW_SECONDS_AGO[wrappedOptions.value.relativeTime];
        } else {
          return formatter.format(Math.round(seconds), "second");
        }
      }
      const minutes = seconds / 60;
      if (Math.abs(minutes) <= 90) {
        return formatter.format(Math.round(minutes), "minute");
      }
      const hours = minutes / 60;
      if (Math.abs(hours) <= 24) {
        return formatter.format(Math.round(hours), "hour");
      }
      const days = hours / 24;
      if (Math.abs(days) <= 6) {
        return formatter.format(Math.round(days), "day");
      }
      const weeks = days / 7;
      if (Math.abs(weeks) <= 4) {
        return formatter.format(Math.round(weeks), "week");
      }
      const months = days / 30;
      if (Math.abs(months) <= 12) {
        return formatter.format(Math.round(months), "month");
      }
      return formatter.format(Math.round(days / 365), "year");
    }
    return formattedFullTime.value;
  });
  watchEffect(() => {
    window.clearInterval(intervalId);
    intervalId = void 0;
    if (wrappedOptions.value.relativeTime) {
      intervalId = window.setInterval(() => {
        currentTime.value = Date.now();
      }, 1e3);
    }
  });
  onUnmounted(() => {
    window.clearInterval(intervalId);
  });
  return {
    formattedTime,
    formattedFullTime,
    options
  };
}
const _hoisted_1$c = ["data-timestamp", "title", "textContent"];
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "NcDateTime",
  props: {
    timestamp: {},
    format: { default: () => ({ timeStyle: "medium", dateStyle: "short" }) },
    relativeTime: { type: [Boolean, String], default: "long" },
    ignoreSeconds: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    const {
      formattedTime,
      formattedFullTime
    } = useFormatDateTime(toRef$1(() => props.timestamp), props);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", {
        class: "nc-datetime",
        "data-timestamp": _ctx.timestamp,
        title: unref(formattedFullTime),
        textContent: toDisplayString(unref(formattedTime))
      }, null, 8, _hoisted_1$c);
    };
  }
});
function bail(error) {
  if (error) {
    throw error;
  }
}
var extend$1;
var hasRequiredExtend;
function requireExtend() {
  if (hasRequiredExtend) return extend$1;
  hasRequiredExtend = 1;
  var hasOwn = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var defineProperty = Object.defineProperty;
  var gOPD = Object.getOwnPropertyDescriptor;
  var isArray = function isArray2(arr) {
    if (typeof Array.isArray === "function") {
      return Array.isArray(arr);
    }
    return toStr.call(arr) === "[object Array]";
  };
  var isPlainObject2 = function isPlainObject3(obj) {
    if (!obj || toStr.call(obj) !== "[object Object]") {
      return false;
    }
    var hasOwnConstructor = hasOwn.call(obj, "constructor");
    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
      return false;
    }
    var key;
    for (key in obj) {
    }
    return typeof key === "undefined" || hasOwn.call(obj, key);
  };
  var setProperty = function setProperty2(target, options) {
    if (defineProperty && options.name === "__proto__") {
      defineProperty(target, options.name, {
        enumerable: true,
        configurable: true,
        value: options.newValue,
        writable: true
      });
    } else {
      target[options.name] = options.newValue;
    }
  };
  var getProperty = function getProperty2(obj, name2) {
    if (name2 === "__proto__") {
      if (!hasOwn.call(obj, name2)) {
        return void 0;
      } else if (gOPD) {
        return gOPD(obj, name2).value;
      }
    }
    return obj[name2];
  };
  extend$1 = function extend2() {
    var options, name2, src, copy, copyIsArray, clone;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (target == null || typeof target !== "object" && typeof target !== "function") {
      target = {};
    }
    for (; i < length; ++i) {
      options = arguments[i];
      if (options != null) {
        for (name2 in options) {
          src = getProperty(target, name2);
          copy = getProperty(options, name2);
          if (target !== copy) {
            if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray(src) ? src : [];
              } else {
                clone = src && isPlainObject2(src) ? src : {};
              }
              setProperty(target, { name: name2, newValue: extend2(deep, clone, copy) });
            } else if (typeof copy !== "undefined") {
              setProperty(target, { name: name2, newValue: copy });
            }
          }
        }
      }
    }
    return target;
  };
  return extend$1;
}
var extendExports = requireExtend();
const extend = /* @__PURE__ */ getDefaultExportFromCjs(extendExports);
class AssertionError extends Error {
  name = (
    /** @type {const} */
    "Assertion"
  );
  code = (
    /** @type {const} */
    "ERR_ASSERTION"
  );
  /**
   * Create an assertion error.
   *
   * @param {string} message
   *   Message explaining error.
   * @param {unknown} actual
   *   Value.
   * @param {unknown} expected
   *   Baseline.
   * @param {string} operator
   *   Name of equality operation.
   * @param {boolean} generated
   *   Whether `message` is a custom message or not
   * @returns
   *   Instance.
   */
  // eslint-disable-next-line max-params
  constructor(message, actual, expected, operator, generated) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.actual = actual;
    this.expected = expected;
    this.generated = generated;
    this.operator = operator;
  }
}
function ok$2(value, message) {
  assert(
    Boolean(value),
    false,
    true,
    "ok",
    "Expected value to be truthy",
    message
  );
}
function assert(bool, actual, expected, operator, defaultMessage, userMessage) {
  if (!bool) {
    throw userMessage instanceof Error ? userMessage : new AssertionError(
      userMessage || defaultMessage,
      actual,
      expected,
      operator,
      !userMessage
    );
  }
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values2) {
    let middlewareIndex = -1;
    const callback = values2.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values2);
    function next(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index2 < values2.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values2[index2];
        }
      }
      values2 = output;
      if (fn) {
        wrap$1(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap$1(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error) {
      const exception = (
        /** @type {Error} */
        error
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position$1(value.position);
  }
  if ("start" in value || "end" in value) {
    return position$1(value);
  }
  if ("line" in value || "column" in value) {
    return point$2(value);
  }
  return "";
}
function point$2(point2) {
  return index(point2 && point2.line) + ":" + index(point2 && point2.column);
}
function position$1(pos) {
  return point$2(pos && pos.start) + "-" + point$2(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}
class VFileMessage extends Error {
  /**
   * Create a message for `reason`.
   *
   * > ðŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options.cause = causeOrReason;
    }
    if (!options.ruleId && !options.source && typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        options.ruleId = origin;
      } else {
        options.source = origin.slice(0, index2);
        options.ruleId = origin.slice(index2 + 1);
      }
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      if (parent) {
        options.place = parent.position;
      }
    }
    const start = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || void 0;
    this.cause = options.cause || void 0;
    this.column = start ? start.column : void 0;
    this.fatal = void 0;
    this.file;
    this.message = reason;
    this.line = start ? start.line : void 0;
    this.name = stringifyPosition(options.place) || "1:1";
    this.place = options.place || void 0;
    this.reason = this.message;
    this.ruleId = options.ruleId || void 0;
    this.source = options.source || void 0;
    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
    this.actual;
    this.expected;
    this.note;
    this.url;
  }
}
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;
const minpath = { basename, dirname, extname, join, sep: "/" };
function basename(path2, extname2) {
  if (extname2 !== void 0 && typeof extname2 !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath$1(path2);
  let start = 0;
  let end = -1;
  let index2 = path2.length;
  let seenNonSlash;
  if (extname2 === void 0 || extname2.length === 0 || extname2.length > path2.length) {
    while (index2--) {
      if (path2.codePointAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path2.slice(start, end);
  }
  if (extname2 === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extnameIndex = extname2.length - 1;
  while (index2--) {
    if (path2.codePointAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extnameIndex > -1) {
        if (path2.codePointAt(index2) === extname2.codePointAt(extnameIndex--)) {
          if (extnameIndex < 0) {
            end = index2;
          }
        } else {
          extnameIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path2.length;
  }
  return path2.slice(start, end);
}
function dirname(path2) {
  assertPath$1(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end = -1;
  let index2 = path2.length;
  let unmatchedSlash;
  while (--index2) {
    if (path2.codePointAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end);
}
function extname(path2) {
  assertPath$1(path2);
  let index2 = path2.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code2 = path2.codePointAt(index2);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath$1(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize$1(joined);
}
function normalize$1(path2) {
  assertPath$1(path2);
  const absolute = path2.codePointAt(0) === 47;
  let value = normalizeString(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code2;
  let lastSlashIndex;
  while (++index2 <= path2.length) {
    if (index2 < path2.length) {
      code2 = path2.codePointAt(index2);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index2 - 1 || dots === 1) ;
      else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index2);
        } else {
          result = path2.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath$1(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}
const minproc = { cwd };
function cwd() {
  return "/";
}
function isUrl(fileUrlOrPath) {
  return Boolean(
    fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
    fileUrlOrPath.auth === void 0
  );
}
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error.code = "ERR_INVALID_ARG_TYPE";
    throw error;
  }
  if (path2.protocol !== "file:") {
    const error = new TypeError("The URL must be of scheme file");
    error.code = "ERR_INVALID_URL_SCHEME";
    throw error;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error.code = "ERR_INVALID_FILE_URL_HOST";
    throw error;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
      const third = pathname.codePointAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error.code = "ERR_INVALID_FILE_URL_PATH";
        throw error;
      }
    }
  }
  return decodeURIComponent(pathname);
}
const order = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class VFile {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` â€” `{value: options}`
   * *   `URL` â€” `{path: options}`
   * *   `VFile` â€” shallow copies its data over to the new file
   * *   `object` â€” all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (isUrl(value)) {
      options = { path: value };
    } else if (typeof value === "string" || isUint8Array$1(value)) {
      options = { value };
    } else {
      options = value;
    }
    this.cwd = "cwd" in options ? "" : minproc.cwd();
    this.data = {};
    this.history = [];
    this.messages = [];
    this.value;
    this.map;
    this.result;
    this.stored;
    let index2 = -1;
    while (++index2 < order.length) {
      const field2 = order[index2];
      if (field2 in options && options[field2] !== void 0 && options[field2] !== null) {
        this[field2] = field2 === "history" ? [...options[field2]] : options[field2];
      }
    }
    let field;
    for (field in options) {
      if (!order.includes(field)) {
        this[field] = options[field];
      }
    }
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path === "string" ? minpath.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = minpath.join(this.dirname || "", basename2);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path === "string" ? minpath.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if thereâ€™s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(dirname2) {
    assertPath(this.basename, "dirname");
    this.path = minpath.join(dirname2 || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path === "string" ? minpath.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if thereâ€™s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath(this.dirname, "extname");
    if (extname2) {
      if (extname2.codePointAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = minpath.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(path2) {
    if (isUrl(path2)) {
      path2 = urlToPath(path2);
    }
    assertNonEmpty(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path === "string" ? minpath.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ðŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = true;
    throw message;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ðŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = void 0;
    return message;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ðŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = new VFileMessage(
      // @ts-expect-error: the overloads are fine.
      causeOrReason,
      optionsOrParentOrPlace,
      origin
    );
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when itâ€™s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    if (this.value === void 0) {
      return "";
    }
    if (typeof this.value === "string") {
      return this.value;
    }
    const decoder = new TextDecoder(encoding || void 0);
    return decoder.decode(this.value);
  }
}
function assertPart(part, name2) {
  if (part && part.includes(minpath.sep)) {
    throw new Error(
      "`" + name2 + "` cannot be a path: did not expect `" + minpath.sep + "`"
    );
  }
}
function assertNonEmpty(part, name2) {
  if (!part) {
    throw new Error("`" + name2 + "` cannot be empty");
  }
}
function assertPath(path2, name2) {
  if (!path2) {
    throw new Error("Setting `" + name2 + "` requires `path` to be set too");
  }
}
function isUint8Array$1(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}
const CallableInstance = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(property) {
    const self2 = this;
    const constr = self2.constructor;
    const proto = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      constr.prototype
    );
    const value = proto[property];
    const apply = function() {
      return value.apply(apply, arguments);
    };
    Object.setPrototypeOf(apply, proto);
    return apply;
  }
);
const own$3 = {}.hasOwnProperty;
class Processor extends CallableInstance {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy");
    this.Compiler = void 0;
    this.Parser = void 0;
    this.attachers = [];
    this.compiler = void 0;
    this.freezeIndex = -1;
    this.frozen = void 0;
    this.namespace = {};
    this.parser = void 0;
    this.transformers = trough();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const destination = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Processor()
    );
    let index2 = -1;
    while (++index2 < this.attachers.length) {
      const attacher = this.attachers[index2];
      destination.use(...attacher);
    }
    destination.data(extend(true, {}, this.namespace));
    return destination;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", this.frozen);
        this.namespace[key] = value;
        return this;
      }
      return own$3.call(this.namespace, key) && this.namespace[key] || void 0;
    }
    if (key) {
      assertUnfrozen("data", this.frozen);
      this.namespace = key;
      return this;
    }
    return this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Itâ€™s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen) {
      return this;
    }
    const self2 = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    while (++this.freezeIndex < this.attachers.length) {
      const [attacher, ...options] = this.attachers[this.freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(self2, ...options);
      if (typeof transformer === "function") {
        this.transformers.use(transformer);
      }
    }
    this.frozen = true;
    this.freezeIndex = Number.POSITIVE_INFINITY;
    return this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(file) {
    this.freeze();
    const realFile = vfile(file);
    const parser = this.parser || this.Parser;
    assertParser("parse", parser);
    return parser(String(realFile), realFile);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(file, done) {
    const self2 = this;
    this.freeze();
    assertParser("process", this.parser || this.Parser);
    assertCompiler("process", this.compiler || this.Compiler);
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      const parseTree = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        self2.parse(realFile)
      );
      self2.run(parseTree, realFile, function(error, tree, file2) {
        if (error || !tree || !file2) {
          return realDone(error);
        }
        const compileTree = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          tree
        );
        const compileResult = self2.stringify(compileTree, file2);
        if (looksLikeAValue(compileResult)) {
          file2.value = compileResult;
        } else {
          file2.result = compileResult;
        }
        realDone(
          error,
          /** @type {VFileWithOutput<CompileResult>} */
          file2
        );
      });
      function realDone(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve) {
          resolve(file2);
        } else {
          ok$2(done, "`done` is defined if `resolve` is not");
          done(void 0, file2);
        }
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(file) {
    let complete = false;
    let result;
    this.freeze();
    assertParser("processSync", this.parser || this.Parser);
    assertCompiler("processSync", this.compiler || this.Compiler);
    this.process(file, realDone);
    assertDone("processSync", "process", complete);
    ok$2(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error, file2) {
      complete = true;
      bail(error);
      result = file2;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(tree, file, done) {
    assertNode(tree);
    this.freeze();
    const transformers = this.transformers;
    if (!done && typeof file === "function") {
      done = file;
      file = void 0;
    }
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      ok$2(
        typeof file !== "function",
        "`file` canâ€™t be a `done` anymore, we checked"
      );
      const realFile = vfile(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error, outputTree, file2) {
        const resultingTree = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          outputTree || tree
        );
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(resultingTree);
        } else {
          ok$2(done, "`done` is defined if `resolve` is not");
          done(void 0, resultingTree, file2);
        }
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(tree, file) {
    let complete = false;
    let result;
    this.run(tree, file, realDone);
    assertDone("runSync", "run", complete);
    ok$2(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error, tree2) {
      bail(error);
      result = tree2;
      complete = true;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile(file);
    const compiler2 = this.compiler || this.Compiler;
    assertCompiler("stringify", compiler2);
    assertNode(tree);
    return compiler2(tree, realFile);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(value, ...parameters) {
    const attachers = this.attachers;
    const namespace = this.namespace;
    assertUnfrozen("use", this.frozen);
    if (value === null || value === void 0) ;
    else if (typeof value === "function") {
      addPlugin(value, parameters);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    return this;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2, []);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...parameters2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            value2
          );
          addPlugin(plugin, parameters2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      if (!("plugins" in result) && !("settings" in result)) {
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      }
      addList(result.plugins);
      if (result.settings) {
        namespace.settings = extend(true, namespace.settings, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0) ;
      else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, parameters2) {
      let index2 = -1;
      let entryIndex = -1;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entryIndex = index2;
          break;
        }
      }
      if (entryIndex === -1) {
        attachers.push([plugin, ...parameters2]);
      } else if (parameters2.length > 0) {
        let [primary, ...rest] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        if (isPlainObject(currentPrimary) && isPlainObject(primary)) {
          primary = extend(true, currentPrimary, primary);
        }
        attachers[entryIndex] = [plugin, primary, ...rest];
      }
    }
  }
}
const unified = new Processor().freeze();
function assertParser(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `parser`");
  }
}
function assertCompiler(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `compiler`");
  }
}
function assertUnfrozen(name2, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name2, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAValue(value) {
  return typeof value === "string" || isUint8Array(value);
}
function isUint8Array(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}
const emptyOptions$5 = {};
function toString$2(value, options) {
  const settings = emptyOptions$5;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one$2(value, includeImageAlt, includeHtml);
}
function one$2(value, includeImageAlt, includeHtml) {
  if (node$1(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all$1(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all$1(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all$1(values2, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values2.length) {
    result[index2] = one$2(values2[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node$1(value) {
  return Boolean(value && typeof value === "object");
}
const element$2 = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element$2.innerHTML = characterReference2;
  const character = element$2.textContent;
  if (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    character.charCodeAt(character.length - 1) === 59 && value !== "semi"
  ) {
    return false;
  }
  return character === characterReference2 ? false : character;
}
const codes = (
  /** @type {const} */
  {
    carriageReturn: -5,
    lineFeed: -4,
    carriageReturnLineFeed: -3,
    horizontalTab: -2,
    virtualSpace: -1,
    eof: null,
    nul: 0,
    ht: 9,
    // `\t`
    lf: 10,
    // `\n`
    vt: 11,
    // `\v`
    cr: 13,
    // `\r`
    space: 32,
    exclamationMark: 33,
    // `!`
    quotationMark: 34,
    // `"`
    numberSign: 35,
    // `#`
    percentSign: 37,
    // `%`
    ampersand: 38,
    // `&`
    apostrophe: 39,
    // `'`
    leftParenthesis: 40,
    // `(`
    rightParenthesis: 41,
    // `)`
    asterisk: 42,
    // `*`
    plusSign: 43,
    // `+`
    dash: 45,
    // `-`
    dot: 46,
    // `.`
    slash: 47,
    // `/`
    digit0: 48,
    // `0`
    digit1: 49,
    // `1`
    digit2: 50,
    // `2`
    digit3: 51,
    // `3`
    digit4: 52,
    // `4`
    digit5: 53,
    // `5`
    digit6: 54,
    // `6`
    digit7: 55,
    // `7`
    digit8: 56,
    // `8`
    digit9: 57,
    // `9`
    colon: 58,
    // `:`
    semicolon: 59,
    // `;`
    lessThan: 60,
    // `<`
    equalsTo: 61,
    // `=`
    greaterThan: 62,
    // `>`
    questionMark: 63,
    // `?`
    atSign: 64,
    // `@`
    uppercaseX: 88,
    // `X`
    leftSquareBracket: 91,
    // `[`
    backslash: 92,
    // `\`
    rightSquareBracket: 93,
    // `]`
    caret: 94,
    // `^`
    underscore: 95,
    // `_`
    graveAccent: 96,
    // `` ` ``
    lowercaseX: 120,
    // `x`
    tilde: 126,
    // `~`
    del: 127,
    // Unicode Specials block.
    byteOrderMarker: 65279,
    // Unicode Specials block.
    replacementCharacter: 65533
    // `ï¿½`
  }
);
const constants = (
  /** @type {const} */
  {
    atxHeadingOpeningFenceSizeMax: 6,
    // 6 number signs is fine, 7 isnâ€™t.
    autolinkDomainSizeMax: 63,
    // 63 characters is fine, 64 is too many.
    autolinkSchemeSizeMax: 32,
    // 32 characters is fine, 33 is too many.
    cdataOpeningString: "CDATA[",
    // And preceded by `<![`.
    characterGroupPunctuation: 2,
    // Symbol used to indicate a character is punctuation
    characterGroupWhitespace: 1,
    // Symbol used to indicate a character is whitespace
    characterReferenceDecimalSizeMax: 7,
    // `&#9999999;`.
    characterReferenceHexadecimalSizeMax: 6,
    // `&#xff9999;`.
    characterReferenceNamedSizeMax: 31,
    // `&CounterClockwiseContourIntegral;`.
    codeFencedSequenceSizeMin: 3,
    // At least 3 ticks or tildes are needed.
    contentTypeContent: "content",
    contentTypeFlow: "flow",
    contentTypeString: "string",
    contentTypeText: "text",
    hardBreakPrefixSizeMin: 2,
    // At least 2 trailing spaces are needed.
    htmlBasic: 6,
    // Symbol for `<div`
    htmlCdata: 5,
    // Symbol for `<![CDATA[]]>`
    htmlComment: 2,
    // Symbol for `<!---->`
    htmlComplete: 7,
    // Symbol for `<x>`
    htmlDeclaration: 4,
    // Symbol for `<!doctype>`
    htmlInstruction: 3,
    // Symbol for `<?php?>`
    htmlRawSizeMax: 8,
    // Length of `textarea`.
    htmlRaw: 1,
    // Symbol for `<script>`
    linkResourceDestinationBalanceMax: 32,
    // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>
    linkReferenceSizeMax: 999,
    // See: <https://spec.commonmark.org/0.30/#link-label>
    listItemValueSizeMax: 10,
    // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>
    numericBaseDecimal: 10,
    numericBaseHexadecimal: 16,
    tabSize: 4,
    // Tabs have a hard-coded size of 4, per CommonMark.
    thematicBreakMarkerCountMin: 3,
    // At least 3 asterisks, dashes, or underscores are needed.
    v8MaxSafeChunkSize: 1e4
    // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.
  }
);
const types$1 = (
  /** @type {const} */
  {
    // Generic type for data, such as in a title, a destination, etc.
    data: "data",
    // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).
    // Such as, between a fenced code fence and an info string.
    whitespace: "whitespace",
    // Generic type for line endings (line feed, carriage return, carriage return +
    // line feed).
    lineEnding: "lineEnding",
    // A line ending, but ending a blank line.
    lineEndingBlank: "lineEndingBlank",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
    // line.
    linePrefix: "linePrefix",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a
    // line.
    lineSuffix: "lineSuffix",
    // Whole ATX heading:
    //
    // ```markdown
    // #
    // ## Alpha
    // ### Bravo ###
    // ```
    //
    // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.
    atxHeading: "atxHeading",
    // Sequence of number signs in an ATX heading (`###`).
    atxHeadingSequence: "atxHeadingSequence",
    // Content in an ATX heading (`alpha`).
    // Includes text.
    atxHeadingText: "atxHeadingText",
    // Whole autolink (`<https://example.com>` or `<admin@example.com>`)
    // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.
    autolink: "autolink",
    // Email autolink w/o markers (`admin@example.com`)
    autolinkEmail: "autolinkEmail",
    // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).
    autolinkMarker: "autolinkMarker",
    // Protocol autolink w/o markers (`https://example.com`)
    autolinkProtocol: "autolinkProtocol",
    // A whole character escape (`\-`).
    // Includes `escapeMarker` and `characterEscapeValue`.
    characterEscape: "characterEscape",
    // The escaped character (`-`).
    characterEscapeValue: "characterEscapeValue",
    // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).
    // Includes `characterReferenceMarker`, an optional
    // `characterReferenceMarkerNumeric`, in which case an optional
    // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.
    characterReference: "characterReference",
    // The start or end marker (`&` or `;`).
    characterReferenceMarker: "characterReferenceMarker",
    // Mark reference as numeric (`#`).
    characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
    // Mark reference as numeric (`x` or `X`).
    characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
    // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).
    characterReferenceValue: "characterReferenceValue",
    // Whole fenced code:
    //
    // ````markdown
    // ```js
    // alert(1)
    // ```
    // ````
    codeFenced: "codeFenced",
    // A fenced code fence, including whitespace, sequence, info, and meta
    // (` ```js `).
    codeFencedFence: "codeFencedFence",
    // Sequence of grave accent or tilde characters (` ``` `) in a fence.
    codeFencedFenceSequence: "codeFencedFenceSequence",
    // Info word (`js`) in a fence.
    // Includes string.
    codeFencedFenceInfo: "codeFencedFenceInfo",
    // Meta words (`highlight="1"`) in a fence.
    // Includes string.
    codeFencedFenceMeta: "codeFencedFenceMeta",
    // A line of code.
    codeFlowValue: "codeFlowValue",
    // Whole indented code:
    //
    // ```markdown
    //     alert(1)
    // ```
    //
    // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.
    codeIndented: "codeIndented",
    // A text code (``` `alpha` ```).
    // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include
    // `codeTextPadding`.
    codeText: "codeText",
    codeTextData: "codeTextData",
    // A space or line ending right after or before a tick.
    codeTextPadding: "codeTextPadding",
    // A text code fence (` `` `).
    codeTextSequence: "codeTextSequence",
    // Whole content:
    //
    // ```markdown
    // [a]: b
    // c
    // =
    // d
    // ```
    //
    // Includes `paragraph` and `definition`.
    content: "content",
    // Whole definition:
    //
    // ```markdown
    // [micromark]: https://github.com/micromark/micromark
    // ```
    //
    // Includes `definitionLabel`, `definitionMarker`, `whitespace`,
    // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.
    definition: "definition",
    // Destination of a definition (`https://github.com/micromark/micromark` or
    // `<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.
    definitionDestination: "definitionDestination",
    // Enclosed destination of a definition
    // (`<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteralMarker` and optionally
    // `definitionDestinationString`.
    definitionDestinationLiteral: "definitionDestinationLiteral",
    // Markers of an enclosed definition destination (`<` or `>`).
    definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
    // Unenclosed destination of a definition
    // (`https://github.com/micromark/micromark`).
    // Includes `definitionDestinationString`.
    definitionDestinationRaw: "definitionDestinationRaw",
    // Text in an destination (`https://github.com/micromark/micromark`).
    // Includes string.
    definitionDestinationString: "definitionDestinationString",
    // Label of a definition (`[micromark]`).
    // Includes `definitionLabelMarker` and `definitionLabelString`.
    definitionLabel: "definitionLabel",
    // Markers of a definition label (`[` or `]`).
    definitionLabelMarker: "definitionLabelMarker",
    // Value of a definition label (`micromark`).
    // Includes string.
    definitionLabelString: "definitionLabelString",
    // Marker between a label and a destination (`:`).
    definitionMarker: "definitionMarker",
    // Title of a definition (`"x"`, `'y'`, or `(z)`).
    // Includes `definitionTitleMarker` and optionally `definitionTitleString`.
    definitionTitle: "definitionTitle",
    // Marker around a title of a definition (`"`, `'`, `(`, or `)`).
    definitionTitleMarker: "definitionTitleMarker",
    // Data without markers in a title (`z`).
    // Includes string.
    definitionTitleString: "definitionTitleString",
    // Emphasis (`*alpha*`).
    // Includes `emphasisSequence` and `emphasisText`.
    emphasis: "emphasis",
    // Sequence of emphasis markers (`*` or `_`).
    emphasisSequence: "emphasisSequence",
    // Emphasis text (`alpha`).
    // Includes text.
    emphasisText: "emphasisText",
    // The character escape marker (`\`).
    escapeMarker: "escapeMarker",
    // A hard break created with a backslash (`\\n`).
    // Note: does not include the line ending.
    hardBreakEscape: "hardBreakEscape",
    // A hard break created with trailing spaces (`  \n`).
    // Does not include the line ending.
    hardBreakTrailing: "hardBreakTrailing",
    // Flow HTML:
    //
    // ```markdown
    // <div
    // ```
    //
    // Inlcudes `lineEnding`, `htmlFlowData`.
    htmlFlow: "htmlFlow",
    htmlFlowData: "htmlFlowData",
    // HTML in text (the tag in `a <i> b`).
    // Includes `lineEnding`, `htmlTextData`.
    htmlText: "htmlText",
    htmlTextData: "htmlTextData",
    // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or
    // `![alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    image: "image",
    // Whole link label (`[*alpha*]`).
    // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.
    label: "label",
    // Text in an label (`*alpha*`).
    // Includes text.
    labelText: "labelText",
    // Start a link label (`[`).
    // Includes a `labelMarker`.
    labelLink: "labelLink",
    // Start an image label (`![`).
    // Includes `labelImageMarker` and `labelMarker`.
    labelImage: "labelImage",
    // Marker of a label (`[` or `]`).
    labelMarker: "labelMarker",
    // Marker to start an image (`!`).
    labelImageMarker: "labelImageMarker",
    // End a label (`]`).
    // Includes `labelMarker`.
    labelEnd: "labelEnd",
    // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    link: "link",
    // Whole paragraph:
    //
    // ```markdown
    // alpha
    // bravo.
    // ```
    //
    // Includes text.
    paragraph: "paragraph",
    // A reference (`[alpha]` or `[]`).
    // Includes `referenceMarker` and an optional `referenceString`.
    reference: "reference",
    // A reference marker (`[` or `]`).
    referenceMarker: "referenceMarker",
    // Reference text (`alpha`).
    // Includes string.
    referenceString: "referenceString",
    // A resource (`(https://example.com "alpha")`).
    // Includes `resourceMarker`, an optional `resourceDestination` with an optional
    // `whitespace` and `resourceTitle`.
    resource: "resource",
    // A resource destination (`https://example.com`).
    // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.
    resourceDestination: "resourceDestination",
    // A literal resource destination (`<https://example.com>`).
    // Includes `resourceDestinationLiteralMarker` and optionally
    // `resourceDestinationString`.
    resourceDestinationLiteral: "resourceDestinationLiteral",
    // A resource destination marker (`<` or `>`).
    resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
    // A raw resource destination (`https://example.com`).
    // Includes `resourceDestinationString`.
    resourceDestinationRaw: "resourceDestinationRaw",
    // Resource destination text (`https://example.com`).
    // Includes string.
    resourceDestinationString: "resourceDestinationString",
    // A resource marker (`(` or `)`).
    resourceMarker: "resourceMarker",
    // A resource title (`"alpha"`, `'alpha'`, or `(alpha)`).
    // Includes `resourceTitleMarker` and optionally `resourceTitleString`.
    resourceTitle: "resourceTitle",
    // A resource title marker (`"`, `'`, `(`, or `)`).
    resourceTitleMarker: "resourceTitleMarker",
    // Resource destination title (`alpha`).
    // Includes string.
    resourceTitleString: "resourceTitleString",
    // Whole setext heading:
    //
    // ```markdown
    // alpha
    // bravo
    // =====
    // ```
    //
    // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and
    // `setextHeadingLine`.
    setextHeading: "setextHeading",
    // Content in a setext heading (`alpha\nbravo`).
    // Includes text.
    setextHeadingText: "setextHeadingText",
    // Underline in a setext heading, including whitespace suffix (`==`).
    // Includes `setextHeadingLineSequence`.
    setextHeadingLine: "setextHeadingLine",
    // Sequence of equals or dash characters in underline in a setext heading (`-`).
    setextHeadingLineSequence: "setextHeadingLineSequence",
    // Strong (`**alpha**`).
    // Includes `strongSequence` and `strongText`.
    strong: "strong",
    // Sequence of strong markers (`**` or `__`).
    strongSequence: "strongSequence",
    // Strong text (`alpha`).
    // Includes text.
    strongText: "strongText",
    // Whole thematic break:
    //
    // ```markdown
    // * * *
    // ```
    //
    // Includes `thematicBreakSequence` and `whitespace`.
    thematicBreak: "thematicBreak",
    // A sequence of one or more thematic break markers (`***`).
    thematicBreakSequence: "thematicBreakSequence",
    // Whole block quote:
    //
    // ```markdown
    // > a
    // >
    // > b
    // ```
    //
    // Includes `blockQuotePrefix` and flow.
    blockQuote: "blockQuote",
    // The `>` or `> ` of a block quote.
    blockQuotePrefix: "blockQuotePrefix",
    // The `>` of a block quote prefix.
    blockQuoteMarker: "blockQuoteMarker",
    // The optional ` ` of a block quote prefix.
    blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
    // Whole ordered list:
    //
    // ```markdown
    // 1. a
    //    b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listOrdered: "listOrdered",
    // Whole unordered list:
    //
    // ```markdown
    // - a
    //   b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listUnordered: "listUnordered",
    // The indent of further list item lines.
    listItemIndent: "listItemIndent",
    // A marker, as in, `*`, `+`, `-`, `.`, or `)`.
    listItemMarker: "listItemMarker",
    // The thing that starts a list item, such as `1. `.
    // Includes `listItemValue` if ordered, `listItemMarker`, and
    // `listItemPrefixWhitespace` (unless followed by a line ending).
    listItemPrefix: "listItemPrefix",
    // The whitespace after a marker.
    listItemPrefixWhitespace: "listItemPrefixWhitespace",
    // The numerical value of an ordered item.
    listItemValue: "listItemValue",
    chunkContent: "chunkContent",
    chunkFlow: "chunkFlow",
    chunkText: "chunkText",
    chunkString: "chunkString"
  }
);
const values = (
  /** @type {const} */
  {
    ht: "	",
    lf: "\n",
    cr: "\r",
    space: " ",
    replacementCharacter: "ï¿½"
  }
);
function splice$1(list2, start, remove, items) {
  const end = list2.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < constants.v8MaxSafeChunkSize) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    list2.splice(...parameters);
  } else {
    if (remove) list2.splice(start, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(
        chunkStart,
        chunkStart + constants.v8MaxSafeChunkSize
      );
      parameters.unshift(start, 0);
      list2.splice(...parameters);
      chunkStart += constants.v8MaxSafeChunkSize;
      start += constants.v8MaxSafeChunkSize;
    }
  }
}
function push(list2, items) {
  if (list2.length > 0) {
    splice$1(list2, list2.length, 0, items);
    return list2;
  }
  return items;
}
const hasOwnProperty$1 = {}.hasOwnProperty;
function combineExtensions$1(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension$1(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension$1(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty$1.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code2;
    if (right) {
      for (code2 in right) {
        if (!hasOwnProperty$1.call(left, code2)) left[code2] = [];
        const value = right[code2];
        constructs$1(
          // @ts-expect-error Looks like a list.
          left[code2],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs$1(existing, list2) {
  let index2 = -1;
  const before = [];
  while (++index2 < list2.length) {
    (list2[index2].add === "after" ? existing : before).push(list2[index2]);
  }
  splice$1(existing, 0, 0, before);
}
function decodeNumericCharacterReference(value, base) {
  const code2 = Number.parseInt(value, base);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code2 < codes.ht || code2 === codes.vt || code2 > codes.cr && code2 < codes.space || // Control character (DEL) of C0, and C1 controls.
    code2 > codes.tilde && code2 < 160 || // Lone high surrogates and low surrogates.
    code2 > 55295 && code2 < 57344 || // Noncharacters.
    code2 > 64975 && code2 < 65008 || /* eslint-disable no-bitwise */
    (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    code2 > 1114111
  ) {
    return values.replacementCharacter;
  }
  return String.fromCodePoint(code2);
}
function normalizeIdentifier$1(value) {
  return value.replace(/[\t\n\r ]+/g, values.space).replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const asciiAlpha$1 = regexCheck$1(/[A-Za-z]/);
const asciiAlphanumeric$1 = regexCheck$1(/[\dA-Za-z]/);
const asciiAtext = regexCheck$1(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl$1(code2) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code2 !== null && (code2 < codes.space || code2 === codes.del)
  );
}
const asciiDigit = regexCheck$1(/\d/);
const asciiHexDigit = regexCheck$1(/[\dA-Fa-f]/);
const asciiPunctuation = regexCheck$1(/[!-/:-@[-`{-~]/);
function markdownLineEnding$1(code2) {
  return code2 !== null && code2 < codes.horizontalTab;
}
function markdownLineEndingOrSpace$1(code2) {
  return code2 !== null && (code2 < codes.nul || code2 === codes.space);
}
function markdownSpace$1(code2) {
  return code2 === codes.horizontalTab || code2 === codes.virtualSpace || code2 === codes.space;
}
const unicodePunctuation$1 = regexCheck$1(new RegExp("\\p{P}|\\p{S}", "u"));
const unicodeWhitespace$1 = regexCheck$1(/\s/);
function regexCheck$1(regex) {
  return check;
  function check(code2) {
    return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
  }
}
function normalizeUri(value) {
  const result = [];
  let index2 = -1;
  let start = 0;
  let skip = 0;
  while (++index2 < value.length) {
    const code2 = value.charCodeAt(index2);
    let replace2 = "";
    if (code2 === codes.percentSign && asciiAlphanumeric$1(value.charCodeAt(index2 + 1)) && asciiAlphanumeric$1(value.charCodeAt(index2 + 2))) {
      skip = 2;
    } else if (code2 < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
        replace2 = String.fromCharCode(code2);
      }
    } else if (code2 > 55295 && code2 < 57344) {
      const next = value.charCodeAt(index2 + 1);
      if (code2 < 56320 && next > 56319 && next < 57344) {
        replace2 = String.fromCharCode(code2, next);
        skip = 1;
      } else {
        replace2 = values.replacementCharacter;
      }
    } else {
      replace2 = String.fromCharCode(code2);
    }
    if (replace2) {
      result.push(value.slice(start, index2), encodeURIComponent(replace2));
      start = index2 + skip + 1;
      replace2 = "";
    }
    if (skip) {
      index2 += skip;
      skip = 0;
    }
  }
  return result.join("") + value.slice(start);
}
function factorySpace$1(effects, ok2, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code2) {
    if (markdownSpace$1(code2)) {
      effects.enter(type);
      return prefix(code2);
    }
    return ok2(code2);
  }
  function prefix(code2) {
    if (markdownSpace$1(code2) && size++ < limit) {
      effects.consume(code2);
      return prefix;
    }
    effects.exit(type);
    return ok2(code2);
  }
}
const content$1 = { tokenize: initializeContent };
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous2;
  return contentStart;
  function afterContentStartConstruct(code2) {
    ok$2(
      code2 === codes.eof || markdownLineEnding$1(code2),
      "expected eol or eof"
    );
    if (code2 === codes.eof) {
      effects.consume(code2);
      return;
    }
    effects.enter(types$1.lineEnding);
    effects.consume(code2);
    effects.exit(types$1.lineEnding);
    return factorySpace$1(effects, contentStart, types$1.linePrefix);
  }
  function paragraphInitial(code2) {
    ok$2(
      code2 !== codes.eof && !markdownLineEnding$1(code2),
      "expected anything other than a line ending or EOF"
    );
    effects.enter(types$1.paragraph);
    return lineStart(code2);
  }
  function lineStart(code2) {
    const token = effects.enter(types$1.chunkText, {
      contentType: constants.contentTypeText,
      previous: previous2
    });
    if (previous2) {
      previous2.next = token;
    }
    previous2 = token;
    return data(code2);
  }
  function data(code2) {
    if (code2 === codes.eof) {
      effects.exit(types$1.chunkText);
      effects.exit(types$1.paragraph);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding$1(code2)) {
      effects.consume(code2);
      effects.exit(types$1.chunkText);
      return lineStart;
    }
    effects.consume(code2);
    return data;
  }
}
const document$2 = { tokenize: initializeDocument };
const containerConstruct = { tokenize: tokenizeContainer };
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      ok$2(
        item[0].continuation,
        "expected `continuation` to be defined on container construct"
      );
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    ok$2(
      self2.containerState,
      "expected `containerState` to be defined after continuation"
    );
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types$1.chunkFlow) {
          point2 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      ok$2(point2, "could not find previous flow chunk");
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = { ...point2 };
        index2++;
      }
      splice$1(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
      return checkNewContainers(code2);
    }
    return start(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code2);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code2);
  }
  function thereIsANewContainer(code2) {
    if (childFlow) closeFlow();
    exitContainers(continued);
    return documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code2);
  }
  function documentContinued(code2) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code2);
  }
  function containerContinue(code2) {
    ok$2(
      self2.currentConstruct,
      "expected `currentConstruct` to be defined on tokenizer"
    );
    ok$2(
      self2.containerState,
      "expected `containerState` to be defined on tokenizer"
    );
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === codes.eof) {
      if (childFlow) closeFlow();
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter(types$1.chunkFlow, {
      _tokenizer: childFlow,
      contentType: constants.contentTypeFlow,
      previous: childToken
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === codes.eof) {
      writeToChild(effects.exit(types$1.chunkFlow), true);
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding$1(code2)) {
      effects.consume(code2);
      writeToChild(effects.exit(types$1.chunkFlow));
      continued = 0;
      self2.interrupt = void 0;
      return start;
    }
    effects.consume(code2);
    return flowContinue;
  }
  function writeToChild(token, endOfFile) {
    ok$2(childFlow, "expected `childFlow` to be defined when continuing");
    const stream = self2.sliceStream(token);
    if (endOfFile) stream.push(null);
    token.previous = childToken;
    if (childToken) childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (
          // The token starts before the line endingâ€¦
          childFlow.events[index2][1].start.offset < lineStartOffset && // â€¦and either is not ended yetâ€¦
          (!childFlow.events[index2][1].end || // â€¦or ends after it.
          childFlow.events[index2][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types$1.chunkFlow) {
          if (seen) {
            point2 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      ok$2(point2, "could not find previous flow chunk");
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = { ...point2 };
        index2++;
      }
      splice$1(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self2.containerState = entry[1];
      ok$2(
        entry[0].exit,
        "expected `exit` to be defined on container construct"
      );
      entry[0].exit.call(self2, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    ok$2(
      self2.containerState,
      "expected `containerState` to be defined when closing flow"
    );
    ok$2(childFlow, "expected `childFlow` to be defined when closing it");
    childFlow.write([codes.eof]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok2, nok) {
  ok$2(
    this.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace$1(
    effects,
    effects.attempt(this.parser.constructs.document, ok2, nok),
    types$1.linePrefix,
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
  );
}
function classifyCharacter$1(code2) {
  if (code2 === codes.eof || markdownLineEndingOrSpace$1(code2) || unicodeWhitespace$1(code2)) {
    return constants.characterGroupWhitespace;
  }
  if (unicodePunctuation$1(code2)) {
    return constants.characterGroupPunctuation;
  }
}
function resolveAll$1(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}
const attention = {
  name: "attention",
  resolveAll: resolveAllAttention,
  tokenize: tokenizeAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text2;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = { ...events[open][1].end };
          const end = { ...events[index2][1].start };
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? types$1.strongSequence : types$1.emphasisSequence,
            start,
            end: { ...events[open][1].end }
          };
          closingSequence = {
            type: use > 1 ? types$1.strongSequence : types$1.emphasisSequence,
            start: { ...events[index2][1].start },
            end
          };
          text2 = {
            type: use > 1 ? types$1.strongText : types$1.emphasisText,
            start: { ...events[open][1].end },
            end: { ...events[index2][1].start }
          };
          group = {
            type: use > 1 ? types$1.strong : types$1.emphasis,
            start: { ...openingSequence.start },
            end: { ...closingSequence.end }
          };
          events[open][1].end = { ...openingSequence.start };
          events[index2][1].start = { ...closingSequence.end };
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text2, context]
          ]);
          ok$2(
            context.parser.constructs.insideSpan.null,
            "expected `insideSpan` to be populated"
          );
          nextEvents = push(
            nextEvents,
            resolveAll$1(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index2),
              context
            )
          );
          nextEvents = push(nextEvents, [
            ["exit", text2, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice$1(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok2) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous2 = this.previous;
  const before = classifyCharacter$1(previous2);
  let marker;
  return start;
  function start(code2) {
    ok$2(
      code2 === codes.asterisk || code2 === codes.underscore,
      "expected asterisk or underscore"
    );
    marker = code2;
    effects.enter("attentionSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter$1(code2);
    ok$2(attentionMarkers2, "expected `attentionMarkers` to be populated");
    const open = !after || after === constants.characterGroupPunctuation && before || attentionMarkers2.includes(code2);
    const close = !before || before === constants.characterGroupPunctuation && after || attentionMarkers2.includes(previous2);
    token._open = Boolean(
      marker === codes.asterisk ? open : open && (before || !close)
    );
    token._close = Boolean(
      marker === codes.asterisk ? close : close && (after || !open)
    );
    return ok2(code2);
  }
}
function movePoint(point2, offset) {
  point2.column += offset;
  point2.offset += offset;
  point2._bufferIndex += offset;
}
const autolink = { name: "autolink", tokenize: tokenizeAutolink };
function tokenizeAutolink(effects, ok2, nok) {
  let size = 0;
  return start;
  function start(code2) {
    ok$2(code2 === codes.lessThan, "expected `<`");
    effects.enter(types$1.autolink);
    effects.enter(types$1.autolinkMarker);
    effects.consume(code2);
    effects.exit(types$1.autolinkMarker);
    effects.enter(types$1.autolinkProtocol);
    return open;
  }
  function open(code2) {
    if (asciiAlpha$1(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    if (code2 === codes.atSign) {
      return nok(code2);
    }
    return emailAtext(code2);
  }
  function schemeOrEmailAtext(code2) {
    if (code2 === codes.plusSign || code2 === codes.dash || code2 === codes.dot || asciiAlphanumeric$1(code2)) {
      size = 1;
      return schemeInsideOrEmailAtext(code2);
    }
    return emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === codes.colon) {
      effects.consume(code2);
      size = 0;
      return urlInside;
    }
    if ((code2 === codes.plusSign || code2 === codes.dash || code2 === codes.dot || asciiAlphanumeric$1(code2)) && size++ < constants.autolinkSchemeSizeMax) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    size = 0;
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === codes.greaterThan) {
      effects.exit(types$1.autolinkProtocol);
      effects.enter(types$1.autolinkMarker);
      effects.consume(code2);
      effects.exit(types$1.autolinkMarker);
      effects.exit(types$1.autolink);
      return ok2;
    }
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.lessThan || asciiControl$1(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === codes.atSign) {
      effects.consume(code2);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric$1(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === codes.dot) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code2 === codes.greaterThan) {
      effects.exit(types$1.autolinkProtocol).type = types$1.autolinkEmail;
      effects.enter(types$1.autolinkMarker);
      effects.consume(code2);
      effects.exit(types$1.autolinkMarker);
      effects.exit(types$1.autolink);
      return ok2;
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === codes.dash || asciiAlphanumeric$1(code2)) && size++ < constants.autolinkDomainSizeMax) {
      const next = code2 === codes.dash ? emailValue : emailLabel;
      effects.consume(code2);
      return next;
    }
    return nok(code2);
  }
}
const blankLine$1 = { partial: true, tokenize: tokenizeBlankLine$1 };
function tokenizeBlankLine$1(effects, ok2, nok) {
  return start;
  function start(code2) {
    return markdownSpace$1(code2) ? factorySpace$1(effects, after, types$1.linePrefix)(code2) : after(code2);
  }
  function after(code2) {
    return code2 === codes.eof || markdownLineEnding$1(code2) ? ok2(code2) : nok(code2);
  }
}
const blockQuote = {
  continuation: { tokenize: tokenizeBlockQuoteContinuation },
  exit: exit$1,
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart
};
function tokenizeBlockQuoteStart(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (code2 === codes.greaterThan) {
      const state = self2.containerState;
      ok$2(state, "expected `containerState` to be defined in container");
      if (!state.open) {
        effects.enter(types$1.blockQuote, { _container: true });
        state.open = true;
      }
      effects.enter(types$1.blockQuotePrefix);
      effects.enter(types$1.blockQuoteMarker);
      effects.consume(code2);
      effects.exit(types$1.blockQuoteMarker);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownSpace$1(code2)) {
      effects.enter(types$1.blockQuotePrefixWhitespace);
      effects.consume(code2);
      effects.exit(types$1.blockQuotePrefixWhitespace);
      effects.exit(types$1.blockQuotePrefix);
      return ok2;
    }
    effects.exit(types$1.blockQuotePrefix);
    return ok2(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
  const self2 = this;
  return contStart;
  function contStart(code2) {
    if (markdownSpace$1(code2)) {
      ok$2(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      return factorySpace$1(
        effects,
        contBefore,
        types$1.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code2);
    }
    return contBefore(code2);
  }
  function contBefore(code2) {
    return effects.attempt(blockQuote, ok2, nok)(code2);
  }
}
function exit$1(effects) {
  effects.exit(types$1.blockQuote);
}
const characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    ok$2(code2 === codes.backslash, "expected `\\`");
    effects.enter(types$1.characterEscape);
    effects.enter(types$1.escapeMarker);
    effects.consume(code2);
    effects.exit(types$1.escapeMarker);
    return inside;
  }
  function inside(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter(types$1.characterEscapeValue);
      effects.consume(code2);
      effects.exit(types$1.characterEscapeValue);
      effects.exit(types$1.characterEscape);
      return ok2;
    }
    return nok(code2);
  }
}
const characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok2, nok) {
  const self2 = this;
  let size = 0;
  let max;
  let test;
  return start;
  function start(code2) {
    ok$2(code2 === codes.ampersand, "expected `&`");
    effects.enter(types$1.characterReference);
    effects.enter(types$1.characterReferenceMarker);
    effects.consume(code2);
    effects.exit(types$1.characterReferenceMarker);
    return open;
  }
  function open(code2) {
    if (code2 === codes.numberSign) {
      effects.enter(types$1.characterReferenceMarkerNumeric);
      effects.consume(code2);
      effects.exit(types$1.characterReferenceMarkerNumeric);
      return numeric;
    }
    effects.enter(types$1.characterReferenceValue);
    max = constants.characterReferenceNamedSizeMax;
    test = asciiAlphanumeric$1;
    return value(code2);
  }
  function numeric(code2) {
    if (code2 === codes.uppercaseX || code2 === codes.lowercaseX) {
      effects.enter(types$1.characterReferenceMarkerHexadecimal);
      effects.consume(code2);
      effects.exit(types$1.characterReferenceMarkerHexadecimal);
      effects.enter(types$1.characterReferenceValue);
      max = constants.characterReferenceHexadecimalSizeMax;
      test = asciiHexDigit;
      return value;
    }
    effects.enter(types$1.characterReferenceValue);
    max = constants.characterReferenceDecimalSizeMax;
    test = asciiDigit;
    return value(code2);
  }
  function value(code2) {
    if (code2 === codes.semicolon && size) {
      const token = effects.exit(types$1.characterReferenceValue);
      if (test === asciiAlphanumeric$1 && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
        return nok(code2);
      }
      effects.enter(types$1.characterReferenceMarker);
      effects.consume(code2);
      effects.exit(types$1.characterReferenceMarker);
      effects.exit(types$1.characterReference);
      return ok2;
    }
    if (test(code2) && size++ < max) {
      effects.consume(code2);
      return value;
    }
    return nok(code2);
  }
}
const nonLazyContinuation = {
  partial: true,
  tokenize: tokenizeNonLazyContinuation
};
const codeFenced = {
  concrete: true,
  name: "codeFenced",
  tokenize: tokenizeCodeFenced
};
function tokenizeCodeFenced(effects, ok2, nok) {
  const self2 = this;
  const closeStart = { partial: true, tokenize: tokenizeCloseStart };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code2) {
    return beforeSequenceOpen(code2);
  }
  function beforeSequenceOpen(code2) {
    ok$2(
      code2 === codes.graveAccent || code2 === codes.tilde,
      "expected `` ` `` or `~`"
    );
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === types$1.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code2;
    effects.enter(types$1.codeFenced);
    effects.enter(types$1.codeFencedFence);
    effects.enter(types$1.codeFencedFenceSequence);
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      sizeOpen++;
      effects.consume(code2);
      return sequenceOpen;
    }
    if (sizeOpen < constants.codeFencedSequenceSizeMin) {
      return nok(code2);
    }
    effects.exit(types$1.codeFencedFenceSequence);
    return markdownSpace$1(code2) ? factorySpace$1(effects, infoBefore, types$1.whitespace)(code2) : infoBefore(code2);
  }
  function infoBefore(code2) {
    if (code2 === codes.eof || markdownLineEnding$1(code2)) {
      effects.exit(types$1.codeFencedFence);
      return self2.interrupt ? ok2(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter(types$1.codeFencedFenceInfo);
    effects.enter(types$1.chunkString, { contentType: constants.contentTypeString });
    return info(code2);
  }
  function info(code2) {
    if (code2 === codes.eof || markdownLineEnding$1(code2)) {
      effects.exit(types$1.chunkString);
      effects.exit(types$1.codeFencedFenceInfo);
      return infoBefore(code2);
    }
    if (markdownSpace$1(code2)) {
      effects.exit(types$1.chunkString);
      effects.exit(types$1.codeFencedFenceInfo);
      return factorySpace$1(effects, metaBefore, types$1.whitespace)(code2);
    }
    if (code2 === codes.graveAccent && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return info;
  }
  function metaBefore(code2) {
    if (code2 === codes.eof || markdownLineEnding$1(code2)) {
      return infoBefore(code2);
    }
    effects.enter(types$1.codeFencedFenceMeta);
    effects.enter(types$1.chunkString, { contentType: constants.contentTypeString });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === codes.eof || markdownLineEnding$1(code2)) {
      effects.exit(types$1.chunkString);
      effects.exit(types$1.codeFencedFenceMeta);
      return infoBefore(code2);
    }
    if (code2 === codes.graveAccent && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return meta;
  }
  function atNonLazyBreak(code2) {
    ok$2(markdownLineEnding$1(code2), "expected eol");
    return effects.attempt(closeStart, after, contentBefore)(code2);
  }
  function contentBefore(code2) {
    ok$2(markdownLineEnding$1(code2), "expected eol");
    effects.enter(types$1.lineEnding);
    effects.consume(code2);
    effects.exit(types$1.lineEnding);
    return contentStart;
  }
  function contentStart(code2) {
    return initialPrefix > 0 && markdownSpace$1(code2) ? factorySpace$1(
      effects,
      beforeContentChunk,
      types$1.linePrefix,
      initialPrefix + 1
    )(code2) : beforeContentChunk(code2);
  }
  function beforeContentChunk(code2) {
    if (code2 === codes.eof || markdownLineEnding$1(code2)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter(types$1.codeFlowValue);
    return contentChunk(code2);
  }
  function contentChunk(code2) {
    if (code2 === codes.eof || markdownLineEnding$1(code2)) {
      effects.exit(types$1.codeFlowValue);
      return beforeContentChunk(code2);
    }
    effects.consume(code2);
    return contentChunk;
  }
  function after(code2) {
    effects.exit(types$1.codeFenced);
    return ok2(code2);
  }
  function tokenizeCloseStart(effects2, ok3, nok2) {
    let size = 0;
    return startBefore;
    function startBefore(code2) {
      ok$2(markdownLineEnding$1(code2), "expected eol");
      effects2.enter(types$1.lineEnding);
      effects2.consume(code2);
      effects2.exit(types$1.lineEnding);
      return start2;
    }
    function start2(code2) {
      ok$2(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      effects2.enter(types$1.codeFencedFence);
      return markdownSpace$1(code2) ? factorySpace$1(
        effects2,
        beforeSequenceClose,
        types$1.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code2) : beforeSequenceClose(code2);
    }
    function beforeSequenceClose(code2) {
      if (code2 === marker) {
        effects2.enter(types$1.codeFencedFenceSequence);
        return sequenceClose(code2);
      }
      return nok2(code2);
    }
    function sequenceClose(code2) {
      if (code2 === marker) {
        size++;
        effects2.consume(code2);
        return sequenceClose;
      }
      if (size >= sizeOpen) {
        effects2.exit(types$1.codeFencedFenceSequence);
        return markdownSpace$1(code2) ? factorySpace$1(effects2, sequenceCloseAfter, types$1.whitespace)(code2) : sequenceCloseAfter(code2);
      }
      return nok2(code2);
    }
    function sequenceCloseAfter(code2) {
      if (code2 === codes.eof || markdownLineEnding$1(code2)) {
        effects2.exit(types$1.codeFencedFence);
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    ok$2(markdownLineEnding$1(code2), "expected eol");
    effects.enter(types$1.lineEnding);
    effects.consume(code2);
    effects.exit(types$1.lineEnding);
    return lineStart;
  }
  function lineStart(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
  }
}
const codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
const furtherStart = { partial: true, tokenize: tokenizeFurtherStart };
function tokenizeCodeIndented(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    ok$2(markdownSpace$1(code2));
    effects.enter(types$1.codeIndented);
    return factorySpace$1(
      effects,
      afterPrefix,
      types$1.linePrefix,
      constants.tabSize + 1
    )(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types$1.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? atBreak(code2) : nok(code2);
  }
  function atBreak(code2) {
    if (code2 === codes.eof) {
      return after(code2);
    }
    if (markdownLineEnding$1(code2)) {
      return effects.attempt(furtherStart, atBreak, after)(code2);
    }
    effects.enter(types$1.codeFlowValue);
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === codes.eof || markdownLineEnding$1(code2)) {
      effects.exit(types$1.codeFlowValue);
      return atBreak(code2);
    }
    effects.consume(code2);
    return inside;
  }
  function after(code2) {
    effects.exit(types$1.codeIndented);
    return ok2(code2);
  }
}
function tokenizeFurtherStart(effects, ok2, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code2) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    if (markdownLineEnding$1(code2)) {
      effects.enter(types$1.lineEnding);
      effects.consume(code2);
      effects.exit(types$1.lineEnding);
      return furtherStart2;
    }
    return factorySpace$1(
      effects,
      afterPrefix,
      types$1.linePrefix,
      constants.tabSize + 1
    )(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types$1.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? ok2(code2) : markdownLineEnding$1(code2) ? furtherStart2(code2) : nok(code2);
  }
}
const codeText = {
  name: "codeText",
  previous: previous$1,
  resolve: resolveCodeText,
  tokenize: tokenizeCodeText
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === types$1.lineEnding || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === types$1.lineEnding || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === types$1.codeTextData) {
        events[headEnterIndex][1].type = types$1.codeTextPadding;
        events[tailExitIndex][1].type = types$1.codeTextPadding;
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== types$1.lineEnding) {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === types$1.lineEnding) {
      events[enter][1].type = types$1.codeTextData;
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous$1(code2) {
  return code2 !== codes.graveAccent || this.events[this.events.length - 1][1].type === types$1.characterEscape;
}
function tokenizeCodeText(effects, ok2, nok) {
  const self2 = this;
  let sizeOpen = 0;
  let size;
  let token;
  return start;
  function start(code2) {
    ok$2(code2 === codes.graveAccent, "expected `` ` ``");
    ok$2(previous$1.call(self2, self2.previous), "expected correct previous");
    effects.enter(types$1.codeText);
    effects.enter(types$1.codeTextSequence);
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === codes.graveAccent) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit(types$1.codeTextSequence);
    return between(code2);
  }
  function between(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.space) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return between;
    }
    if (code2 === codes.graveAccent) {
      token = effects.enter(types$1.codeTextSequence);
      size = 0;
      return sequenceClose(code2);
    }
    if (markdownLineEnding$1(code2)) {
      effects.enter(types$1.lineEnding);
      effects.consume(code2);
      effects.exit(types$1.lineEnding);
      return between;
    }
    effects.enter(types$1.codeTextData);
    return data(code2);
  }
  function data(code2) {
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.graveAccent || markdownLineEnding$1(code2)) {
      effects.exit(types$1.codeTextData);
      return between(code2);
    }
    effects.consume(code2);
    return data;
  }
  function sequenceClose(code2) {
    if (code2 === codes.graveAccent) {
      effects.consume(code2);
      size++;
      return sequenceClose;
    }
    if (size === sizeOpen) {
      effects.exit(types$1.codeTextSequence);
      effects.exit(types$1.codeText);
      return ok2(code2);
    }
    token.type = types$1.codeTextData;
    return data(code2);
  }
}
class SpliceBuffer {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(initial) {
    this.left = initial ? [...initial] : [];
    this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(index2) {
    if (index2 < 0 || index2 >= this.left.length + this.right.length) {
      throw new RangeError(
        "Cannot access index `" + index2 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`"
      );
    }
    if (index2 < this.left.length) return this.left[index2];
    return this.right[this.right.length - index2 + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    this.setCursor(0);
    return this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(start, end) {
    const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
    if (stop < this.left.length) {
      return this.left.slice(start, stop);
    }
    if (start > this.left.length) {
      return this.right.slice(
        this.right.length - stop + this.left.length,
        this.right.length - start + this.left.length
      ).reverse();
    }
    return this.left.slice(start).concat(
      this.right.slice(this.right.length - stop + this.left.length).reverse()
    );
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(start, deleteCount, items) {
    const count = deleteCount || 0;
    this.setCursor(Math.trunc(start));
    const removed = this.right.splice(
      this.right.length - count,
      Number.POSITIVE_INFINITY
    );
    if (items) chunkedPush(this.left, items);
    return removed.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    this.setCursor(Number.POSITIVE_INFINITY);
    return this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(item) {
    this.setCursor(Number.POSITIVE_INFINITY);
    this.left.push(item);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(items) {
    this.setCursor(Number.POSITIVE_INFINITY);
    chunkedPush(this.left, items);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(item) {
    this.setCursor(0);
    this.right.push(item);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(items) {
    this.setCursor(0);
    chunkedPush(this.right, items.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(n) {
    if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0)
      return;
    if (n < this.left.length) {
      const removed = this.left.splice(n, Number.POSITIVE_INFINITY);
      chunkedPush(this.right, removed.reverse());
    } else {
      const removed = this.right.splice(
        this.left.length + this.right.length - n,
        Number.POSITIVE_INFINITY
      );
      chunkedPush(this.left, removed.reverse());
    }
  }
}
function chunkedPush(list2, right) {
  let chunkStart = 0;
  if (right.length < constants.v8MaxSafeChunkSize) {
    list2.push(...right);
  } else {
    while (chunkStart < right.length) {
      list2.push(
        ...right.slice(chunkStart, chunkStart + constants.v8MaxSafeChunkSize)
      );
      chunkStart += constants.v8MaxSafeChunkSize;
    }
  }
}
function subtokenize(eventsArray) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  const events = new SpliceBuffer(eventsArray);
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events.get(index2);
    if (index2 && event[1].type === types$1.chunkFlow && events.get(index2 - 1)[1].type === types$1.listItemPrefix) {
      ok$2(event[1]._tokenizer, "expected `_tokenizer` on subtokens");
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types$1.lineEndingBlank) {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types$1.content) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === types$1.content) {
            break;
          }
          if (subevents[otherIndex][1].type === types$1.chunkText) {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events.get(otherIndex);
        if (otherEvent[1].type === types$1.lineEnding || otherEvent[1].type === types$1.lineEndingBlank) {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events.get(lineIndex)[1].type = types$1.lineEndingBlank;
            }
            otherEvent[1].type = types$1.lineEnding;
            lineIndex = otherIndex;
          }
        } else if (otherEvent[1].type === types$1.linePrefix || otherEvent[1].type === types$1.listItemIndent) ;
        else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = { ...events.get(lineIndex)[1].start };
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        events.splice(lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  splice$1(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events.get(eventIndex)[1];
  const context = events.get(eventIndex)[2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  ok$2(token.contentType, "expected `contentType` on subtokens");
  let tokenizer = token._tokenizer;
  if (!tokenizer) {
    tokenizer = context.parser[token.contentType](token.start);
    if (token._contentTypeTextTrailing) {
      tokenizer._contentTypeTextTrailing = true;
    }
  }
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous2;
  let index2 = -1;
  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events.get(++startPosition)[1] !== current) {
    }
    ok$2(
      !previous2 || current.previous === previous2,
      "expected previous to match"
    );
    ok$2(!previous2 || previous2.next === current, "expected next to match");
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(codes.eof);
      }
      if (previous2) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = current;
    current = current.next;
  }
  current = token;
  while (++index2 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
    ) {
      ok$2(current, "expected a current token");
      start = index2 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
    ok$2(!current.next, "expected no next token");
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start2 = startPositions.pop();
    ok$2(start2 !== void 0, "expected a start position when splicing");
    jumps.push([start2, start2 + slice.length - 1]);
    events.splice(start2, 2, slice);
  }
  jumps.reverse();
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}
const content = { resolve: resolveContent, tokenize: tokenizeContent };
const continuationConstruct = { partial: true, tokenize: tokenizeContinuation };
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok2) {
  let previous2;
  return chunkStart;
  function chunkStart(code2) {
    ok$2(
      code2 !== codes.eof && !markdownLineEnding$1(code2),
      "expected no eof or eol"
    );
    effects.enter(types$1.content);
    previous2 = effects.enter(types$1.chunkContent, {
      contentType: constants.contentTypeContent
    });
    return chunkInside(code2);
  }
  function chunkInside(code2) {
    if (code2 === codes.eof) {
      return contentEnd(code2);
    }
    if (markdownLineEnding$1(code2)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code2);
    }
    effects.consume(code2);
    return chunkInside;
  }
  function contentEnd(code2) {
    effects.exit(types$1.chunkContent);
    effects.exit(types$1.content);
    return ok2(code2);
  }
  function contentContinue(code2) {
    ok$2(markdownLineEnding$1(code2), "expected eol");
    effects.consume(code2);
    effects.exit(types$1.chunkContent);
    ok$2(previous2, "expected previous token");
    previous2.next = effects.enter(types$1.chunkContent, {
      contentType: constants.contentTypeContent,
      previous: previous2
    });
    previous2 = previous2.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok2, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code2) {
    ok$2(markdownLineEnding$1(code2), "expected a line ending");
    effects.exit(types$1.chunkContent);
    effects.enter(types$1.lineEnding);
    effects.consume(code2);
    effects.exit(types$1.lineEnding);
    return factorySpace$1(effects, prefixed, types$1.linePrefix);
  }
  function prefixed(code2) {
    if (code2 === codes.eof || markdownLineEnding$1(code2)) {
      return nok(code2);
    }
    ok$2(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === types$1.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize) {
      return ok2(code2);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code2);
  }
}
function factoryDestination(effects, ok2, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code2) {
    if (code2 === codes.lessThan) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.rightParenthesis || asciiControl$1(code2)) {
      return nok(code2);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter(types$1.chunkString, { contentType: constants.contentTypeString });
    return raw(code2);
  }
  function enclosedBefore(code2) {
    if (code2 === codes.greaterThan) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    effects.enter(types$1.chunkString, { contentType: constants.contentTypeString });
    return enclosed(code2);
  }
  function enclosed(code2) {
    if (code2 === codes.greaterThan) {
      effects.exit(types$1.chunkString);
      effects.exit(stringType);
      return enclosedBefore(code2);
    }
    if (code2 === codes.eof || code2 === codes.lessThan || markdownLineEnding$1(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === codes.backslash ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code2) {
    if (code2 === codes.lessThan || code2 === codes.greaterThan || code2 === codes.backslash) {
      effects.consume(code2);
      return enclosed;
    }
    return enclosed(code2);
  }
  function raw(code2) {
    if (!balance && (code2 === codes.eof || code2 === codes.rightParenthesis || markdownLineEndingOrSpace$1(code2))) {
      effects.exit(types$1.chunkString);
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok2(code2);
    }
    if (balance < limit && code2 === codes.leftParenthesis) {
      effects.consume(code2);
      balance++;
      return raw;
    }
    if (code2 === codes.rightParenthesis) {
      effects.consume(code2);
      balance--;
      return raw;
    }
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.leftParenthesis || asciiControl$1(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === codes.backslash ? rawEscape : raw;
  }
  function rawEscape(code2) {
    if (code2 === codes.leftParenthesis || code2 === codes.rightParenthesis || code2 === codes.backslash) {
      effects.consume(code2);
      return raw;
    }
    return raw(code2);
  }
}
function factoryLabel(effects, ok2, nok, type, markerType, stringType) {
  const self2 = this;
  let size = 0;
  let seen;
  return start;
  function start(code2) {
    ok$2(code2 === codes.leftSquareBracket, "expected `[`");
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (size > constants.linkReferenceSizeMax || code2 === codes.eof || code2 === codes.leftSquareBracket || code2 === codes.rightSquareBracket && !seen || // To do: remove in the future once weâ€™ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnâ€™t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code2 === codes.caret && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code2);
    }
    if (code2 === codes.rightSquareBracket) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    if (markdownLineEnding$1(code2)) {
      effects.enter(types$1.lineEnding);
      effects.consume(code2);
      effects.exit(types$1.lineEnding);
      return atBreak;
    }
    effects.enter(types$1.chunkString, { contentType: constants.contentTypeString });
    return labelInside(code2);
  }
  function labelInside(code2) {
    if (code2 === codes.eof || code2 === codes.leftSquareBracket || code2 === codes.rightSquareBracket || markdownLineEnding$1(code2) || size++ > constants.linkReferenceSizeMax) {
      effects.exit(types$1.chunkString);
      return atBreak(code2);
    }
    effects.consume(code2);
    if (!seen) seen = !markdownSpace$1(code2);
    return code2 === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code2) {
    if (code2 === codes.leftSquareBracket || code2 === codes.backslash || code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      size++;
      return labelInside;
    }
    return labelInside(code2);
  }
}
function factoryTitle(effects, ok2, nok, type, markerType, stringType) {
  let marker;
  return start;
  function start(code2) {
    if (code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.leftParenthesis) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      marker = code2 === codes.leftParenthesis ? codes.rightParenthesis : code2;
      return begin;
    }
    return nok(code2);
  }
  function begin(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (markdownLineEnding$1(code2)) {
      effects.enter(types$1.lineEnding);
      effects.consume(code2);
      effects.exit(types$1.lineEnding);
      return factorySpace$1(effects, atBreak, types$1.linePrefix);
    }
    effects.enter(types$1.chunkString, { contentType: constants.contentTypeString });
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker || code2 === codes.eof || markdownLineEnding$1(code2)) {
      effects.exit(types$1.chunkString);
      return atBreak(code2);
    }
    effects.consume(code2);
    return code2 === codes.backslash ? escape : inside;
  }
  function escape(code2) {
    if (code2 === marker || code2 === codes.backslash) {
      effects.consume(code2);
      return inside;
    }
    return inside(code2);
  }
}
function factoryWhitespace(effects, ok2) {
  let seen;
  return start;
  function start(code2) {
    if (markdownLineEnding$1(code2)) {
      effects.enter(types$1.lineEnding);
      effects.consume(code2);
      effects.exit(types$1.lineEnding);
      seen = true;
      return start;
    }
    if (markdownSpace$1(code2)) {
      return factorySpace$1(
        effects,
        start,
        seen ? types$1.linePrefix : types$1.lineSuffix
      )(code2);
    }
    return ok2(code2);
  }
}
const definition$1 = { name: "definition", tokenize: tokenizeDefinition };
const titleBefore = { partial: true, tokenize: tokenizeTitleBefore };
function tokenizeDefinition(effects, ok2, nok) {
  const self2 = this;
  let identifier;
  return start;
  function start(code2) {
    effects.enter(types$1.definition);
    return before(code2);
  }
  function before(code2) {
    ok$2(code2 === codes.leftSquareBracket, "expected `[`");
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we donâ€™t need to reset the way `markdown-rs` does.
      nok,
      types$1.definitionLabel,
      types$1.definitionLabelMarker,
      types$1.definitionLabelString
    )(code2);
  }
  function labelAfter(code2) {
    identifier = normalizeIdentifier$1(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code2 === codes.colon) {
      effects.enter(types$1.definitionMarker);
      effects.consume(code2);
      effects.exit(types$1.definitionMarker);
      return markerAfter;
    }
    return nok(code2);
  }
  function markerAfter(code2) {
    return markdownLineEndingOrSpace$1(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
  }
  function destinationBefore(code2) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we donâ€™t need to reset the way `markdown-rs` does.
      nok,
      types$1.definitionDestination,
      types$1.definitionDestinationLiteral,
      types$1.definitionDestinationLiteralMarker,
      types$1.definitionDestinationRaw,
      types$1.definitionDestinationString
    )(code2);
  }
  function destinationAfter(code2) {
    return effects.attempt(titleBefore, after, after)(code2);
  }
  function after(code2) {
    return markdownSpace$1(code2) ? factorySpace$1(effects, afterWhitespace, types$1.whitespace)(code2) : afterWhitespace(code2);
  }
  function afterWhitespace(code2) {
    if (code2 === codes.eof || markdownLineEnding$1(code2)) {
      effects.exit(types$1.definition);
      self2.parser.defined.push(identifier);
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitleBefore(effects, ok2, nok) {
  return titleBefore2;
  function titleBefore2(code2) {
    return markdownLineEndingOrSpace$1(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
  }
  function beforeMarker(code2) {
    return factoryTitle(
      effects,
      titleAfter,
      nok,
      types$1.definitionTitle,
      types$1.definitionTitleMarker,
      types$1.definitionTitleString
    )(code2);
  }
  function titleAfter(code2) {
    return markdownSpace$1(code2) ? factorySpace$1(
      effects,
      titleAfterOptionalWhitespace,
      types$1.whitespace
    )(code2) : titleAfterOptionalWhitespace(code2);
  }
  function titleAfterOptionalWhitespace(code2) {
    return code2 === codes.eof || markdownLineEnding$1(code2) ? ok2(code2) : nok(code2);
  }
}
const hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    ok$2(code2 === codes.backslash, "expected `\\`");
    effects.enter(types$1.hardBreakEscape);
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    if (markdownLineEnding$1(code2)) {
      effects.exit(types$1.hardBreakEscape);
      return ok2(code2);
    }
    return nok(code2);
  }
}
const headingAtx = {
  name: "headingAtx",
  resolve: resolveHeadingAtx,
  tokenize: tokenizeHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content2;
  let text2;
  if (events[contentStart][1].type === types$1.whitespace) {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === types$1.whitespace) {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === types$1.atxHeadingSequence && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === types$1.whitespace)) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content2 = {
      type: types$1.atxHeadingText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text2 = {
      type: types$1.chunkText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: constants.contentTypeText
    };
    splice$1(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content2, context],
      ["enter", text2, context],
      ["exit", text2, context],
      ["exit", content2, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
  let size = 0;
  return start;
  function start(code2) {
    effects.enter(types$1.atxHeading);
    return before(code2);
  }
  function before(code2) {
    ok$2(code2 === codes.numberSign, "expected `#`");
    effects.enter(types$1.atxHeadingSequence);
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === codes.numberSign && size++ < constants.atxHeadingOpeningFenceSizeMax) {
      effects.consume(code2);
      return sequenceOpen;
    }
    if (code2 === codes.eof || markdownLineEndingOrSpace$1(code2)) {
      effects.exit(types$1.atxHeadingSequence);
      return atBreak(code2);
    }
    return nok(code2);
  }
  function atBreak(code2) {
    if (code2 === codes.numberSign) {
      effects.enter(types$1.atxHeadingSequence);
      return sequenceFurther(code2);
    }
    if (code2 === codes.eof || markdownLineEnding$1(code2)) {
      effects.exit(types$1.atxHeading);
      return ok2(code2);
    }
    if (markdownSpace$1(code2)) {
      return factorySpace$1(effects, atBreak, types$1.whitespace)(code2);
    }
    effects.enter(types$1.atxHeadingText);
    return data(code2);
  }
  function sequenceFurther(code2) {
    if (code2 === codes.numberSign) {
      effects.consume(code2);
      return sequenceFurther;
    }
    effects.exit(types$1.atxHeadingSequence);
    return atBreak(code2);
  }
  function data(code2) {
    if (code2 === codes.eof || code2 === codes.numberSign || markdownLineEndingOrSpace$1(code2)) {
      effects.exit(types$1.atxHeadingText);
      return atBreak(code2);
    }
    effects.consume(code2);
    return data;
  }
}
const htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
const htmlRawNames = ["pre", "script", "style", "textarea"];
const htmlFlow = {
  concrete: true,
  name: "htmlFlow",
  resolveTo: resolveToHtmlFlow,
  tokenize: tokenizeHtmlFlow
};
const blankLineBefore = { partial: true, tokenize: tokenizeBlankLineBefore };
const nonLazyContinuationStart = {
  partial: true,
  tokenize: tokenizeNonLazyContinuationStart
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === types$1.htmlFlow) {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === types$1.linePrefix) {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer;
  let index2;
  let markerB;
  return start;
  function start(code2) {
    return before(code2);
  }
  function before(code2) {
    ok$2(code2 === codes.lessThan, "expected `<`");
    effects.enter(types$1.htmlFlow);
    effects.enter(types$1.htmlFlowData);
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === codes.exclamationMark) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === codes.slash) {
      effects.consume(code2);
      closingTag = true;
      return tagCloseStart;
    }
    if (code2 === codes.questionMark) {
      effects.consume(code2);
      marker = constants.htmlInstruction;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    if (asciiAlpha$1(code2)) {
      ok$2(code2 !== null);
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      marker = constants.htmlComment;
      return commentOpenInside;
    }
    if (code2 === codes.leftSquareBracket) {
      effects.consume(code2);
      marker = constants.htmlCdata;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha$1(code2)) {
      effects.consume(code2);
      marker = constants.htmlDeclaration;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    const value = constants.cdataOpeningString;
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      if (index2 === value.length) {
        return self2.interrupt ? ok2 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha$1(code2)) {
      ok$2(code2 !== null);
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === codes.eof || code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace$1(code2)) {
      const slash = code2 === codes.slash;
      const name2 = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name2)) {
        marker = constants.htmlRaw;
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = constants.htmlBasic;
        if (slash) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      marker = constants.htmlComplete;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
    }
    if (code2 === codes.dash || asciiAlphanumeric$1(code2)) {
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace$1(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === codes.slash) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === codes.colon || code2 === codes.underscore || asciiAlpha$1(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace$1(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === codes.dash || code2 === codes.dot || code2 === codes.colon || code2 === codes.underscore || asciiAlphanumeric$1(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === codes.equalsTo) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace$1(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === codes.eof || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.greaterThan || code2 === codes.graveAccent) {
      return nok(code2);
    }
    if (code2 === codes.quotationMark || code2 === codes.apostrophe) {
      effects.consume(code2);
      markerB = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace$1(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === markerB) {
      effects.consume(code2);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code2 === codes.eof || markdownLineEnding$1(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === codes.eof || code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.slash || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.greaterThan || code2 === codes.graveAccent || markdownLineEndingOrSpace$1(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownSpace$1(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (code2 === codes.eof || markdownLineEnding$1(code2)) {
      return continuation(code2);
    }
    if (markdownSpace$1(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function continuation(code2) {
    if (code2 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === codes.lessThan && marker === constants.htmlRaw) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === codes.greaterThan && marker === constants.htmlDeclaration) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === codes.questionMark && marker === constants.htmlInstruction) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === codes.rightSquareBracket && marker === constants.htmlCdata) {
      effects.consume(code2);
      return continuationCdataInside;
    }
    if (markdownLineEnding$1(code2) && (marker === constants.htmlBasic || marker === constants.htmlComplete)) {
      effects.exit(types$1.htmlFlowData);
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code2);
    }
    if (code2 === codes.eof || markdownLineEnding$1(code2)) {
      effects.exit(types$1.htmlFlowData);
      return continuationStart(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationStart(code2) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code2);
  }
  function continuationStartNonLazy(code2) {
    ok$2(markdownLineEnding$1(code2));
    effects.enter(types$1.lineEnding);
    effects.consume(code2);
    effects.exit(types$1.lineEnding);
    return continuationBefore;
  }
  function continuationBefore(code2) {
    if (code2 === codes.eof || markdownLineEnding$1(code2)) {
      return continuationStart(code2);
    }
    effects.enter(types$1.htmlFlowData);
    return continuation(code2);
  }
  function continuationCommentInside(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === codes.slash) {
      effects.consume(code2);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === codes.greaterThan) {
      const name2 = buffer.toLowerCase();
      if (htmlRawNames.includes(name2)) {
        effects.consume(code2);
        return continuationClose;
      }
      return continuation(code2);
    }
    if (asciiAlpha$1(code2) && buffer.length < constants.htmlRawSizeMax) {
      ok$2(code2 !== null);
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCdataInside(code2) {
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === codes.eof || markdownLineEnding$1(code2)) {
      effects.exit(types$1.htmlFlowData);
      return continuationAfter(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function continuationAfter(code2) {
    effects.exit(types$1.htmlFlow);
    return ok2(code2);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (markdownLineEnding$1(code2)) {
      effects.enter(types$1.lineEnding);
      effects.consume(code2);
      effects.exit(types$1.lineEnding);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
  }
}
function tokenizeBlankLineBefore(effects, ok2, nok) {
  return start;
  function start(code2) {
    ok$2(markdownLineEnding$1(code2), "expected a line ending");
    effects.enter(types$1.lineEnding);
    effects.consume(code2);
    effects.exit(types$1.lineEnding);
    return effects.attempt(blankLine$1, ok2, nok);
  }
}
const htmlText = { name: "htmlText", tokenize: tokenizeHtmlText };
function tokenizeHtmlText(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let index2;
  let returnState;
  return start;
  function start(code2) {
    ok$2(code2 === codes.lessThan, "expected `<`");
    effects.enter(types$1.htmlText);
    effects.enter(types$1.htmlTextData);
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === codes.exclamationMark) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === codes.slash) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === codes.questionMark) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha$1(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentOpenInside;
    }
    if (code2 === codes.leftSquareBracket) {
      effects.consume(code2);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha$1(code2)) {
      effects.consume(code2);
      return declaration;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentEnd;
    }
    return nok(code2);
  }
  function comment(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding$1(code2)) {
      returnState = comment;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return comment;
  }
  function commentClose(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentEnd;
    }
    return comment(code2);
  }
  function commentEnd(code2) {
    return code2 === codes.greaterThan ? end(code2) : code2 === codes.dash ? commentClose(code2) : comment(code2);
  }
  function cdataOpenInside(code2) {
    const value = constants.cdataOpeningString;
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding$1(code2)) {
      returnState = cdata;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === codes.greaterThan) {
      return end(code2);
    }
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration(code2) {
    if (code2 === codes.eof || code2 === codes.greaterThan) {
      return end(code2);
    }
    if (markdownLineEnding$1(code2)) {
      returnState = declaration;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return declaration;
  }
  function instruction(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.questionMark) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding$1(code2)) {
      returnState = instruction;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === codes.greaterThan ? end(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha$1(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === codes.dash || asciiAlphanumeric$1(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding$1(code2)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace$1(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end(code2);
  }
  function tagOpen(code2) {
    if (code2 === codes.dash || asciiAlphanumeric$1(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace$1(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === codes.slash) {
      effects.consume(code2);
      return end;
    }
    if (code2 === codes.colon || code2 === codes.underscore || asciiAlpha$1(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding$1(code2)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace$1(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === codes.dash || code2 === codes.dot || code2 === codes.colon || code2 === codes.underscore || asciiAlphanumeric$1(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === codes.equalsTo) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding$1(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code2);
    }
    if (markdownSpace$1(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === codes.eof || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.greaterThan || code2 === codes.graveAccent) {
      return nok(code2);
    }
    if (code2 === codes.quotationMark || code2 === codes.apostrophe) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding$1(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code2);
    }
    if (markdownSpace$1(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (markdownLineEnding$1(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === codes.eof || code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.graveAccent) {
      return nok(code2);
    }
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace$1(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace$1(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function end(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      effects.exit(types$1.htmlTextData);
      effects.exit(types$1.htmlText);
      return ok2;
    }
    return nok(code2);
  }
  function lineEndingBefore(code2) {
    ok$2(returnState, "expected return state");
    ok$2(markdownLineEnding$1(code2), "expected eol");
    effects.exit(types$1.htmlTextData);
    effects.enter(types$1.lineEnding);
    effects.consume(code2);
    effects.exit(types$1.lineEnding);
    return lineEndingAfter;
  }
  function lineEndingAfter(code2) {
    ok$2(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return markdownSpace$1(code2) ? factorySpace$1(
      effects,
      lineEndingAfterPrefix,
      types$1.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code2) : lineEndingAfterPrefix(code2);
  }
  function lineEndingAfterPrefix(code2) {
    effects.enter(types$1.htmlTextData);
    return returnState(code2);
  }
}
const labelEnd = {
  name: "labelEnd",
  resolveAll: resolveAllLabelEnd,
  resolveTo: resolveToLabelEnd,
  tokenize: tokenizeLabelEnd
};
const resourceConstruct = { tokenize: tokenizeResource };
const referenceFullConstruct = { tokenize: tokenizeReferenceFull };
const referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed };
function resolveAllLabelEnd(events) {
  let index2 = -1;
  const newEvents = [];
  while (++index2 < events.length) {
    const token = events[index2][1];
    newEvents.push(events[index2]);
    if (token.type === types$1.labelImage || token.type === types$1.labelLink || token.type === types$1.labelEnd) {
      const offset = token.type === types$1.labelImage ? 4 : 2;
      token.type = types$1.data;
      index2 += offset;
    }
  }
  if (events.length !== newEvents.length) {
    splice$1(events, 0, events.length, newEvents);
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token;
  let open;
  let close;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === types$1.link || token.type === types$1.labelLink && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === types$1.labelLink) {
        token._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token.type === types$1.labelImage || token.type === types$1.labelLink) && !token._balanced) {
        open = index2;
        if (token.type !== types$1.labelLink) {
          offset = 2;
          break;
        }
      }
    } else if (token.type === types$1.labelEnd) {
      close = index2;
    }
  }
  ok$2(open !== void 0, "`open` is supposed to be found");
  ok$2(close !== void 0, "`close` is supposed to be found");
  const group = {
    type: events[open][1].type === types$1.labelLink ? types$1.link : types$1.image,
    start: { ...events[open][1].start },
    end: { ...events[events.length - 1][1].end }
  };
  const label = {
    type: types$1.label,
    start: { ...events[open][1].start },
    end: { ...events[close][1].end }
  };
  const text2 = {
    type: types$1.labelText,
    start: { ...events[open + offset + 2][1].end },
    end: { ...events[close - 2][1].start }
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text2, context]]);
  ok$2(
    context.parser.constructs.insideSpan.null,
    "expected `insideSpan.null` to be populated"
  );
  media = push(
    media,
    resolveAll$1(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset + 4, close - 3),
      context
    )
  );
  media = push(media, [
    ["exit", text2, context],
    events[close - 2],
    events[close - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group, context]]);
  splice$1(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === types$1.labelImage || self2.events[index2][1].type === types$1.labelLink) && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start;
  function start(code2) {
    ok$2(code2 === codes.rightSquareBracket, "expected `]`");
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive) {
      return labelEndNok(code2);
    }
    defined = self2.parser.defined.includes(
      normalizeIdentifier$1(
        self2.sliceSerialize({ start: labelStart.end, end: self2.now() })
      )
    );
    effects.enter(types$1.labelEnd);
    effects.enter(types$1.labelMarker);
    effects.consume(code2);
    effects.exit(types$1.labelMarker);
    effects.exit(types$1.labelEnd);
    return after;
  }
  function after(code2) {
    if (code2 === codes.leftParenthesis) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code2);
    }
    if (code2 === codes.leftSquareBracket) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code2);
    }
    return defined ? labelEndOk(code2) : labelEndNok(code2);
  }
  function referenceNotFull(code2) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code2);
  }
  function labelEndOk(code2) {
    return ok2(code2);
  }
  function labelEndNok(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok2, nok) {
  return resourceStart;
  function resourceStart(code2) {
    ok$2(code2 === codes.leftParenthesis, "expected left paren");
    effects.enter(types$1.resource);
    effects.enter(types$1.resourceMarker);
    effects.consume(code2);
    effects.exit(types$1.resourceMarker);
    return resourceBefore;
  }
  function resourceBefore(code2) {
    return markdownLineEndingOrSpace$1(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
  }
  function resourceOpen(code2) {
    if (code2 === codes.rightParenthesis) {
      return resourceEnd(code2);
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      types$1.resourceDestination,
      types$1.resourceDestinationLiteral,
      types$1.resourceDestinationLiteralMarker,
      types$1.resourceDestinationRaw,
      types$1.resourceDestinationString,
      constants.linkResourceDestinationBalanceMax
    )(code2);
  }
  function resourceDestinationAfter(code2) {
    return markdownLineEndingOrSpace$1(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
  }
  function resourceDestinationMissing(code2) {
    return nok(code2);
  }
  function resourceBetween(code2) {
    if (code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.leftParenthesis) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        types$1.resourceTitle,
        types$1.resourceTitleMarker,
        types$1.resourceTitleString
      )(code2);
    }
    return resourceEnd(code2);
  }
  function resourceTitleAfter(code2) {
    return markdownLineEndingOrSpace$1(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
  }
  function resourceEnd(code2) {
    if (code2 === codes.rightParenthesis) {
      effects.enter(types$1.resourceMarker);
      effects.consume(code2);
      effects.exit(types$1.resourceMarker);
      effects.exit(types$1.resource);
      return ok2;
    }
    return nok(code2);
  }
}
function tokenizeReferenceFull(effects, ok2, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code2) {
    ok$2(code2 === codes.leftSquareBracket, "expected left bracket");
    return factoryLabel.call(
      self2,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      types$1.reference,
      types$1.referenceMarker,
      types$1.referenceString
    )(code2);
  }
  function referenceFullAfter(code2) {
    return self2.parser.defined.includes(
      normalizeIdentifier$1(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok2(code2) : nok(code2);
  }
  function referenceFullMissing(code2) {
    return nok(code2);
  }
}
function tokenizeReferenceCollapsed(effects, ok2, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code2) {
    ok$2(code2 === codes.leftSquareBracket, "expected left bracket");
    effects.enter(types$1.reference);
    effects.enter(types$1.referenceMarker);
    effects.consume(code2);
    effects.exit(types$1.referenceMarker);
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code2) {
    if (code2 === codes.rightSquareBracket) {
      effects.enter(types$1.referenceMarker);
      effects.consume(code2);
      effects.exit(types$1.referenceMarker);
      effects.exit(types$1.reference);
      return ok2;
    }
    return nok(code2);
  }
}
const labelStartImage = {
  name: "labelStartImage",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartImage
};
function tokenizeLabelStartImage(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    ok$2(code2 === codes.exclamationMark, "expected `!`");
    effects.enter(types$1.labelImage);
    effects.enter(types$1.labelImageMarker);
    effects.consume(code2);
    effects.exit(types$1.labelImageMarker);
    return open;
  }
  function open(code2) {
    if (code2 === codes.leftSquareBracket) {
      effects.enter(types$1.labelMarker);
      effects.consume(code2);
      effects.exit(types$1.labelMarker);
      effects.exit(types$1.labelImage);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
const labelStartLink = {
  name: "labelStartLink",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartLink
};
function tokenizeLabelStartLink(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    ok$2(code2 === codes.leftSquareBracket, "expected `[`");
    effects.enter(types$1.labelLink);
    effects.enter(types$1.labelMarker);
    effects.consume(code2);
    effects.exit(types$1.labelMarker);
    effects.exit(types$1.labelLink);
    return after;
  }
  function after(code2) {
    return code2 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
const lineEnding = { name: "lineEnding", tokenize: tokenizeLineEnding };
function tokenizeLineEnding(effects, ok2) {
  return start;
  function start(code2) {
    ok$2(markdownLineEnding$1(code2), "expected eol");
    effects.enter(types$1.lineEnding);
    effects.consume(code2);
    effects.exit(types$1.lineEnding);
    return factorySpace$1(effects, ok2, types$1.linePrefix);
  }
}
const thematicBreak$2 = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok2, nok) {
  let size = 0;
  let marker;
  return start;
  function start(code2) {
    effects.enter(types$1.thematicBreak);
    return before(code2);
  }
  function before(code2) {
    ok$2(
      code2 === codes.asterisk || code2 === codes.dash || code2 === codes.underscore,
      "expected `*`, `-`, or `_`"
    );
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter(types$1.thematicBreakSequence);
      return sequence(code2);
    }
    if (size >= constants.thematicBreakMarkerCountMin && (code2 === codes.eof || markdownLineEnding$1(code2))) {
      effects.exit(types$1.thematicBreak);
      return ok2(code2);
    }
    return nok(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size++;
      return sequence;
    }
    effects.exit(types$1.thematicBreakSequence);
    return markdownSpace$1(code2) ? factorySpace$1(effects, atBreak, types$1.whitespace)(code2) : atBreak(code2);
  }
}
const list$2 = {
  continuation: { tokenize: tokenizeListContinuation },
  exit: tokenizeListEnd,
  name: "list",
  tokenize: tokenizeListStart
};
const listItemPrefixWhitespaceConstruct = {
  partial: true,
  tokenize: tokenizeListItemPrefixWhitespace
};
const indentConstruct = { partial: true, tokenize: tokenizeIndent$1 };
function tokenizeListStart(effects, ok2, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === types$1.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start;
  function start(code2) {
    ok$2(self2.containerState, "expected state");
    const kind = self2.containerState.type || (code2 === codes.asterisk || code2 === codes.plusSign || code2 === codes.dash ? types$1.listUnordered : types$1.listOrdered);
    if (kind === types$1.listUnordered ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, { _container: true });
      }
      if (kind === types$1.listUnordered) {
        effects.enter(types$1.listItemPrefix);
        return code2 === codes.asterisk || code2 === codes.dash ? effects.check(thematicBreak$2, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self2.interrupt || code2 === codes.digit1) {
        effects.enter(types$1.listItemPrefix);
        effects.enter(types$1.listItemValue);
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    ok$2(self2.containerState, "expected state");
    if (asciiDigit(code2) && ++size < constants.listItemValueSizeMax) {
      effects.consume(code2);
      return inside;
    }
    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === codes.rightParenthesis || code2 === codes.dot)) {
      effects.exit(types$1.listItemValue);
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    ok$2(self2.containerState, "expected state");
    ok$2(code2 !== codes.eof, "eof (`null`) is not a marker");
    effects.enter(types$1.listItemMarker);
    effects.consume(code2);
    effects.exit(types$1.listItemMarker);
    self2.containerState.marker = self2.containerState.marker || code2;
    return effects.check(
      blankLine$1,
      // Canâ€™t be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code2) {
    ok$2(self2.containerState, "expected state");
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace$1(code2)) {
      effects.enter(types$1.listItemPrefixWhitespace);
      effects.consume(code2);
      effects.exit(types$1.listItemPrefixWhitespace);
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    ok$2(self2.containerState, "expected state");
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit(types$1.listItemPrefix), true).length;
    return ok2(code2);
  }
}
function tokenizeListContinuation(effects, ok2, nok) {
  const self2 = this;
  ok$2(self2.containerState, "expected state");
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine$1, onBlank, notBlank);
  function onBlank(code2) {
    ok$2(self2.containerState, "expected state");
    ok$2(typeof self2.containerState.size === "number", "expected size");
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace$1(
      effects,
      ok2,
      types$1.listItemIndent,
      self2.containerState.size + 1
    )(code2);
  }
  function notBlank(code2) {
    ok$2(self2.containerState, "expected state");
    if (self2.containerState.furtherBlankLines || !markdownSpace$1(code2)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    ok$2(self2.containerState, "expected state");
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    ok$2(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return factorySpace$1(
      effects,
      effects.attempt(list$2, ok2, nok),
      types$1.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code2);
  }
}
function tokenizeIndent$1(effects, ok2, nok) {
  const self2 = this;
  ok$2(self2.containerState, "expected state");
  ok$2(typeof self2.containerState.size === "number", "expected size");
  return factorySpace$1(
    effects,
    afterPrefix,
    types$1.listItemIndent,
    self2.containerState.size + 1
  );
  function afterPrefix(code2) {
    ok$2(self2.containerState, "expected state");
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types$1.listItemIndent && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok2(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  ok$2(this.containerState, "expected state");
  ok$2(typeof this.containerState.type === "string", "expected type");
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
  const self2 = this;
  ok$2(
    self2.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace$1(
    effects,
    afterPrefix,
    types$1.listItemPrefixWhitespace,
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize + 1
  );
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace$1(code2) && tail && tail[1].type === types$1.listItemPrefixWhitespace ? ok2(code2) : nok(code2);
  }
}
const setextUnderline = {
  name: "setextUnderline",
  resolveTo: resolveToSetextUnderline,
  tokenize: tokenizeSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content2;
  let text2;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === types$1.content) {
        content2 = index2;
        break;
      }
      if (events[index2][1].type === types$1.paragraph) {
        text2 = index2;
      }
    } else {
      if (events[index2][1].type === types$1.content) {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === types$1.definition) {
        definition2 = index2;
      }
    }
  }
  ok$2(text2 !== void 0, "expected a `text` index to be found");
  ok$2(content2 !== void 0, "expected a `text` index to be found");
  ok$2(events[content2][2] === context, "enter context should be same");
  ok$2(
    events[events.length - 1][2] === context,
    "enter context should be same"
  );
  const heading2 = {
    type: types$1.setextHeading,
    start: { ...events[content2][1].start },
    end: { ...events[events.length - 1][1].end }
  };
  events[text2][1].type = types$1.setextHeadingText;
  if (definition2) {
    events.splice(text2, 0, ["enter", heading2, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content2][1], context]);
    events[content2][1].end = { ...events[definition2][1].end };
  } else {
    events[content2][1] = heading2;
  }
  events.push(["exit", heading2, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
  const self2 = this;
  let marker;
  return start;
  function start(code2) {
    let index2 = self2.events.length;
    let paragraph2;
    ok$2(
      code2 === codes.dash || code2 === codes.equalsTo,
      "expected `=` or `-`"
    );
    while (index2--) {
      if (self2.events[index2][1].type !== types$1.lineEnding && self2.events[index2][1].type !== types$1.linePrefix && self2.events[index2][1].type !== types$1.content) {
        paragraph2 = self2.events[index2][1].type === types$1.paragraph;
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
      effects.enter(types$1.setextHeadingLine);
      marker = code2;
      return before(code2);
    }
    return nok(code2);
  }
  function before(code2) {
    effects.enter(types$1.setextHeadingLineSequence);
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    effects.exit(types$1.setextHeadingLineSequence);
    return markdownSpace$1(code2) ? factorySpace$1(effects, after, types$1.lineSuffix)(code2) : after(code2);
  }
  function after(code2) {
    if (code2 === codes.eof || markdownLineEnding$1(code2)) {
      effects.exit(types$1.setextHeadingLine);
      return ok2(code2);
    }
    return nok(code2);
  }
}
const flow$1 = { tokenize: initializeFlow };
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine$1,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace$1(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content, afterConstruct)
        ),
        types$1.linePrefix
      )
    )
  );
  return initial;
  function atBlankEnding(code2) {
    ok$2(
      code2 === codes.eof || markdownLineEnding$1(code2),
      "expected eol or eof"
    );
    if (code2 === codes.eof) {
      effects.consume(code2);
      return;
    }
    effects.enter(types$1.lineEndingBlank);
    effects.consume(code2);
    effects.exit(types$1.lineEndingBlank);
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code2) {
    ok$2(
      code2 === codes.eof || markdownLineEnding$1(code2),
      "expected eol or eof"
    );
    if (code2 === codes.eof) {
      effects.consume(code2);
      return;
    }
    effects.enter(types$1.lineEnding);
    effects.consume(code2);
    effects.exit(types$1.lineEnding);
    self2.currentConstruct = void 0;
    return initial;
  }
}
const resolver = { resolveAll: createResolver() };
const string$1 = initializeFactory("string");
const text$5 = initializeFactory("text");
function initializeFactory(field) {
  return {
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    ),
    tokenize: initializeText
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text2 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code2) {
      return atBreak(code2) ? text2(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === codes.eof) {
        effects.consume(code2);
        return;
      }
      effects.enter(types$1.data);
      effects.consume(code2);
      return data;
    }
    function data(code2) {
      if (atBreak(code2)) {
        effects.exit(types$1.data);
        return text2(code2);
      }
      effects.consume(code2);
      return data;
    }
    function atBreak(code2) {
      if (code2 === codes.eof) {
        return true;
      }
      const list2 = constructs2[code2];
      let index2 = -1;
      if (list2) {
        ok$2(Array.isArray(list2), "expected `disable.null` to be populated");
        while (++index2 < list2.length) {
          const item = list2[index2];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === types$1.data) {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== types$1.data) {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === types$1.lineEnding) && events[eventIndex - 1][1].type === types$1.data) {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === codes.space) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex) break;
          bufferIndex = -1;
        } else if (chunk === codes.horizontalTab) {
          tabs = true;
          size++;
        } else if (chunk === codes.virtualSpace) ;
        else {
          index2++;
          break;
        }
      }
      if (context._contentTypeTextTrailing && eventIndex === events.length) {
        size = 0;
      }
      if (size) {
        const token = {
          type: eventIndex === events.length || tabs || size < constants.hardBreakPrefixSizeMin ? types$1.lineSuffix : types$1.hardBreakTrailing,
          start: {
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex,
            _index: data.start._index + index2,
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size
          },
          end: { ...data.end }
        };
        data.end = { ...token.start };
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token, context],
            ["exit", token, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}
const document$1 = {
  [codes.asterisk]: list$2,
  [codes.plusSign]: list$2,
  [codes.dash]: list$2,
  [codes.digit0]: list$2,
  [codes.digit1]: list$2,
  [codes.digit2]: list$2,
  [codes.digit3]: list$2,
  [codes.digit4]: list$2,
  [codes.digit5]: list$2,
  [codes.digit6]: list$2,
  [codes.digit7]: list$2,
  [codes.digit8]: list$2,
  [codes.digit9]: list$2,
  [codes.greaterThan]: blockQuote
};
const contentInitial = {
  [codes.leftSquareBracket]: definition$1
};
const flowInitial = {
  [codes.horizontalTab]: codeIndented,
  [codes.virtualSpace]: codeIndented,
  [codes.space]: codeIndented
};
const flow = {
  [codes.numberSign]: headingAtx,
  [codes.asterisk]: thematicBreak$2,
  [codes.dash]: [setextUnderline, thematicBreak$2],
  [codes.lessThan]: htmlFlow,
  [codes.equalsTo]: setextUnderline,
  [codes.underscore]: thematicBreak$2,
  [codes.graveAccent]: codeFenced,
  [codes.tilde]: codeFenced
};
const string = {
  [codes.ampersand]: characterReference,
  [codes.backslash]: characterEscape
};
const text$4 = {
  [codes.carriageReturn]: lineEnding,
  [codes.lineFeed]: lineEnding,
  [codes.carriageReturnLineFeed]: lineEnding,
  [codes.exclamationMark]: labelStartImage,
  [codes.ampersand]: characterReference,
  [codes.asterisk]: attention,
  [codes.lessThan]: [autolink, htmlText],
  [codes.leftSquareBracket]: labelStartLink,
  [codes.backslash]: [hardBreakEscape, characterEscape],
  [codes.rightSquareBracket]: labelEnd,
  [codes.underscore]: attention,
  [codes.graveAccent]: codeText
};
const insideSpan = { null: [attention, resolver] };
const attentionMarkers = { null: [codes.asterisk, codes.underscore] };
const disable = { null: [] };
const defaultConstructs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers,
  contentInitial,
  disable,
  document: document$1,
  flow,
  flowInitial,
  insideSpan,
  string,
  text: text$4
}, Symbol.toStringTag, { value: "Module" }));
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m2 = s * 60;
  var h2 = m2 * 60;
  var d = h2 * 24;
  var w2 = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w2;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h2) {
      return plural(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name2) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
  }
  return ms;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function setup(env2) {
    createDebug2.debug = createDebug2;
    createDebug2.default = createDebug2;
    createDebug2.coerce = coerce;
    createDebug2.disable = disable2;
    createDebug2.enable = enable;
    createDebug2.enabled = enabled;
    createDebug2.humanize = requireMs();
    createDebug2.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug2[key] = env2[key];
    });
    createDebug2.names = [];
    createDebug2.skips = [];
    createDebug2.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug2.colors[Math.abs(hash) % createDebug2.colors.length];
    }
    createDebug2.selectColor = selectColor;
    function createDebug2(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug2.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug2.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug2.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug2.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug2.useColors();
      debug2.color = createDebug2.selectColor(namespace);
      debug2.extend = extend2;
      debug2.destroy = createDebug2.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug2.namespaces) {
            namespacesCache = createDebug2.namespaces;
            enabledCache = createDebug2.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v2) => {
          enableOverride = v2;
        }
      });
      if (typeof createDebug2.init === "function") {
        createDebug2.init(debug2);
      }
      return debug2;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug2.save(namespaces);
      createDebug2.namespaces = namespaces;
      createDebug2.names = [];
      createDebug2.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug2.skips.push(ns.slice(1));
        } else {
          createDebug2.names.push(ns);
        }
      }
    }
    function matchesTemplate(search2, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search2.length) {
        if (templateIndex < template.length && (template[templateIndex] === search2[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable2() {
      const namespaces = [
        ...createDebug2.names,
        ...createDebug2.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug2.enable("");
      return namespaces;
    }
    function enabled(name2) {
      for (const skip of createDebug2.skips) {
        if (matchesTemplate(name2, skip)) {
          return false;
        }
      }
      for (const ns of createDebug2.names) {
        if (matchesTemplate(name2, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug2.enable(createDebug2.load());
    return createDebug2;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports) {
    var define_process_env_default = {};
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process$1 !== "undefined" && "env" in process$1) {
        r = define_process_env_default.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var browserExports = requireBrowser();
const createDebug = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
const debug = createDebug("micromark");
function createTokenizer(parser, initialize, from) {
  let point2 = {
    _bufferIndex: -1,
    _index: 0,
    line: from && from.line || 1,
    column: from && from.column || 1,
    offset: from && from.offset || 0
  };
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    consume,
    enter,
    exit: exit2,
    interrupt: constructFactory(onsuccessfulcheck, { interrupt: true })
  };
  const context = {
    code: codes.eof,
    containerState: {},
    defineSkip,
    events: [],
    now,
    parser,
    previous: codes.eof,
    sliceSerialize,
    sliceStream,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push(chunks, slice);
    main();
    if (chunks[chunks.length - 1] !== codes.eof) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll$1(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const { _bufferIndex, _index, line, column, offset } = point2;
    return { _bufferIndex, _index, line, column, offset };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
    debug("position: define skip: `%j`", point2);
  }
  function main() {
    let chunkIndex;
    while (point2._index < chunks.length) {
      const chunk = chunks[point2._index];
      if (typeof chunk === "string") {
        chunkIndex = point2._index;
        if (point2._bufferIndex < 0) {
          point2._bufferIndex = 0;
        }
        while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point2._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code2) {
    ok$2(consumed === true, "expected character to be consumed");
    consumed = void 0;
    debug("main: passing `%s` to %s", code2, state && state.name);
    expectedCode = code2;
    ok$2(typeof state === "function", "expected state");
    state = state(code2);
  }
  function consume(code2) {
    ok$2(code2 === expectedCode, "expected given code to equal expected code");
    debug("consume: `%s`", code2);
    ok$2(
      consumed === void 0,
      "expected code to not have been consumed: this might be because `return x(code)` instead of `return x` was used"
    );
    ok$2(
      code2 === null ? context.events.length === 0 || context.events[context.events.length - 1][0] === "exit" : context.events[context.events.length - 1][0] === "enter",
      "expected last token to be open"
    );
    if (markdownLineEnding$1(code2)) {
      point2.line++;
      point2.column = 1;
      point2.offset += code2 === codes.carriageReturnLineFeed ? 2 : 1;
      accountForPotentialSkip();
      debug("position: after eol: `%j`", point2);
    } else if (code2 !== codes.virtualSpace) {
      point2.column++;
      point2.offset++;
    }
    if (point2._bufferIndex < 0) {
      point2._index++;
    } else {
      point2._bufferIndex++;
      if (point2._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
      // strings.
      /** @type {string} */
      chunks[point2._index].length) {
        point2._bufferIndex = -1;
        point2._index++;
      }
    }
    context.previous = code2;
    consumed = true;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    ok$2(typeof type === "string", "expected string type");
    ok$2(type.length > 0, "expected non-empty string");
    debug("enter: `%s`", type);
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit2(type) {
    ok$2(typeof type === "string", "expected string type");
    ok$2(type.length > 0, "expected non-empty string");
    const token = stack.pop();
    ok$2(token, "cannot close w/o open tokens");
    token.end = now();
    ok$2(type === token.type, "expected exit token to match current token");
    ok$2(
      !(token.start._index === token.end._index && token.start._bufferIndex === token.end._bufferIndex),
      "expected non-empty token (`" + type + "`)"
    );
    debug("exit: `%s`", token.type);
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_2, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? (
        /* c8 ignore next 1 */
        handleListOfConstructs(constructs2)
      ) : "tokenize" in constructs2 ? (
        // Looks like a construct.
        handleListOfConstructs([
          /** @type {Construct} */
          constructs2
        ])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map2) {
        return start;
        function start(code2) {
          const left = code2 !== null && map2[code2];
          const all2 = code2 !== null && map2.null;
          const list2 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(left) ? left : left ? [left] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list2)(code2);
        }
      }
      function handleListOfConstructs(list2) {
        listOfConstructs = list2;
        constructIndex = 0;
        if (list2.length === 0) {
          ok$2(bogusState, "expected `bogusState` to be given");
          return bogusState;
        }
        return handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code2) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          ok$2(
            context.parser.constructs.disable.null,
            "expected `disable.null` to be populated"
          );
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code2);
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a â€œlive bindingâ€, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok2,
            nok
          )(code2);
        }
      }
      function ok2(code2) {
        ok$2(code2 === expectedCode, "expected code");
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code2) {
        ok$2(code2 === expectedCode, "expected code");
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice$1(
        context.events,
        from2,
        context.events.length - from2,
        construct.resolve(context.events.slice(from2), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
    ok$2(
      construct.partial || context.events.length === 0 || context.events[context.events.length - 1][0] === "exit",
      "expected last token to end"
    );
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return { from: startEventsIndex, restore };
    function restore() {
      point2 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
      debug("position: restore: `%j`", point2);
    }
  }
  function accountForPotentialSkip() {
    if (point2.line in columnStart && point2.column < 2) {
      point2.column = columnStart[point2.line];
      point2.offset += columnStart[point2.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    ok$2(endBufferIndex > -1, "expected non-negative end buffer index");
    ok$2(startBufferIndex > -1, "expected non-negative start buffer index");
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        ok$2(startBufferIndex === 0, "expected `startBufferIndex` to be `0`");
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case codes.carriageReturn: {
          value = values.cr;
          break;
        }
        case codes.lineFeed: {
          value = values.lf;
          break;
        }
        case codes.carriageReturnLineFeed: {
          value = values.cr + values.lf;
          break;
        }
        case codes.horizontalTab: {
          value = expandTabs ? values.space : values.ht;
          break;
        }
        case codes.virtualSpace: {
          if (!expandTabs && atTab) continue;
          value = values.space;
          break;
        }
        default: {
          ok$2(typeof chunk === "number", "expected number");
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === codes.horizontalTab;
    result.push(value);
  }
  return result.join("");
}
function parse$1(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions$1([defaultConstructs, ...settings.extensions || []])
  );
  const parser = {
    constructs: constructs2,
    content: create2(content$1),
    defined: [],
    document: create2(document$2),
    flow: create2(flow$1),
    lazy: {},
    string: create2(string$1),
    text: create2(text$5)
  };
  return parser;
  function create2(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}
const search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code2;
    value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
    startPosition = 0;
    buffer = "";
    if (start) {
      if (value.charCodeAt(0) === codes.byteOrderMarker) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition = match && match.index !== void 0 ? match.index : value.length;
      code2 = value.charCodeAt(endPosition);
      if (!match) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code2 === codes.lf && startPosition === endPosition && atCarriageReturn) {
        chunks.push(codes.carriageReturnLineFeed);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(codes.carriageReturn);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code2) {
          case codes.nul: {
            chunks.push(codes.replacementCharacter);
            column++;
            break;
          }
          case codes.ht: {
            next = Math.ceil(column / constants.tabSize) * constants.tabSize;
            chunks.push(codes.horizontalTab);
            while (column++ < next) chunks.push(codes.virtualSpace);
            break;
          }
          case codes.lf: {
            chunks.push(codes.lineFeed);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn) chunks.push(codes.carriageReturn);
      if (buffer) chunks.push(buffer);
      chunks.push(codes.eof);
    }
    return chunks;
  }
}
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === codes.numberSign) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === codes.lowercaseX || head2 === codes.uppercaseX;
    return decodeNumericCharacterReference(
      $2.slice(hex ? 2 : 1),
      hex ? constants.numericBaseHexadecimal : constants.numericBaseDecimal
    );
  }
  return decodeNamedCharacterReference($2) || $0;
}
const own$2 = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(
    postprocess(
      parse$1(options).document().write(preprocess()(value, encoding, true))
    )
  );
}
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html2, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html2, buffer),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer,
      link: opener(link2),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list2, onenterlistordered),
      listUnordered: opener(list2),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      characterReference: onexitcharacterreference,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);
  const data = {};
  return compile;
  function compile(events) {
    let tree = { type: "root", children: [] };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit: exit2,
      buffer,
      resume,
      data
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === types$1.listOrdered || events[index2][1].type === types$1.listUnordered) {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          ok$2(typeof tail === "number", "expected list ot be open");
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own$2.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(
          Object.assign(
            { sliceSerialize: events[index2][2].sliceSerialize },
            context
          ),
          events[index2][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point$1(
        events.length > 0 ? events[0][1].start : { line: 1, column: 1, offset: 0 }
      ),
      end: point$1(
        events.length > 0 ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 }
      )
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length) {
    let index2 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      switch (event[1].type) {
        case types$1.listUnordered:
        case types$1.listOrdered:
        case types$1.blockQuote: {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
          break;
        }
        case types$1.lineEndingBlank: {
          if (event[0] === "enter") {
            if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index2;
            }
            atMarker = void 0;
          }
          break;
        }
        case types$1.linePrefix:
        case types$1.listItemValue:
        case types$1.listItemMarker:
        case types$1.listItemPrefix:
        case types$1.listItemPrefixWhitespace: {
          break;
        }
        default: {
          atMarker = void 0;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === types$1.listItemPrefix || containerBalance === -1 && event[0] === "exit" && (event[1].type === types$1.listUnordered || event[1].type === types$1.listOrdered)) {
        if (listItem3) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === types$1.lineEnding || tailEvent[1].type === types$1.lineEndingBlank) {
              if (tailEvent[0] === "exit") continue;
              if (lineIndex) {
                events[lineIndex][1].type = types$1.lineEndingBlank;
                listSpread = true;
              }
              tailEvent[1].type = types$1.lineEnding;
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === types$1.linePrefix || tailEvent[1].type === types$1.blockQuotePrefix || tailEvent[1].type === types$1.blockQuotePrefixWhitespace || tailEvent[1].type === types$1.blockQuoteMarker || tailEvent[1].type === types$1.listItemIndent) ;
            else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === types$1.listItemPrefix) {
          const item = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: weâ€™ll add `end` in a second.
            end: void 0
          };
          listItem3 = item;
          events.splice(index2, 0, ["enter", item, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length;
  }
  function opener(create2, and) {
    return open;
    function open(token) {
      enter.call(this, create2(token), token);
      if (and) and.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function enter(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    ok$2(parent, "expected `parent`");
    ok$2("children" in parent, "expected `parent`");
    const siblings = parent.children;
    siblings.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler || void 0]);
    node2.position = {
      start: point$1(token.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function closer(and) {
    return close;
    function close(token) {
      if (and) and.call(this, token);
      exit2.call(this, token);
    }
  }
  function exit2(token, onExitError) {
    const node2 = this.stack.pop();
    ok$2(node2, "expected `node`");
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        "Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): itâ€™s not open"
      );
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    ok$2(node2.type !== "fragment", "unexpected fragment `exit`ed");
    ok$2(node2.position, "expected `position` to be defined");
    node2.position.end = point$1(token.end);
  }
  function resume() {
    return toString$2(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ok$2(ancestor, "expected nodes on stack");
      ok$2(ancestor.type === "list", "expected list on stack");
      ancestor.start = Number.parseInt(
        this.sliceSerialize(token),
        constants.numericBaseDecimal
      );
      this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(node2.type === "code", "expected code on stack");
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(node2.type === "code", "expected code on stack");
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside) return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(node2.type === "definition", "expected definition on stack");
    node2.label = label;
    node2.identifier = normalizeIdentifier$1(
      this.sliceSerialize(token)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(node2.type === "definition", "expected definition on stack");
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(node2.type === "definition", "expected definition on stack");
    node2.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(node2.type === "heading", "expected heading on stack");
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      ok$2(
        depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6,
        "expected `depth` between `1` and `6`"
      );
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(node2.type === "heading", "expected heading on stack");
    node2.depth = this.sliceSerialize(token).codePointAt(0) === codes.equalsTo ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2("children" in node2, "expected parent on stack");
    const siblings = node2.children;
    let tail = siblings[siblings.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text2();
      tail.position = {
        start: point$1(token.start),
        // @ts-expect-error: weâ€™ll add `end` later.
        end: void 0
      };
      siblings.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    ok$2(tail, "expected a `node` to be on the stack");
    ok$2("value" in tail, "expected a `literal` to be on the stack");
    ok$2(tail.position, "expected `node` to have an open position");
    tail.value += this.sliceSerialize(token);
    tail.position.end = point$1(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    ok$2(context, "expected `node`");
    if (this.data.atHardBreak) {
      ok$2("children" in context, "expected `parent`");
      const tail = context.children[context.children.length - 1];
      ok$2(tail.position, "expected tail to have a starting position");
      tail.position.end = point$1(token.end);
      this.data.atHardBreak = void 0;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(node2.type === "inlineCode", "expected inline code on stack");
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(node2.type === "link", "expected link on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(node2.type === "image", "expected image on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token) {
    const string2 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ok$2(ancestor, "expected ancestor on stack");
    ok$2(
      ancestor.type === "image" || ancestor.type === "link",
      "expected image or link on stack"
    );
    ancestor.label = decodeString(string2);
    ancestor.identifier = normalizeIdentifier$1(string2).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    ok$2(fragment, "expected node on stack");
    ok$2(fragment.type === "fragment", "expected fragment on stack");
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    this.data.inReference = true;
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.title = data2;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(
      node2.type === "image" || node2.type === "link",
      "expected image reference or link reference on stack"
    );
    node2.label = label;
    node2.identifier = normalizeIdentifier$1(
      this.sliceSerialize(token)
    ).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token) {
    ok$2(
      token.type === "characterReferenceMarkerNumeric" || token.type === "characterReferenceMarkerHexadecimal"
    );
    this.data.characterReferenceType = token.type;
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = this.data.characterReferenceType;
    let value;
    if (type) {
      value = decodeNumericCharacterReference(
        data2,
        type === types$1.characterReferenceMarkerNumeric ? constants.numericBaseDecimal : constants.numericBaseHexadecimal
      );
      this.data.characterReferenceType = void 0;
    } else {
      const result = decodeNamedCharacterReference(data2);
      ok$2(result !== false, "expected reference to decode");
      value = result;
    }
    const tail = this.stack[this.stack.length - 1];
    ok$2(tail, "expected `node`");
    ok$2("value" in tail, "expected `node.value`");
    tail.value += value;
  }
  function onexitcharacterreference(token) {
    const tail = this.stack.pop();
    ok$2(tail, "expected `node`");
    ok$2(tail.position, "expected `node.position`");
    tail.position.end = point$1(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(node2.type === "link", "expected link on stack");
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok$2(node2, "expected node on stack");
    ok$2(node2.type === "link", "expected link on stack");
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return { type: "blockquote", children: [] };
  }
  function codeFlow() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function codeText2() {
    return { type: "inlineCode", value: "" };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return { type: "emphasis", children: [] };
  }
  function heading2() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function hardBreak2() {
    return { type: "break" };
  }
  function html2() {
    return { type: "html", value: "" };
  }
  function image2() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function link2() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function list2(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem2(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return { type: "paragraph", children: [] };
  }
  function strong2() {
    return { type: "strong", children: [] };
  }
  function text2() {
    return { type: "text", value: "" };
  }
  function thematicBreak2() {
    return { type: "thematicBreak" };
  }
}
function point$1(d) {
  return { line: d.line, column: d.column, offset: d.offset };
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own$2.call(extension2, key)) {
      switch (key) {
        case "canContainEols": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "transforms": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key];
          if (right) {
            Object.assign(combined[key], right);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition({ start: left.start, end: left.end }) + "): a different token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is still open"
    );
  }
}
function remarkParse(options) {
  const self2 = this;
  self2.parser = parser;
  function parser(doc) {
    return fromMarkdown(doc, {
      ...self2.data("settings"),
      ...options,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: self2.data("micromarkExtensions") || [],
      mdastExtensions: self2.data("fromMarkdownExtensions") || []
    });
  }
}
function escapeStringRegexp$1(string2) {
  if (typeof string2 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function findAndReplace$1(tree, list2, options) {
  const settings = {};
  const ignored = convert$1(settings.ignore || []);
  const pairs = toPairs$1(list2);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents$1(tree, "text", visitor);
  }
  function visitor(node2, parents) {
    let index2 = -1;
    let grandparent;
    while (++index2 < parents.length) {
      const parent = parents[index2];
      const siblings = grandparent ? grandparent.children : void 0;
      if (ignored(
        parent,
        siblings ? siblings.indexOf(parent) : void 0,
        grandparent
      )) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node2, parents);
    }
  }
  function handler(node2, parents) {
    const parent = parents[parents.length - 1];
    const find2 = pairs[pairIndex][0];
    const replace2 = pairs[pairIndex][1];
    let start = 0;
    const siblings = parent.children;
    const index2 = siblings.indexOf(node2);
    let change = false;
    let nodes = [];
    find2.lastIndex = 0;
    let match = find2.exec(node2.value);
    while (match) {
      const position2 = match.index;
      const matchObject = {
        index: match.index,
        input: match.input,
        stack: [...parents, node2]
      };
      let value = replace2(...match, matchObject);
      if (typeof value === "string") {
        value = value.length > 0 ? { type: "text", value } : void 0;
      }
      if (value === false) {
        find2.lastIndex = position2 + 1;
      } else {
        if (start !== position2) {
          nodes.push({
            type: "text",
            value: node2.value.slice(start, position2)
          });
        }
        if (Array.isArray(value)) {
          nodes.push(...value);
        } else if (value) {
          nodes.push(value);
        }
        start = position2 + match[0].length;
        change = true;
      }
      if (!find2.global) {
        break;
      }
      match = find2.exec(node2.value);
    }
    if (change) {
      if (start < node2.value.length) {
        nodes.push({ type: "text", value: node2.value.slice(start) });
      }
      parent.children.splice(index2, 1, ...nodes);
    } else {
      nodes = [node2];
    }
    return index2 + nodes.length;
  }
}
function toPairs$1(tupleOrList) {
  const result = [];
  if (!Array.isArray(tupleOrList)) {
    throw new TypeError("Expected find and replace tuple or list of tuples");
  }
  const list2 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
  let index2 = -1;
  while (++index2 < list2.length) {
    const tuple = list2[index2];
    result.push([toExpression$1(tuple[0]), toFunction$1(tuple[1])]);
  }
  return result;
}
function toExpression$1(find2) {
  return typeof find2 === "string" ? new RegExp(escapeStringRegexp$1(find2), "g") : find2;
}
function toFunction$1(replace2) {
  return typeof replace2 === "function" ? replace2 : function() {
    return replace2;
  };
}
function newlineToBreak(tree) {
  findAndReplace$1(tree, [/\r?\n|\r/g, replace$1]);
}
function replace$1() {
  return { type: "break" };
}
function remarkBreaks() {
  return function(tree) {
    newlineToBreak(tree);
  };
}
function squeezeParagraphs(tree) {
  visit(tree, function(node2, index2, parent) {
    if (index2 !== void 0 && parent && node2.type === "paragraph" && node2.children.every(function(child) {
      return child.type === "text" && /^\s*$/.test(child.value);
    })) {
      parent.children.splice(index2, 1);
      return index2;
    }
  });
}
function remarkUnlinkProtocols(options = { except: ["http", "https"] }) {
  return function(tree) {
    const definitions = /* @__PURE__ */ new Map();
    visit(tree, "definition", function(node2, index2, parent) {
      definitions.set(node2.identifier, node2.url);
      if (parent && typeof index2 === "number") {
        const url = node2.url;
        if (url && url.includes(":") && !options.except.some((proto) => url.startsWith(`${proto}:`))) {
          parent.children.splice(index2, 1);
          return index2;
        }
      }
    });
    visit(tree, function(node2, index2, parent) {
      if (parent && typeof index2 === "number" && (node2.type === "link" || node2.type === "linkReference")) {
        const url = node2.type === "link" ? node2.url : definitions.get(node2.identifier);
        if (url && url.includes(":") && !options.except.some((proto) => url.startsWith(`${proto}:`))) {
          parent.children.splice(index2, 1, ...node2.children);
          return index2;
        }
      }
    });
    squeezeParagraphs(tree);
  };
}
function blockquote$1(state, node2) {
  const result = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: state.wrap(state.all(node2), true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function hardBreak$1(state, node2) {
  const result = { type: "element", tagName: "br", properties: {}, children: [] };
  state.patch(node2, result);
  return [state.applyData(node2, result), { type: "text", value: "\n" }];
}
function code$2(state, node2) {
  const value = node2.value ? node2.value + "\n" : "";
  const properties = {};
  if (node2.lang) {
    properties.className = ["language-" + node2.lang];
  }
  let result = {
    type: "element",
    tagName: "code",
    properties,
    children: [{ type: "text", value }]
  };
  if (node2.meta) {
    result.data = { meta: node2.meta };
  }
  state.patch(node2, result);
  result = state.applyData(node2, result);
  result = { type: "element", tagName: "pre", properties: {}, children: [result] };
  state.patch(node2, result);
  return result;
}
function strikethrough(state, node2) {
  const result = {
    type: "element",
    tagName: "del",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function emphasis$1(state, node2) {
  const result = {
    type: "element",
    tagName: "em",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function footnoteReference$1(state, node2) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const id = String(node2.identifier).toUpperCase();
  const safeId = normalizeUri(id.toLowerCase());
  const index2 = state.footnoteOrder.indexOf(id);
  let counter;
  let reuseCounter = state.footnoteCounts.get(id);
  if (reuseCounter === void 0) {
    reuseCounter = 0;
    state.footnoteOrder.push(id);
    counter = state.footnoteOrder.length;
  } else {
    counter = index2 + 1;
  }
  reuseCounter += 1;
  state.footnoteCounts.set(id, reuseCounter);
  const link2 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + clobberPrefix + "fn-" + safeId,
      id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(counter) }]
  };
  state.patch(node2, link2);
  const sup = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [link2]
  };
  state.patch(node2, sup);
  return state.applyData(node2, sup);
}
function heading$1(state, node2) {
  const result = {
    type: "element",
    tagName: "h" + node2.depth,
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function html$3(state, node2) {
  if (state.options.allowDangerousHtml) {
    const result = { type: "raw", value: node2.value };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  return void 0;
}
function revert(state, node2) {
  const subtype = node2.referenceType;
  let suffix = "]";
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return [{ type: "text", value: "![" + node2.alt + suffix }];
  }
  const contents = state.all(node2);
  const head = contents[0];
  if (head && head.type === "text") {
    head.value = "[" + head.value;
  } else {
    contents.unshift({ type: "text", value: "[" });
  }
  const tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push({ type: "text", value: suffix });
  }
  return contents;
}
function imageReference$1(state, node2) {
  const id = String(node2.identifier).toUpperCase();
  const definition2 = state.definitionById.get(id);
  if (!definition2) {
    return revert(state, node2);
  }
  const properties = { src: normalizeUri(definition2.url || ""), alt: node2.alt };
  if (definition2.title !== null && definition2.title !== void 0) {
    properties.title = definition2.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function image$1(state, node2) {
  const properties = { src: normalizeUri(node2.url) };
  if (node2.alt !== null && node2.alt !== void 0) {
    properties.alt = node2.alt;
  }
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function inlineCode$1(state, node2) {
  const text2 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
  state.patch(node2, text2);
  const result = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [text2]
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function linkReference$1(state, node2) {
  const id = String(node2.identifier).toUpperCase();
  const definition2 = state.definitionById.get(id);
  if (!definition2) {
    return revert(state, node2);
  }
  const properties = { href: normalizeUri(definition2.url || "") };
  if (definition2.title !== null && definition2.title !== void 0) {
    properties.title = definition2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function link$1(state, node2) {
  const properties = { href: normalizeUri(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listItem$1(state, node2, parent) {
  const results = state.all(node2);
  const loose = parent ? listLoose(parent) : listItemLoose(node2);
  const properties = {};
  const children = [];
  if (typeof node2.checked === "boolean") {
    const head = results[0];
    let paragraph2;
    if (head && head.type === "element" && head.tagName === "p") {
      paragraph2 = head;
    } else {
      paragraph2 = { type: "element", tagName: "p", properties: {}, children: [] };
      results.unshift(paragraph2);
    }
    if (paragraph2.children.length > 0) {
      paragraph2.children.unshift({ type: "text", value: " " });
    }
    paragraph2.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: node2.checked, disabled: true },
      children: []
    });
    properties.className = ["task-list-item"];
  }
  let index2 = -1;
  while (++index2 < results.length) {
    const child = results[index2];
    if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
      children.push({ type: "text", value: "\n" });
    }
    if (child.type === "element" && child.tagName === "p" && !loose) {
      children.push(...child.children);
    } else {
      children.push(child);
    }
  }
  const tail = results[results.length - 1];
  if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
    children.push({ type: "text", value: "\n" });
  }
  const result = { type: "element", tagName: "li", properties, children };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listLoose(node2) {
  let loose = false;
  if (node2.type === "list") {
    loose = node2.spread || false;
    const children = node2.children;
    let index2 = -1;
    while (!loose && ++index2 < children.length) {
      loose = listItemLoose(children[index2]);
    }
  }
  return loose;
}
function listItemLoose(node2) {
  const spread = node2.spread;
  return spread === null || spread === void 0 ? node2.children.length > 1 : spread;
}
function list$1(state, node2) {
  const properties = {};
  const results = state.all(node2);
  let index2 = -1;
  if (typeof node2.start === "number" && node2.start !== 1) {
    properties.start = node2.start;
  }
  while (++index2 < results.length) {
    const child = results[index2];
    if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
      properties.className = ["contains-task-list"];
      break;
    }
  }
  const result = {
    type: "element",
    tagName: node2.ordered ? "ol" : "ul",
    properties,
    children: state.wrap(results, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function paragraph$1(state, node2) {
  const result = {
    type: "element",
    tagName: "p",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function root$2(state, node2) {
  const result = { type: "root", children: state.wrap(state.all(node2)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function strong$1(state, node2) {
  const result = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
const pointEnd = point("end");
const pointStart = point("start");
function point(type) {
  return point2;
  function point2(node2) {
    const point3 = node2 && node2.position && node2.position[type] || {};
    if (typeof point3.line === "number" && point3.line > 0 && typeof point3.column === "number" && point3.column > 0) {
      return {
        line: point3.line,
        column: point3.column,
        offset: typeof point3.offset === "number" && point3.offset > -1 ? point3.offset : void 0
      };
    }
  }
}
function position(node2) {
  const start = pointStart(node2);
  const end = pointEnd(node2);
  if (start && end) {
    return { start, end };
  }
}
function table(state, node2) {
  const rows = state.all(node2);
  const firstRow = rows.shift();
  const tableContent = [];
  if (firstRow) {
    const head = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: state.wrap([firstRow], true)
    };
    state.patch(node2.children[0], head);
    tableContent.push(head);
  }
  if (rows.length > 0) {
    const body = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: state.wrap(rows, true)
    };
    const start = pointStart(node2.children[1]);
    const end = pointEnd(node2.children[node2.children.length - 1]);
    if (start && end) body.position = { start, end };
    tableContent.push(body);
  }
  const result = {
    type: "element",
    tagName: "table",
    properties: {},
    children: state.wrap(tableContent, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function tableRow(state, node2, parent) {
  const siblings = parent ? parent.children : void 0;
  const rowIndex = siblings ? siblings.indexOf(node2) : 1;
  const tagName = rowIndex === 0 ? "th" : "td";
  const align = parent && parent.type === "table" ? parent.align : void 0;
  const length = align ? align.length : node2.children.length;
  let cellIndex = -1;
  const cells = [];
  while (++cellIndex < length) {
    const cell = node2.children[cellIndex];
    const properties = {};
    const alignValue = align ? align[cellIndex] : void 0;
    if (alignValue) {
      properties.align = alignValue;
    }
    let result2 = { type: "element", tagName, properties, children: [] };
    if (cell) {
      result2.children = state.all(cell);
      state.patch(cell, result2);
      result2 = state.applyData(cell, result2);
    }
    cells.push(result2);
  }
  const result = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: state.wrap(cells, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function tableCell(state, node2) {
  const result = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
const tab = 9;
const space = 32;
function trimLines(value) {
  const source = String(value);
  const search2 = /\r?\n|\r/g;
  let match = search2.exec(source);
  let last = 0;
  const lines = [];
  while (match) {
    lines.push(
      trimLine(source.slice(last, match.index), last > 0, true),
      match[0]
    );
    last = match.index + match[0].length;
    match = search2.exec(source);
  }
  lines.push(trimLine(source.slice(last), last > 0, false));
  return lines.join("");
}
function trimLine(value, start, end) {
  let startIndex = 0;
  let endIndex = value.length;
  if (start) {
    let code2 = value.codePointAt(startIndex);
    while (code2 === tab || code2 === space) {
      startIndex++;
      code2 = value.codePointAt(startIndex);
    }
  }
  if (end) {
    let code2 = value.codePointAt(endIndex - 1);
    while (code2 === tab || code2 === space) {
      endIndex--;
      code2 = value.codePointAt(endIndex - 1);
    }
  }
  return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}
function text$3(state, node2) {
  const result = { type: "text", value: trimLines(String(node2.value)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function thematicBreak$1(state, node2) {
  const result = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
const handlers = {
  blockquote: blockquote$1,
  break: hardBreak$1,
  code: code$2,
  delete: strikethrough,
  emphasis: emphasis$1,
  footnoteReference: footnoteReference$1,
  heading: heading$1,
  html: html$3,
  imageReference: imageReference$1,
  image: image$1,
  inlineCode: inlineCode$1,
  linkReference: linkReference$1,
  link: link$1,
  listItem: listItem$1,
  list: list$1,
  paragraph: paragraph$1,
  // @ts-expect-error: root is different, but hard to type.
  root: root$2,
  strong: strong$1,
  table,
  tableCell,
  tableRow,
  text: text$3,
  thematicBreak: thematicBreak$1,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return void 0;
}
const VOID = -1;
const PRIMITIVE = 0;
const ARRAY = 1;
const OBJECT = 2;
const DATE = 3;
const REGEXP = 4;
const MAP = 5;
const SET = 6;
const ERROR = 7;
const BIGINT = 8;
const env = typeof self === "object" ? self : globalThis;
const deserializer = ($, _2) => {
  const as = (out, index2) => {
    $.set(index2, out);
    return out;
  };
  const unpair = (index2) => {
    if ($.has(index2))
      return $.get(index2);
    const [type, value] = _2[index2];
    switch (type) {
      case PRIMITIVE:
      case VOID:
        return as(value, index2);
      case ARRAY: {
        const arr = as([], index2);
        for (const index3 of value)
          arr.push(unpair(index3));
        return arr;
      }
      case OBJECT: {
        const object = as({}, index2);
        for (const [key, index3] of value)
          object[unpair(key)] = unpair(index3);
        return object;
      }
      case DATE:
        return as(new Date(value), index2);
      case REGEXP: {
        const { source, flags } = value;
        return as(new RegExp(source, flags), index2);
      }
      case MAP: {
        const map2 = as(/* @__PURE__ */ new Map(), index2);
        for (const [key, index3] of value)
          map2.set(unpair(key), unpair(index3));
        return map2;
      }
      case SET: {
        const set = as(/* @__PURE__ */ new Set(), index2);
        for (const index3 of value)
          set.add(unpair(index3));
        return set;
      }
      case ERROR: {
        const { name: name2, message } = value;
        return as(new env[name2](message), index2);
      }
      case BIGINT:
        return as(BigInt(value), index2);
      case "BigInt":
        return as(Object(BigInt(value)), index2);
      case "ArrayBuffer":
        return as(new Uint8Array(value).buffer, value);
      case "DataView": {
        const { buffer } = new Uint8Array(value);
        return as(new DataView(buffer), value);
      }
    }
    return as(new env[type](value), index2);
  };
  return unpair;
};
const deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);
const EMPTY = "";
const { toString: toString$1 } = {};
const { keys } = Object;
const typeOf = (value) => {
  const type = typeof value;
  if (type !== "object" || !value)
    return [PRIMITIVE, type];
  const asString = toString$1.call(value).slice(8, -1);
  switch (asString) {
    case "Array":
      return [ARRAY, EMPTY];
    case "Object":
      return [OBJECT, EMPTY];
    case "Date":
      return [DATE, EMPTY];
    case "RegExp":
      return [REGEXP, EMPTY];
    case "Map":
      return [MAP, EMPTY];
    case "Set":
      return [SET, EMPTY];
    case "DataView":
      return [ARRAY, asString];
  }
  if (asString.includes("Array"))
    return [ARRAY, asString];
  if (asString.includes("Error"))
    return [ERROR, asString];
  return [OBJECT, asString];
};
const shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
const serializer = (strict, json, $, _2) => {
  const as = (out, value) => {
    const index2 = _2.push(out) - 1;
    $.set(value, index2);
    return index2;
  };
  const pair = (value) => {
    if ($.has(value))
      return $.get(value);
    let [TYPE, type] = typeOf(value);
    switch (TYPE) {
      case PRIMITIVE: {
        let entry = value;
        switch (type) {
          case "bigint":
            TYPE = BIGINT;
            entry = value.toString();
            break;
          case "function":
          case "symbol":
            if (strict)
              throw new TypeError("unable to serialize " + type);
            entry = null;
            break;
          case "undefined":
            return as([VOID], value);
        }
        return as([TYPE, entry], value);
      }
      case ARRAY: {
        if (type) {
          let spread = value;
          if (type === "DataView") {
            spread = new Uint8Array(value.buffer);
          } else if (type === "ArrayBuffer") {
            spread = new Uint8Array(value);
          }
          return as([type, [...spread]], value);
        }
        const arr = [];
        const index2 = as([TYPE, arr], value);
        for (const entry of value)
          arr.push(pair(entry));
        return index2;
      }
      case OBJECT: {
        if (type) {
          switch (type) {
            case "BigInt":
              return as([type, value.toString()], value);
            case "Boolean":
            case "Number":
            case "String":
              return as([type, value.valueOf()], value);
          }
        }
        if (json && "toJSON" in value)
          return pair(value.toJSON());
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const key of keys(value)) {
          if (strict || !shouldSkip(typeOf(value[key])))
            entries.push([pair(key), pair(value[key])]);
        }
        return index2;
      }
      case DATE:
        return as([TYPE, value.toISOString()], value);
      case REGEXP: {
        const { source, flags } = value;
        return as([TYPE, { source, flags }], value);
      }
      case MAP: {
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const [key, entry] of value) {
          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))
            entries.push([pair(key), pair(entry)]);
        }
        return index2;
      }
      case SET: {
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const entry of value) {
          if (strict || !shouldSkip(typeOf(entry)))
            entries.push(pair(entry));
        }
        return index2;
      }
    }
    const { message } = value;
    return as([TYPE, { name: type, message }], value);
  };
  return pair;
};
const serialize$1 = (value, { json, lossy } = {}) => {
  const _2 = [];
  return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _2)(value), _2;
};
const structuredClone$1 = typeof structuredClone === "function" ? (
  /* c8 ignore start */
  (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize$1(any, options)) : structuredClone(any)
) : (any, options) => deserialize(serialize$1(any, options));
function defaultFootnoteBackContent(_2, rereferenceIndex) {
  const result = [{ type: "text", value: "â†©" }];
  if (rereferenceIndex > 1) {
    result.push({
      type: "element",
      tagName: "sup",
      properties: {},
      children: [{ type: "text", value: String(rereferenceIndex) }]
    });
  }
  return result;
}
function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
  return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
}
function footer(state) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
  const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
  const footnoteLabel = state.options.footnoteLabel || "Footnotes";
  const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
  const footnoteLabelProperties = state.options.footnoteLabelProperties || {
    className: ["sr-only"]
  };
  const listItems = [];
  let referenceIndex = -1;
  while (++referenceIndex < state.footnoteOrder.length) {
    const definition2 = state.footnoteById.get(
      state.footnoteOrder[referenceIndex]
    );
    if (!definition2) {
      continue;
    }
    const content2 = state.all(definition2);
    const id = String(definition2.identifier).toUpperCase();
    const safeId = normalizeUri(id.toLowerCase());
    let rereferenceIndex = 0;
    const backReferences = [];
    const counts = state.footnoteCounts.get(id);
    while (counts !== void 0 && ++rereferenceIndex <= counts) {
      if (backReferences.length > 0) {
        backReferences.push({ type: "text", value: " " });
      }
      let children = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
      if (typeof children === "string") {
        children = { type: "text", value: children };
      }
      backReferences.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(children) ? children : [children]
      });
    }
    const tail = content2[content2.length - 1];
    if (tail && tail.type === "element" && tail.tagName === "p") {
      const tailTail = tail.children[tail.children.length - 1];
      if (tailTail && tailTail.type === "text") {
        tailTail.value += " ";
      } else {
        tail.children.push({ type: "text", value: " " });
      }
      tail.children.push(...backReferences);
    } else {
      content2.push(...backReferences);
    }
    const listItem2 = {
      type: "element",
      tagName: "li",
      properties: { id: clobberPrefix + "fn-" + safeId },
      children: state.wrap(content2, true)
    };
    state.patch(definition2, listItem2);
    listItems.push(listItem2);
  }
  if (listItems.length === 0) {
    return;
  }
  return {
    type: "element",
    tagName: "section",
    properties: { dataFootnotes: true, className: ["footnotes"] },
    children: [
      {
        type: "element",
        tagName: footnoteLabelTagName,
        properties: {
          ...structuredClone$1(footnoteLabelProperties),
          id: "footnote-label"
        },
        children: [{ type: "text", value: footnoteLabel }]
      },
      { type: "text", value: "\n" },
      {
        type: "element",
        tagName: "ol",
        properties: {},
        children: state.wrap(listItems, true)
      },
      { type: "text", value: "\n" }
    ]
  };
}
const own$1 = {}.hasOwnProperty;
const emptyOptions$4 = {};
function createState(tree, options) {
  const settings = options || emptyOptions$4;
  const definitionById = /* @__PURE__ */ new Map();
  const footnoteById = /* @__PURE__ */ new Map();
  const footnoteCounts = /* @__PURE__ */ new Map();
  const handlers$1 = { ...handlers, ...settings.handlers };
  const state = {
    all: all2,
    applyData,
    definitionById,
    footnoteById,
    footnoteCounts,
    footnoteOrder: [],
    handlers: handlers$1,
    one: one2,
    options: settings,
    patch,
    wrap
  };
  visit(tree, function(node2) {
    if (node2.type === "definition" || node2.type === "footnoteDefinition") {
      const map2 = node2.type === "definition" ? definitionById : footnoteById;
      const id = String(node2.identifier).toUpperCase();
      if (!map2.has(id)) {
        map2.set(id, node2);
      }
    }
  });
  return state;
  function one2(node2, parent) {
    const type = node2.type;
    const handle2 = state.handlers[type];
    if (own$1.call(state.handlers, type) && handle2) {
      return handle2(state, node2, parent);
    }
    if (state.options.passThrough && state.options.passThrough.includes(type)) {
      if ("children" in node2) {
        const { children, ...shallow } = node2;
        const result = structuredClone$1(shallow);
        result.children = state.all(node2);
        return result;
      }
      return structuredClone$1(node2);
    }
    const unknown = state.options.unknownHandler || defaultUnknownHandler;
    return unknown(state, node2, parent);
  }
  function all2(parent) {
    const values2 = [];
    if ("children" in parent) {
      const nodes = parent.children;
      let index2 = -1;
      while (++index2 < nodes.length) {
        const result = state.one(nodes[index2], parent);
        if (result) {
          if (index2 && nodes[index2 - 1].type === "break") {
            if (!Array.isArray(result) && result.type === "text") {
              result.value = trimMarkdownSpaceStart(result.value);
            }
            if (!Array.isArray(result) && result.type === "element") {
              const head = result.children[0];
              if (head && head.type === "text") {
                head.value = trimMarkdownSpaceStart(head.value);
              }
            }
          }
          if (Array.isArray(result)) {
            values2.push(...result);
          } else {
            values2.push(result);
          }
        }
      }
    }
    return values2;
  }
}
function patch(from, to) {
  if (from.position) to.position = position(from);
}
function applyData(from, to) {
  let result = to;
  if (from && from.data) {
    const hName = from.data.hName;
    const hChildren = from.data.hChildren;
    const hProperties = from.data.hProperties;
    if (typeof hName === "string") {
      if (result.type === "element") {
        result.tagName = hName;
      } else {
        const children = "children" in result ? result.children : [result];
        result = { type: "element", tagName: hName, properties: {}, children };
      }
    }
    if (result.type === "element" && hProperties) {
      Object.assign(result.properties, structuredClone$1(hProperties));
    }
    if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
      result.children = hChildren;
    }
  }
  return result;
}
function defaultUnknownHandler(state, node2) {
  const data = node2.data || {};
  const result = "value" in node2 && !(own$1.call(data, "hProperties") || own$1.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function wrap(nodes, loose) {
  const result = [];
  let index2 = -1;
  if (loose) {
    result.push({ type: "text", value: "\n" });
  }
  while (++index2 < nodes.length) {
    if (index2) result.push({ type: "text", value: "\n" });
    result.push(nodes[index2]);
  }
  if (loose && nodes.length > 0) {
    result.push({ type: "text", value: "\n" });
  }
  return result;
}
function trimMarkdownSpaceStart(value) {
  let index2 = 0;
  let code2 = value.charCodeAt(index2);
  while (code2 === 9 || code2 === 32) {
    index2++;
    code2 = value.charCodeAt(index2);
  }
  return value.slice(index2);
}
function toHast(tree, options) {
  const state = createState(tree, options);
  const node2 = state.one(tree, void 0);
  const foot = footer(state);
  const result = Array.isArray(node2) ? { type: "root", children: node2 } : node2 || { type: "root", children: [] };
  if (foot) {
    ok$2("children" in result);
    result.children.push({ type: "text", value: "\n" }, foot);
  }
  return result;
}
function remarkRehype(destination, options) {
  if (destination && "run" in destination) {
    return async function(tree, file) {
      const hastTree = (
        /** @type {HastRoot} */
        toHast(tree, { file, ...options })
      );
      await destination.run(hastTree, file);
    };
  }
  return function(tree, file) {
    return (
      /** @type {HastRoot} */
      toHast(tree, { file, ...destination || options })
    );
  };
}
function stringify$1(values2, options) {
  const settings = {};
  const input = values2[values2.length - 1] === "" ? [...values2, ""] : values2;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}
const nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
const nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
const emptyOptions$3 = {};
function name(name2, options) {
  const settings = emptyOptions$3;
  const re2 = settings.jsx ? nameReJsx : nameRe;
  return re2.test(name2);
}
const re$1 = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty$1(thing.value) : false : empty$1(thing);
}
function empty$1(value) {
  return value.replace(re$1, "") === "";
}
class Schema {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(property, normal, space2) {
    this.normal = normal;
    this.property = property;
    if (space2) {
      this.space = space2;
    }
  }
}
Schema.prototype.normal = {};
Schema.prototype.property = {};
Schema.prototype.space = void 0;
function merge(definitions, space2) {
  const property = {};
  const normal = {};
  for (const definition2 of definitions) {
    Object.assign(property, definition2.property);
    Object.assign(normal, definition2.normal);
  }
  return new Schema(property, normal, space2);
}
function normalize(value) {
  return value.toLowerCase();
}
class Info {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(property, attribute) {
    this.attribute = attribute;
    this.property = property;
  }
}
Info.prototype.attribute = "";
Info.prototype.booleanish = false;
Info.prototype.boolean = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.commaSeparated = false;
Info.prototype.defined = false;
Info.prototype.mustUseProperty = false;
Info.prototype.number = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.property = "";
Info.prototype.spaceSeparated = false;
Info.prototype.space = void 0;
let powers = 0;
const boolean = increment();
const booleanish = increment();
const overloadedBoolean = increment();
const number = increment();
const spaceSeparated = increment();
const commaSeparated = increment();
const commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}
const types = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean,
  booleanish,
  commaOrSpaceSeparated,
  commaSeparated,
  number,
  overloadedBoolean,
  spaceSeparated
}, Symbol.toStringTag, { value: "Module" }));
const checks = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(types)
);
class DefinedInfo extends Info {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(property, attribute, mask, space2) {
    let index2 = -1;
    super(property, attribute);
    mark(this, "space", space2);
    if (typeof mask === "number") {
      while (++index2 < checks.length) {
        const check = checks[index2];
        mark(this, checks[index2], (mask & types[check]) === types[check]);
      }
    }
  }
}
DefinedInfo.prototype.defined = true;
function mark(values2, key, value) {
  if (value) {
    values2[key] = value;
  }
}
function create(definition2) {
  const properties = {};
  const normals = {};
  for (const [property, value] of Object.entries(definition2.properties)) {
    const info = new DefinedInfo(
      property,
      definition2.transform(definition2.attributes || {}, property),
      value,
      definition2.space
    );
    if (definition2.mustUseProperty && definition2.mustUseProperty.includes(property)) {
      info.mustUseProperty = true;
    }
    properties[property] = info;
    normals[normalize(property)] = property;
    normals[normalize(info.attribute)] = property;
  }
  return new Schema(properties, normals, definition2.space);
}
const aria = create({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  },
  transform(_2, property) {
    return property === "role" ? property : "aria-" + property.slice(4).toLowerCase();
  }
});
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase());
}
const html$2 = create({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: null,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: overloadedBoolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootClonable: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: caseInsensitiveTransform
});
const svg$1 = create({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: caseSensitiveTransform
});
const xlink = create({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(_2, property) {
    return "xlink:" + property.slice(5).toLowerCase();
  }
});
const xmlns = create({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: caseInsensitiveTransform
});
const xml = create({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(_2, property) {
    return "xml:" + property.slice(3).toLowerCase();
  }
});
const hastToReact = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
};
const cap$1 = /[A-Z]/g;
const dash = /-[a-z]/g;
const valid = /^data[-\w.:]+$/i;
function find(schema, value) {
  const normal = normalize(value);
  let property = value;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      property = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap$1, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(property, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}
const html$1 = merge([aria, html$2, xlink, xmlns, xml], "html");
const svg = merge([aria, svg$1, xlink, xmlns, xml], "svg");
function parse(value) {
  const input = String(value || "").trim();
  return input ? input.split(/[ \t\n\r\f]+/g) : [];
}
function stringify(values2) {
  return values2.join(" ").trim();
}
var cjs$1 = {};
var inlineStyleParser;
var hasRequiredInlineStyleParser;
function requireInlineStyleParser() {
  if (hasRequiredInlineStyleParser) return inlineStyleParser;
  hasRequiredInlineStyleParser = 1;
  var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
  var NEWLINE_REGEX = /\n/g;
  var WHITESPACE_REGEX = /^\s*/;
  var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
  var COLON_REGEX = /^:\s*/;
  var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
  var SEMICOLON_REGEX = /^[;\s]*/;
  var TRIM_REGEX = /^\s+|\s+$/g;
  var NEWLINE = "\n";
  var FORWARD_SLASH = "/";
  var ASTERISK = "*";
  var EMPTY_STRING = "";
  var TYPE_COMMENT = "comment";
  var TYPE_DECLARATION = "declaration";
  inlineStyleParser = function(style, options) {
    if (typeof style !== "string") {
      throw new TypeError("First argument must be a string");
    }
    if (!style) return [];
    options = options || {};
    var lineno = 1;
    var column = 1;
    function updatePosition(str) {
      var lines = str.match(NEWLINE_REGEX);
      if (lines) lineno += lines.length;
      var i = str.lastIndexOf(NEWLINE);
      column = ~i ? str.length - i : column + str.length;
    }
    function position2() {
      var start = { line: lineno, column };
      return function(node2) {
        node2.position = new Position(start);
        whitespace2();
        return node2;
      };
    }
    function Position(start) {
      this.start = start;
      this.end = { line: lineno, column };
      this.source = options.source;
    }
    Position.prototype.content = style;
    function error(msg) {
      var err = new Error(
        options.source + ":" + lineno + ":" + column + ": " + msg
      );
      err.reason = msg;
      err.filename = options.source;
      err.line = lineno;
      err.column = column;
      err.source = style;
      if (options.silent) ;
      else {
        throw err;
      }
    }
    function match(re2) {
      var m2 = re2.exec(style);
      if (!m2) return;
      var str = m2[0];
      updatePosition(str);
      style = style.slice(str.length);
      return m2;
    }
    function whitespace2() {
      match(WHITESPACE_REGEX);
    }
    function comments(rules) {
      var c;
      rules = rules || [];
      while (c = comment()) {
        if (c !== false) {
          rules.push(c);
        }
      }
      return rules;
    }
    function comment() {
      var pos = position2();
      if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;
      var i = 2;
      while (EMPTY_STRING != style.charAt(i) && (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))) {
        ++i;
      }
      i += 2;
      if (EMPTY_STRING === style.charAt(i - 1)) {
        return error("End of comment missing");
      }
      var str = style.slice(2, i - 2);
      column += 2;
      updatePosition(str);
      style = style.slice(i);
      column += 2;
      return pos({
        type: TYPE_COMMENT,
        comment: str
      });
    }
    function declaration() {
      var pos = position2();
      var prop = match(PROPERTY_REGEX);
      if (!prop) return;
      comment();
      if (!match(COLON_REGEX)) return error("property missing ':'");
      var val = match(VALUE_REGEX);
      var ret = pos({
        type: TYPE_DECLARATION,
        property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
        value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
      });
      match(SEMICOLON_REGEX);
      return ret;
    }
    function declarations() {
      var decls = [];
      comments(decls);
      var decl;
      while (decl = declaration()) {
        if (decl !== false) {
          decls.push(decl);
          comments(decls);
        }
      }
      return decls;
    }
    whitespace2();
    return declarations();
  };
  function trim(str) {
    return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
  }
  return inlineStyleParser;
}
var hasRequiredCjs$1;
function requireCjs$1() {
  if (hasRequiredCjs$1) return cjs$1;
  hasRequiredCjs$1 = 1;
  var __importDefault = cjs$1 && cjs$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(cjs$1, "__esModule", { value: true });
  cjs$1.default = StyleToObject;
  var inline_style_parser_1 = __importDefault(requireInlineStyleParser());
  function StyleToObject(style, iterator) {
    var styleObject = null;
    if (!style || typeof style !== "string") {
      return styleObject;
    }
    var declarations = (0, inline_style_parser_1.default)(style);
    var hasIterator = typeof iterator === "function";
    declarations.forEach(function(declaration) {
      if (declaration.type !== "declaration") {
        return;
      }
      var property = declaration.property, value = declaration.value;
      if (hasIterator) {
        iterator(property, value, declaration);
      } else if (value) {
        styleObject = styleObject || {};
        styleObject[property] = value;
      }
    });
    return styleObject;
  }
  return cjs$1;
}
var utilities = {};
var hasRequiredUtilities;
function requireUtilities() {
  if (hasRequiredUtilities) return utilities;
  hasRequiredUtilities = 1;
  Object.defineProperty(utilities, "__esModule", { value: true });
  utilities.camelCase = void 0;
  var CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9_-]+$/;
  var HYPHEN_REGEX = /-([a-z])/g;
  var NO_HYPHEN_REGEX = /^[^-]+$/;
  var VENDOR_PREFIX_REGEX = /^-(webkit|moz|ms|o|khtml)-/;
  var MS_VENDOR_PREFIX_REGEX = /^-(ms)-/;
  var skipCamelCase = function(property) {
    return !property || NO_HYPHEN_REGEX.test(property) || CUSTOM_PROPERTY_REGEX.test(property);
  };
  var capitalize = function(match, character) {
    return character.toUpperCase();
  };
  var trimHyphen = function(match, prefix) {
    return "".concat(prefix, "-");
  };
  var camelCase = function(property, options) {
    if (options === void 0) {
      options = {};
    }
    if (skipCamelCase(property)) {
      return property;
    }
    property = property.toLowerCase();
    if (options.reactCompat) {
      property = property.replace(MS_VENDOR_PREFIX_REGEX, trimHyphen);
    } else {
      property = property.replace(VENDOR_PREFIX_REGEX, trimHyphen);
    }
    return property.replace(HYPHEN_REGEX, capitalize);
  };
  utilities.camelCase = camelCase;
  return utilities;
}
var cjs;
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  var __importDefault = cjs && cjs.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var style_to_object_1 = __importDefault(requireCjs$1());
  var utilities_1 = requireUtilities();
  function StyleToJS(style, options) {
    var output = {};
    if (!style || typeof style !== "string") {
      return output;
    }
    (0, style_to_object_1.default)(style, function(property, value) {
      if (property && value) {
        output[(0, utilities_1.camelCase)(property, options)] = value;
      }
    });
    return output;
  }
  StyleToJS.default = StyleToJS;
  cjs = StyleToJS;
  return cjs;
}
var cjsExports = requireCjs();
const styleToJs = /* @__PURE__ */ getDefaultExportFromCjs(cjsExports);
const own = {}.hasOwnProperty;
const emptyMap = /* @__PURE__ */ new Map();
const cap = /[A-Z]/g;
const tableElements = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
const tableCellElement = /* @__PURE__ */ new Set(["td", "th"]);
const docs = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function toJsxRuntime(tree, options) {
  if (!options || options.Fragment === void 0) {
    throw new TypeError("Expected `Fragment` in options");
  }
  const filePath = options.filePath || void 0;
  let create2;
  if (options.development) {
    if (typeof options.jsxDEV !== "function") {
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    }
    create2 = developmentCreate(filePath, options.jsxDEV);
  } else {
    if (typeof options.jsx !== "function") {
      throw new TypeError("Expected `jsx` in production options");
    }
    if (typeof options.jsxs !== "function") {
      throw new TypeError("Expected `jsxs` in production options");
    }
    create2 = productionCreate(filePath, options.jsx, options.jsxs);
  }
  const state = {
    Fragment: options.Fragment,
    ancestors: [],
    components: options.components || {},
    create: create2,
    elementAttributeNameCase: options.elementAttributeNameCase || "react",
    evaluater: options.createEvaluater ? options.createEvaluater() : void 0,
    filePath,
    ignoreInvalidStyle: options.ignoreInvalidStyle || false,
    passKeys: options.passKeys !== false,
    passNode: options.passNode || false,
    schema: options.space === "svg" ? svg : html$1,
    stylePropertyNameCase: options.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: options.tableCellAlignToStyle !== false
  };
  const result = one$1(state, tree, void 0);
  if (result && typeof result !== "string") {
    return result;
  }
  return state.create(
    tree,
    state.Fragment,
    { children: result || void 0 },
    void 0
  );
}
function one$1(state, node2, key) {
  if (node2.type === "element") {
    return element$1(state, node2, key);
  }
  if (node2.type === "mdxFlowExpression" || node2.type === "mdxTextExpression") {
    return mdxExpression(state, node2);
  }
  if (node2.type === "mdxJsxFlowElement" || node2.type === "mdxJsxTextElement") {
    return mdxJsxElement(state, node2, key);
  }
  if (node2.type === "mdxjsEsm") {
    return mdxEsm(state, node2);
  }
  if (node2.type === "root") {
    return root$1(state, node2, key);
  }
  if (node2.type === "text") {
    return text$2(state, node2);
  }
}
function element$1(state, node2, key) {
  const parentSchema = state.schema;
  let schema = parentSchema;
  if (node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
    schema = svg;
    state.schema = schema;
  }
  state.ancestors.push(node2);
  const type = findComponentFromName(state, node2.tagName, false);
  const props = createElementProps(state, node2);
  let children = createChildren(state, node2);
  if (tableElements.has(node2.tagName)) {
    children = children.filter(function(child) {
      return typeof child === "string" ? !whitespace(child) : true;
    });
  }
  addNode(state, props, type, node2);
  addChildren(props, children);
  state.ancestors.pop();
  state.schema = parentSchema;
  return state.create(node2, type, props, key);
}
function mdxExpression(state, node2) {
  if (node2.data && node2.data.estree && state.evaluater) {
    const program = node2.data.estree;
    const expression = program.body[0];
    ok$2(expression.type === "ExpressionStatement");
    return (
      /** @type {Child | undefined} */
      state.evaluater.evaluateExpression(expression.expression)
    );
  }
  crashEstree(state, node2.position);
}
function mdxEsm(state, node2) {
  if (node2.data && node2.data.estree && state.evaluater) {
    return (
      /** @type {Child | undefined} */
      state.evaluater.evaluateProgram(node2.data.estree)
    );
  }
  crashEstree(state, node2.position);
}
function mdxJsxElement(state, node2, key) {
  const parentSchema = state.schema;
  let schema = parentSchema;
  if (node2.name === "svg" && parentSchema.space === "html") {
    schema = svg;
    state.schema = schema;
  }
  state.ancestors.push(node2);
  const type = node2.name === null ? state.Fragment : findComponentFromName(state, node2.name, true);
  const props = createJsxElementProps(state, node2);
  const children = createChildren(state, node2);
  addNode(state, props, type, node2);
  addChildren(props, children);
  state.ancestors.pop();
  state.schema = parentSchema;
  return state.create(node2, type, props, key);
}
function root$1(state, node2, key) {
  const props = {};
  addChildren(props, createChildren(state, node2));
  return state.create(node2, state.Fragment, props, key);
}
function text$2(_2, node2) {
  return node2.value;
}
function addNode(state, props, type, node2) {
  if (typeof type !== "string" && type !== state.Fragment && state.passNode) {
    props.node = node2;
  }
}
function addChildren(props, children) {
  if (children.length > 0) {
    const value = children.length > 1 ? children : children[0];
    if (value) {
      props.children = value;
    }
  }
}
function productionCreate(_2, jsx, jsxs) {
  return create2;
  function create2(_3, type, props, key) {
    const isStaticChildren = Array.isArray(props.children);
    const fn = isStaticChildren ? jsxs : jsx;
    return key ? fn(type, props, key) : fn(type, props);
  }
}
function developmentCreate(filePath, jsxDEV) {
  return create2;
  function create2(node2, type, props, key) {
    const isStaticChildren = Array.isArray(props.children);
    const point2 = pointStart(node2);
    return jsxDEV(
      type,
      props,
      key,
      isStaticChildren,
      {
        columnNumber: point2 ? point2.column - 1 : void 0,
        fileName: filePath,
        lineNumber: point2 ? point2.line : void 0
      },
      void 0
    );
  }
}
function createElementProps(state, node2) {
  const props = {};
  let alignValue;
  let prop;
  for (prop in node2.properties) {
    if (prop !== "children" && own.call(node2.properties, prop)) {
      const result = createProperty(state, prop, node2.properties[prop]);
      if (result) {
        const [key, value] = result;
        if (state.tableCellAlignToStyle && key === "align" && typeof value === "string" && tableCellElement.has(node2.tagName)) {
          alignValue = value;
        } else {
          props[key] = value;
        }
      }
    }
  }
  if (alignValue) {
    const style = (
      /** @type {Style} */
      props.style || (props.style = {})
    );
    style[state.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = alignValue;
  }
  return props;
}
function createJsxElementProps(state, node2) {
  const props = {};
  for (const attribute of node2.attributes) {
    if (attribute.type === "mdxJsxExpressionAttribute") {
      if (attribute.data && attribute.data.estree && state.evaluater) {
        const program = attribute.data.estree;
        const expression = program.body[0];
        ok$2(expression.type === "ExpressionStatement");
        const objectExpression = expression.expression;
        ok$2(objectExpression.type === "ObjectExpression");
        const property = objectExpression.properties[0];
        ok$2(property.type === "SpreadElement");
        Object.assign(
          props,
          state.evaluater.evaluateExpression(property.argument)
        );
      } else {
        crashEstree(state, node2.position);
      }
    } else {
      const name2 = attribute.name;
      let value;
      if (attribute.value && typeof attribute.value === "object") {
        if (attribute.value.data && attribute.value.data.estree && state.evaluater) {
          const program = attribute.value.data.estree;
          const expression = program.body[0];
          ok$2(expression.type === "ExpressionStatement");
          value = state.evaluater.evaluateExpression(expression.expression);
        } else {
          crashEstree(state, node2.position);
        }
      } else {
        value = attribute.value === null ? true : attribute.value;
      }
      props[name2] = /** @type {Props[keyof Props]} */
      value;
    }
  }
  return props;
}
function createChildren(state, node2) {
  const children = [];
  let index2 = -1;
  const countsByName = state.passKeys ? /* @__PURE__ */ new Map() : emptyMap;
  while (++index2 < node2.children.length) {
    const child = node2.children[index2];
    let key;
    if (state.passKeys) {
      const name2 = child.type === "element" ? child.tagName : child.type === "mdxJsxFlowElement" || child.type === "mdxJsxTextElement" ? child.name : void 0;
      if (name2) {
        const count = countsByName.get(name2) || 0;
        key = name2 + "-" + count;
        countsByName.set(name2, count + 1);
      }
    }
    const result = one$1(state, child, key);
    if (result !== void 0) children.push(result);
  }
  return children;
}
function createProperty(state, prop, value) {
  const info = find(state.schema, prop);
  if (value === null || value === void 0 || typeof value === "number" && Number.isNaN(value)) {
    return;
  }
  if (Array.isArray(value)) {
    value = info.commaSeparated ? stringify$1(value) : stringify(value);
  }
  if (info.property === "style") {
    let styleObject = typeof value === "object" ? value : parseStyle(state, String(value));
    if (state.stylePropertyNameCase === "css") {
      styleObject = transformStylesToCssCasing(styleObject);
    }
    return ["style", styleObject];
  }
  return [
    state.elementAttributeNameCase === "react" && info.space ? hastToReact[info.property] || info.property : info.attribute,
    value
  ];
}
function parseStyle(state, value) {
  try {
    return styleToJs(value, { reactCompat: true });
  } catch (error) {
    if (state.ignoreInvalidStyle) {
      return {};
    }
    const cause = (
      /** @type {Error} */
      error
    );
    const message = new VFileMessage("Cannot parse `style` attribute", {
      ancestors: state.ancestors,
      cause,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    message.file = state.filePath || void 0;
    message.url = docs + "#cannot-parse-style-attribute";
    throw message;
  }
}
function findComponentFromName(state, name$1, allowExpression) {
  let result;
  if (!allowExpression) {
    result = { type: "Literal", value: name$1 };
  } else if (name$1.includes(".")) {
    const identifiers = name$1.split(".");
    let index2 = -1;
    let node2;
    while (++index2 < identifiers.length) {
      const prop = name(identifiers[index2]) ? { type: "Identifier", name: identifiers[index2] } : { type: "Literal", value: identifiers[index2] };
      node2 = node2 ? {
        type: "MemberExpression",
        object: node2,
        property: prop,
        computed: Boolean(index2 && prop.type === "Literal"),
        optional: false
      } : prop;
    }
    ok$2(node2, "always a result");
    result = node2;
  } else {
    result = name(name$1) && !/^[a-z]/.test(name$1) ? { type: "Identifier", name: name$1 } : { type: "Literal", value: name$1 };
  }
  if (result.type === "Literal") {
    const name2 = (
      /** @type {string | number} */
      result.value
    );
    return own.call(state.components, name2) ? state.components[name2] : name2;
  }
  if (state.evaluater) {
    return state.evaluater.evaluateExpression(result);
  }
  crashEstree(state);
}
function crashEstree(state, place) {
  const message = new VFileMessage(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: state.ancestors,
      place,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  message.file = state.filePath || void 0;
  message.url = docs + "#cannot-handle-mdx-estrees-without-createevaluater";
  throw message;
}
function transformStylesToCssCasing(domCasing) {
  const cssCasing = {};
  let from;
  for (from in domCasing) {
    if (own.call(domCasing, from)) {
      cssCasing[transformStyleToCssCasing(from)] = domCasing[from];
    }
  }
  return cssCasing;
}
function transformStyleToCssCasing(from) {
  let to = from.replace(cap, toDash);
  if (to.slice(0, 3) === "ms-") to = "-" + to;
  return to;
}
function toDash($0) {
  return "-" + $0.toLowerCase();
}
function rehypeReact(options) {
  const self2 = (
    /** @type {Processor} */
    this
  );
  self2.compiler = compiler2;
  function compiler2(tree, file) {
    return toJsxRuntime(tree, { filePath: file.path, ...options });
  }
}
const convertElement = (
  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return element;
    }
    if (typeof test === "string") {
      return tagNameFactory(test);
    }
    if (typeof test === "object") {
      return anyFactory$1(test);
    }
    if (typeof test === "function") {
      return castFactory$1(test);
    }
    throw new Error("Expected function, string, or array as `test`");
  }
);
function anyFactory$1(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convertElement(tests[index2]);
  }
  return castFactory$1(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, parameters)) return true;
    }
    return false;
  }
}
function tagNameFactory(check) {
  return castFactory$1(tagName);
  function tagName(element2) {
    return element2.tagName === check;
  }
}
function castFactory$1(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeAnElement(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function element(element2) {
  return Boolean(
    element2 && typeof element2 === "object" && "type" in element2 && element2.type === "element" && "tagName" in element2 && typeof element2.tagName === "string"
  );
}
function looksLikeAnElement(value) {
  return value !== null && typeof value === "object" && "type" in value && "tagName" in value;
}
const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
const WINDOWS_PATH_REGEX = /^[a-zA-Z]:\\/;
function isAbsoluteUrl(url) {
  if (typeof url !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof url}\``);
  }
  if (WINDOWS_PATH_REGEX.test(url)) {
    return false;
  }
  return ABSOLUTE_URL_REGEX.test(url);
}
const defaultProtocols = ["http", "https"];
const defaultRel = ["nofollow"];
const emptyOptions$2 = {};
function rehypeExternalLinks(options) {
  const settings = options || emptyOptions$2;
  const protocols = settings.protocols || defaultProtocols;
  const is = convertElement(settings.test);
  return function(tree) {
    visit(tree, "element", function(node2, index2, parent) {
      if (node2.tagName === "a" && typeof node2.properties.href === "string" && is(node2, index2, parent)) {
        const url = node2.properties.href;
        if (isAbsoluteUrl(url) ? protocols.includes(url.slice(0, url.indexOf(":"))) : url.startsWith("//")) {
          const contentRaw = createIfNeeded(settings.content, node2);
          const content2 = contentRaw && !Array.isArray(contentRaw) ? [contentRaw] : contentRaw;
          const relRaw = createIfNeeded(settings.rel, node2) || defaultRel;
          const rel = typeof relRaw === "string" ? parse(relRaw) : relRaw;
          const target = createIfNeeded(settings.target, node2);
          const properties = createIfNeeded(settings.properties, node2);
          if (properties) {
            Object.assign(node2.properties, structuredClone$1(properties));
          }
          if (rel.length > 0) {
            node2.properties.rel = [...rel];
          }
          if (target) {
            node2.properties.target = target;
          }
          if (content2) {
            const properties2 = createIfNeeded(settings.contentProperties, node2) || {};
            node2.children.push({
              type: "element",
              tagName: "span",
              properties: structuredClone$1(properties2),
              children: structuredClone$1(content2)
            });
          }
        }
      }
    });
  };
}
function createIfNeeded(value, element2) {
  return typeof value === "function" ? value(element2) : value;
}
if (!window._vue_richtext_widgets) {
  window._vue_richtext_widgets = {};
}
const isWidgetRegistered = (id) => {
  return !!window._vue_richtext_widgets[id];
};
const hasInteractiveView = (id) => {
  return !!window._vue_richtext_widgets[id]?.hasInteractiveView;
};
const hasFullWidth = (id) => {
  return !!window._vue_richtext_widgets[id]?.fullWidth;
};
const registerWidget = (id, callback, onDestroy = (el) => {
}, props) => {
  const propsWithDefaults = {
    hasInteractiveView: true,
    fullWidth: false,
    ...props
  };
  if (window._vue_richtext_widgets[id]) {
    console.error("Widget for id " + id + " already registered");
    return;
  }
  window._vue_richtext_widgets[id] = {
    id,
    callback,
    onDestroy,
    ...propsWithDefaults
  };
};
const renderWidget = (el, { richObjectType, richObject, accessible, interactive }) => {
  if (richObjectType === "open-graph") {
    return;
  }
  if (!window._vue_richtext_widgets[richObjectType]) {
    console.error("Widget for rich object type " + richObjectType + " not registered");
    return;
  }
  window._vue_richtext_widgets[richObjectType].callback(el, { richObjectType, richObject, accessible, interactive });
};
const destroyWidget = (richObjectType, el) => {
  if (richObjectType === "open-graph") {
    return;
  }
  if (!window._vue_richtext_widgets[richObjectType]) {
    return;
  }
  window._vue_richtext_widgets[richObjectType].onDestroy(el);
};
window._registerWidget = (id, callback, onDestroy, props) => {
  registerWidget(id, callback, onDestroy, props);
};
if (!window._vue_richtext_custom_picker_elements) {
  window._vue_richtext_custom_picker_elements = {};
}
const registerCustomPickerElement = (id, callback, onDestroy = (el) => {
}, size = "large") => {
  if (window._vue_richtext_custom_picker_elements[id]) {
    console.error("Custom reference picker element for id " + id + " already registered");
    return;
  }
  window._vue_richtext_custom_picker_elements[id] = {
    id,
    callback,
    onDestroy,
    size
  };
};
window._registerCustomPickerElement = registerCustomPickerElement;
var E = Object.defineProperty, M = Object.defineProperties;
var x = Object.getOwnPropertyDescriptors;
var V = Object.getOwnPropertySymbols;
var I = Object.prototype.hasOwnProperty, N = Object.prototype.propertyIsEnumerable;
var C = (e2, t4, s) => t4 in e2 ? E(e2, t4, { enumerable: true, configurable: true, writable: true, value: s }) : e2[t4] = s, f = (e2, t4) => {
  for (var s in t4 || (t4 = {}))
    I.call(t4, s) && C(e2, s, t4[s]);
  if (V)
    for (var s of V(t4))
      N.call(t4, s) && C(e2, s, t4[s]);
  return e2;
}, m = (e2, t4) => M(e2, x(t4));
const U = {
  props: {
    autoscroll: {
      type: Boolean,
      default: true
    }
  },
  watch: {
    typeAheadPointer() {
      this.autoscroll && this.maybeAdjustScroll();
    },
    open(e2) {
      this.autoscroll && e2 && this.$nextTick(() => this.maybeAdjustScroll());
    }
  },
  methods: {
    maybeAdjustScroll() {
      var t4;
      const e2 = ((t4 = this.$refs.dropdownMenu) == null ? void 0 : t4.children[this.typeAheadPointer]) || false;
      if (e2) {
        const s = this.getDropdownViewport(), { top: n, bottom: l, height: i } = e2.getBoundingClientRect();
        if (n < s.top)
          return this.$refs.dropdownMenu.scrollTop = e2.offsetTop;
        if (l > s.bottom)
          return this.$refs.dropdownMenu.scrollTop = e2.offsetTop - (s.height - i);
      }
    },
    getDropdownViewport() {
      return this.$refs.dropdownMenu ? this.$refs.dropdownMenu.getBoundingClientRect() : {
        height: 0,
        top: 0,
        bottom: 0
      };
    }
  }
}, q = {
  data() {
    return {
      typeAheadPointer: -1
    };
  },
  watch: {
    filteredOptions() {
      for (let e2 = 0; e2 < this.filteredOptions.length; e2++)
        if (this.selectable(this.filteredOptions[e2])) {
          this.typeAheadPointer = e2;
          break;
        }
    },
    open(e2) {
      e2 && this.typeAheadToLastSelected();
    },
    selectedValue() {
      this.open && this.typeAheadToLastSelected();
    }
  },
  methods: {
    typeAheadUp() {
      for (let e2 = this.typeAheadPointer - 1; e2 >= 0; e2--)
        if (this.selectable(this.filteredOptions[e2])) {
          this.typeAheadPointer = e2;
          break;
        }
    },
    typeAheadDown() {
      for (let e2 = this.typeAheadPointer + 1; e2 < this.filteredOptions.length; e2++)
        if (this.selectable(this.filteredOptions[e2])) {
          this.typeAheadPointer = e2;
          break;
        }
    },
    typeAheadSelect() {
      const e2 = this.filteredOptions[this.typeAheadPointer];
      e2 && this.selectable(e2) && this.select(e2);
    },
    typeAheadToLastSelected() {
      this.typeAheadPointer = this.selectedValue.length !== 0 ? this.filteredOptions.indexOf(this.selectedValue[this.selectedValue.length - 1]) : -1;
    }
  }
}, J = {
  props: {
    loading: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      mutableLoading: false
    };
  },
  watch: {
    search() {
      this.$emit("search", this.search, this.toggleLoading);
    },
    loading(e2) {
      this.mutableLoading = e2;
    }
  },
  methods: {
    toggleLoading(e2 = null) {
      return e2 == null ? this.mutableLoading = !this.mutableLoading : this.mutableLoading = e2;
    }
  }
}, S = (e2, t4) => {
  const s = e2.__vccOpts || e2;
  for (const [n, l] of t4)
    s[n] = l;
  return s;
}, H = {}, X = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "10",
  height: "10"
}, Y = /* @__PURE__ */ createBaseVNode("path", { d: "M6.895455 5l2.842897-2.842898c.348864-.348863.348864-.914488 0-1.263636L9.106534.261648c-.348864-.348864-.914489-.348864-1.263636 0L5 3.104545 2.157102.261648c-.348863-.348864-.914488-.348864-1.263636 0L.261648.893466c-.348864.348864-.348864.914489 0 1.263636L3.104545 5 .261648 7.842898c-.348864.348863-.348864.914488 0 1.263636l.631818.631818c.348864.348864.914773.348864 1.263636 0L5 6.895455l2.842898 2.842897c.348863.348864.914772.348864 1.263636 0l.631818-.631818c.348864-.348864.348864-.914489 0-1.263636L6.895455 5z" }, null, -1), Q = [
  Y
];
function G(e2, t4) {
  return openBlock(), createElementBlock("svg", X, Q);
}
const W = /* @__PURE__ */ S(H, [["render", G]]), Z = {}, ee = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "14",
  height: "10"
}, te = /* @__PURE__ */ createBaseVNode("path", { d: "M9.211364 7.59931l4.48338-4.867229c.407008-.441854.407008-1.158247 0-1.60046l-.73712-.80023c-.407008-.441854-1.066904-.441854-1.474243 0L7 5.198617 2.51662.33139c-.407008-.441853-1.066904-.441853-1.474243 0l-.737121.80023c-.407008.441854-.407008 1.158248 0 1.600461l4.48338 4.867228L7 10l2.211364-2.40069z" }, null, -1), se = [
  te
];
function ie(e2, t4) {
  return openBlock(), createElementBlock("svg", ee, se);
}
const oe = /* @__PURE__ */ S(Z, [["render", ie]]), T = {
  Deselect: W,
  OpenIndicator: oe
}, ne = {
  mounted(e2, { instance: t4 }) {
    if (t4.appendToBody) {
      const {
        height: s,
        top: n,
        left: l,
        width: i
      } = t4.$refs.toggle.getBoundingClientRect();
      let y = window.scrollX || window.pageXOffset, o = window.scrollY || window.pageYOffset;
      e2.unbindPosition = t4.calculatePosition(e2, t4, {
        width: i + "px",
        left: y + l + "px",
        top: o + n + s + "px"
      }), document.body.appendChild(e2);
    }
  },
  unmounted(e2, { instance: t4 }) {
    t4.appendToBody && (e2.unbindPosition && typeof e2.unbindPosition == "function" && e2.unbindPosition(), e2.parentNode && e2.parentNode.removeChild(e2));
  }
};
function le(e2) {
  const t4 = {};
  return Object.keys(e2).sort().forEach((s) => {
    t4[s] = e2[s];
  }), JSON.stringify(t4);
}
let ae = 0;
function re() {
  return ++ae;
}
const de = {
  components: f({}, T),
  directives: { appendToBody: ne },
  mixins: [U, q, J],
  compatConfig: {
    MODE: 3
  },
  emits: [
    "open",
    "close",
    "update:modelValue",
    "search",
    "search:compositionstart",
    "search:compositionend",
    "search:keydown",
    "search:blur",
    "search:focus",
    "search:input",
    "option:created",
    "option:selecting",
    "option:selected",
    "option:deselecting",
    "option:deselected"
  ],
  props: {
    modelValue: {},
    components: {
      type: Object,
      default: () => ({})
    },
    options: {
      type: Array,
      default() {
        return [];
      }
    },
    disabled: {
      type: Boolean,
      default: false
    },
    clearable: {
      type: Boolean,
      default: true
    },
    deselectFromDropdown: {
      type: Boolean,
      default: false
    },
    searchable: {
      type: Boolean,
      default: true
    },
    multiple: {
      type: Boolean,
      default: false
    },
    placeholder: {
      type: String,
      default: ""
    },
    transition: {
      type: String,
      default: "vs__fade"
    },
    clearSearchOnSelect: {
      type: Boolean,
      default: true
    },
    closeOnSelect: {
      type: Boolean,
      default: true
    },
    label: {
      type: String,
      default: "label"
    },
    autocomplete: {
      type: String,
      default: "off"
    },
    reduce: {
      type: Function,
      default: (e2) => e2
    },
    selectable: {
      type: Function,
      default: (e2) => true
    },
    getOptionLabel: {
      type: Function,
      default(e2) {
        return typeof e2 == "object" ? e2.hasOwnProperty(this.label) ? e2[this.label] : console.warn(`[vue-select warn]: Label key "option.${this.label}" does not exist in options object ${JSON.stringify(e2)}.
https://vue-select.org/api/props.html#getoptionlabel`) : e2;
      }
    },
    getOptionKey: {
      type: Function,
      default(e2) {
        if (typeof e2 != "object")
          return e2;
        try {
          return e2.hasOwnProperty("id") ? e2.id : le(e2);
        } catch (t4) {
          return console.warn(`[vue-select warn]: Could not stringify this option to generate unique key. Please provide'getOptionKey' prop to return a unique key for each option.
https://vue-select.org/api/props.html#getoptionkey`, e2, t4);
        }
      }
    },
    onTab: {
      type: Function,
      default: function() {
        this.selectOnTab && !this.isComposing && this.typeAheadSelect();
      }
    },
    taggable: {
      type: Boolean,
      default: false
    },
    tabindex: {
      type: Number,
      default: null
    },
    pushTags: {
      type: Boolean,
      default: false
    },
    filterable: {
      type: Boolean,
      default: true
    },
    filterBy: {
      type: Function,
      default(e2, t4, s) {
        return (t4 || "").toLocaleLowerCase().indexOf(s.toLocaleLowerCase()) > -1;
      }
    },
    filter: {
      type: Function,
      default(e2, t4) {
        return e2.filter((s) => {
          let n = this.getOptionLabel(s);
          return typeof n == "number" && (n = n.toString()), this.filterBy(s, n, t4);
        });
      }
    },
    createOption: {
      type: Function,
      default(e2) {
        return typeof this.optionList[0] == "object" ? { [this.label]: e2 } : e2;
      }
    },
    resetOnOptionsChange: {
      default: false,
      validator: (e2) => ["function", "boolean"].includes(typeof e2)
    },
    clearSearchOnBlur: {
      type: Function,
      default: function({ clearSearchOnSelect: e2, multiple: t4 }) {
        return e2 && !t4;
      }
    },
    noDrop: {
      type: Boolean,
      default: false
    },
    inputId: {
      type: String
    },
    dir: {
      type: String,
      default: "auto"
    },
    selectOnTab: {
      type: Boolean,
      default: false
    },
    selectOnKeyCodes: {
      type: Array,
      default: () => [13]
    },
    searchInputQuerySelector: {
      type: String,
      default: "[type=search]"
    },
    mapKeydown: {
      type: Function,
      default: (e2, t4) => e2
    },
    appendToBody: {
      type: Boolean,
      default: false
    },
    calculatePosition: {
      type: Function,
      default(e2, t4, { width: s, top: n, left: l }) {
        e2.style.top = n, e2.style.left = l, e2.style.width = s;
      }
    },
    dropdownShouldOpen: {
      type: Function,
      default({ noDrop: e2, open: t4, mutableLoading: s }) {
        return e2 ? false : t4 && !s;
      }
    },
    uid: {
      type: [String, Number],
      default: () => re()
    }
  },
  data() {
    return {
      search: "",
      open: false,
      isComposing: false,
      pushedTags: [],
      _value: [],
      deselectButtons: []
    };
  },
  computed: {
    isReducingValues() {
      return this.$props.reduce !== this.$options.props.reduce.default;
    },
    isTrackingValues() {
      return typeof this.modelValue == "undefined" || this.isReducingValues;
    },
    selectedValue() {
      let e2 = this.modelValue;
      return this.isTrackingValues && (e2 = this.$data._value), e2 != null && e2 !== "" ? [].concat(e2) : [];
    },
    optionList() {
      return this.options.concat(this.pushTags ? this.pushedTags : []);
    },
    searchEl() {
      return this.$slots.search ? this.$refs.selectedOptions.querySelector(this.searchInputQuerySelector) : this.$refs.search;
    },
    scope() {
      const e2 = {
        search: this.search,
        loading: this.loading,
        searching: this.searching,
        filteredOptions: this.filteredOptions
      };
      return {
        search: {
          attributes: f({
            disabled: this.disabled,
            placeholder: this.searchPlaceholder,
            tabindex: this.tabindex,
            readonly: !this.searchable,
            id: this.inputId,
            "aria-autocomplete": "list",
            "aria-labelledby": `vs${this.uid}__combobox`,
            "aria-controls": `vs${this.uid}__listbox`,
            ref: "search",
            type: "search",
            autocomplete: this.autocomplete,
            value: this.search
          }, this.dropdownOpen && this.filteredOptions[this.typeAheadPointer] ? {
            "aria-activedescendant": `vs${this.uid}__option-${this.typeAheadPointer}`
          } : {}),
          events: {
            compositionstart: () => this.isComposing = true,
            compositionend: () => this.isComposing = false,
            keydown: this.onSearchKeyDown,
            blur: this.onSearchBlur,
            focus: this.onSearchFocus,
            input: (t4) => this.search = t4.target.value
          }
        },
        spinner: {
          loading: this.mutableLoading
        },
        noOptions: {
          search: this.search,
          loading: this.mutableLoading,
          searching: this.searching
        },
        openIndicator: {
          attributes: {
            ref: "openIndicator",
            role: "presentation",
            class: "vs__open-indicator"
          }
        },
        listHeader: e2,
        listFooter: e2,
        header: m(f({}, e2), { deselect: this.deselect }),
        footer: m(f({}, e2), { deselect: this.deselect })
      };
    },
    childComponents() {
      return f(f({}, T), this.components);
    },
    stateClasses() {
      return {
        "vs--open": this.dropdownOpen,
        "vs--single": !this.multiple,
        "vs--multiple": this.multiple,
        "vs--searching": this.searching && !this.noDrop,
        "vs--searchable": this.searchable && !this.noDrop,
        "vs--unsearchable": !this.searchable,
        "vs--loading": this.mutableLoading,
        "vs--disabled": this.disabled
      };
    },
    searching() {
      return !!this.search;
    },
    dropdownOpen() {
      return this.dropdownShouldOpen(this);
    },
    searchPlaceholder() {
      return this.isValueEmpty && this.placeholder ? this.placeholder : void 0;
    },
    filteredOptions() {
      const e2 = [].concat(this.optionList);
      if (!this.filterable && !this.taggable)
        return e2;
      const t4 = this.search.length ? this.filter(e2, this.search, this) : e2;
      if (this.taggable && this.search.length) {
        const s = this.createOption(this.search);
        this.optionExists(s) || t4.unshift(s);
      }
      return t4;
    },
    isValueEmpty() {
      return this.selectedValue.length === 0;
    },
    showClearButton() {
      return !this.multiple && this.clearable && !this.open && !this.isValueEmpty;
    }
  },
  watch: {
    options(e2, t4) {
      const s = () => typeof this.resetOnOptionsChange == "function" ? this.resetOnOptionsChange(e2, t4, this.selectedValue) : this.resetOnOptionsChange;
      !this.taggable && s() && this.clearSelection(), this.modelValue && this.isTrackingValues && this.setInternalValueFromOptions(this.modelValue);
    },
    modelValue: {
      immediate: true,
      handler(e2) {
        this.isTrackingValues && this.setInternalValueFromOptions(e2);
      }
    },
    multiple() {
      this.clearSelection();
    },
    open(e2) {
      this.$emit(e2 ? "open" : "close");
    }
  },
  created() {
    this.mutableLoading = this.loading;
  },
  methods: {
    setInternalValueFromOptions(e2) {
      Array.isArray(e2) ? this.$data._value = e2.map((t4) => this.findOptionFromReducedValue(t4)) : this.$data._value = this.findOptionFromReducedValue(e2);
    },
    select(e2) {
      this.$emit("option:selecting", e2), this.isOptionSelected(e2) ? this.deselectFromDropdown && (this.clearable || this.multiple && this.selectedValue.length > 1) && this.deselect(e2) : (this.taggable && !this.optionExists(e2) && (this.$emit("option:created", e2), this.pushTag(e2)), this.multiple && (e2 = this.selectedValue.concat(e2)), this.updateValue(e2), this.$emit("option:selected", e2)), this.onAfterSelect(e2);
    },
    deselect(e2) {
      this.$emit("option:deselecting", e2), this.updateValue(this.selectedValue.filter((t4) => !this.optionComparator(t4, e2))), this.$emit("option:deselected", e2);
    },
    clearSelection() {
      this.updateValue(this.multiple ? [] : null);
    },
    onAfterSelect(e2) {
      this.closeOnSelect && (this.open = !this.open, this.searchEl.blur()), this.clearSearchOnSelect && (this.search = "");
    },
    updateValue(e2) {
      typeof this.modelValue == "undefined" && (this.$data._value = e2), e2 !== null && (Array.isArray(e2) ? e2 = e2.map((t4) => this.reduce(t4)) : e2 = this.reduce(e2)), this.$emit("update:modelValue", e2);
    },
    toggleDropdown(e2) {
      const t4 = e2.target !== this.searchEl;
      t4 && e2.preventDefault();
      const s = [
        ...this.deselectButtons || [],
        this.$refs.clearButton
      ];
      if (this.searchEl === void 0 || s.filter(Boolean).some((n) => n.contains(e2.target) || n === e2.target)) {
        e2.preventDefault();
        return;
      }
      this.open && t4 ? this.searchEl.blur() : this.disabled || (this.open = true, this.searchEl.focus());
    },
    isOptionSelected(e2) {
      return this.selectedValue.some((t4) => this.optionComparator(t4, e2));
    },
    isOptionDeselectable(e2) {
      return this.isOptionSelected(e2) && this.deselectFromDropdown;
    },
    optionComparator(e2, t4) {
      return this.getOptionKey(e2) === this.getOptionKey(t4);
    },
    findOptionFromReducedValue(e2) {
      const t4 = (n) => JSON.stringify(this.reduce(n)) === JSON.stringify(e2), s = [...this.options, ...this.pushedTags].filter(t4);
      return s.length === 1 ? s[0] : s.find((n) => this.optionComparator(n, this.$data._value)) || e2;
    },
    closeSearchOptions() {
      this.open = false, this.$emit("search:blur");
    },
    maybeDeleteValue() {
      if (!this.searchEl.value.length && this.selectedValue && this.selectedValue.length && this.clearable) {
        let e2 = null;
        this.multiple && (e2 = [
          ...this.selectedValue.slice(0, this.selectedValue.length - 1)
        ]), this.updateValue(e2);
      }
    },
    optionExists(e2) {
      return this.optionList.some((t4) => this.optionComparator(t4, e2));
    },
    normalizeOptionForSlot(e2) {
      return typeof e2 == "object" ? e2 : { [this.label]: e2 };
    },
    pushTag(e2) {
      this.pushedTags.push(e2);
    },
    onEscape() {
      this.search.length ? this.search = "" : this.searchEl.blur();
    },
    onSearchBlur() {
      if (this.mousedown && !this.searching)
        this.mousedown = false;
      else {
        const { clearSearchOnSelect: e2, multiple: t4 } = this;
        this.clearSearchOnBlur({ clearSearchOnSelect: e2, multiple: t4 }) && (this.search = ""), this.closeSearchOptions();
        return;
      }
      if (this.search.length === 0 && this.options.length === 0) {
        this.closeSearchOptions();
        return;
      }
    },
    onSearchFocus() {
      this.open = true, this.$emit("search:focus");
    },
    onMousedown() {
      this.mousedown = true;
    },
    onMouseUp() {
      this.mousedown = false;
    },
    onSearchKeyDown(e2) {
      const t4 = (l) => (l.preventDefault(), !this.isComposing && this.typeAheadSelect()), s = {
        8: (l) => this.maybeDeleteValue(),
        9: (l) => this.onTab(),
        27: (l) => this.onEscape(),
        38: (l) => (l.preventDefault(), this.typeAheadUp()),
        40: (l) => (l.preventDefault(), this.typeAheadDown())
      };
      this.selectOnKeyCodes.forEach((l) => s[l] = t4);
      const n = this.mapKeydown(s, this);
      if (typeof n[e2.keyCode] == "function")
        return n[e2.keyCode](e2);
    }
  }
}, he = ["dir"], ce = ["id", "aria-expanded", "aria-owns"], ue = {
  ref: "selectedOptions",
  class: "vs__selected-options"
}, pe = ["disabled", "title", "aria-label", "onClick"], fe = {
  ref: "actions",
  class: "vs__actions"
}, ge = ["disabled"], ye = { class: "vs__spinner" }, me = ["id"], be = ["id", "aria-selected", "onMouseover", "onClick"], _e = {
  key: 0,
  class: "vs__no-options"
}, Oe = /* @__PURE__ */ createTextVNode(" Sorry, no matching options. "), we = ["id"];
function ve(e2, t4, s, n, l, i) {
  const y = resolveDirective("append-to-body");
  return openBlock(), createElementBlock("div", {
    dir: s.dir,
    class: normalizeClass(["v-select", i.stateClasses])
  }, [
    renderSlot(e2.$slots, "header", normalizeProps(guardReactiveProps(i.scope.header))),
    createBaseVNode("div", {
      id: `vs${s.uid}__combobox`,
      ref: "toggle",
      class: "vs__dropdown-toggle",
      role: "combobox",
      "aria-expanded": i.dropdownOpen.toString(),
      "aria-owns": `vs${s.uid}__listbox`,
      "aria-label": "Search for option",
      onMousedown: t4[1] || (t4[1] = (o) => i.toggleDropdown(o))
    }, [
      createBaseVNode("div", ue, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(i.selectedValue, (o, p) => renderSlot(e2.$slots, "selected-option-container", {
          option: i.normalizeOptionForSlot(o),
          deselect: i.deselect,
          multiple: s.multiple,
          disabled: s.disabled
        }, () => [
          (openBlock(), createElementBlock("span", {
            key: s.getOptionKey(o),
            class: "vs__selected"
          }, [
            renderSlot(e2.$slots, "selected-option", normalizeProps(guardReactiveProps(i.normalizeOptionForSlot(o))), () => [
              createTextVNode(toDisplayString(s.getOptionLabel(o)), 1)
            ]),
            s.multiple ? (openBlock(), createElementBlock("button", {
              key: 0,
              ref_for: true,
              ref: (g) => l.deselectButtons[p] = g,
              disabled: s.disabled,
              type: "button",
              class: "vs__deselect",
              title: `Deselect ${s.getOptionLabel(o)}`,
              "aria-label": `Deselect ${s.getOptionLabel(o)}`,
              onClick: (g) => i.deselect(o)
            }, [
              (openBlock(), createBlock(resolveDynamicComponent(i.childComponents.Deselect)))
            ], 8, pe)) : createCommentVNode("", true)
          ]))
        ])), 256)),
        renderSlot(e2.$slots, "search", normalizeProps(guardReactiveProps(i.scope.search)), () => [
          createBaseVNode("input", mergeProps({ class: "vs__search" }, i.scope.search.attributes, toHandlers(i.scope.search.events)), null, 16)
        ])
      ], 512),
      createBaseVNode("div", fe, [
        withDirectives(createBaseVNode("button", {
          ref: "clearButton",
          disabled: s.disabled,
          type: "button",
          class: "vs__clear",
          title: "Clear Selected",
          "aria-label": "Clear Selected",
          onClick: t4[0] || (t4[0] = (...o) => i.clearSelection && i.clearSelection(...o))
        }, [
          (openBlock(), createBlock(resolveDynamicComponent(i.childComponents.Deselect)))
        ], 8, ge), [
          [vShow, i.showClearButton]
        ]),
        renderSlot(e2.$slots, "open-indicator", normalizeProps(guardReactiveProps(i.scope.openIndicator)), () => [
          s.noDrop ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(i.childComponents.OpenIndicator), normalizeProps(mergeProps({ key: 0 }, i.scope.openIndicator.attributes)), null, 16))
        ]),
        renderSlot(e2.$slots, "spinner", normalizeProps(guardReactiveProps(i.scope.spinner)), () => [
          withDirectives(createBaseVNode("div", ye, "Loading...", 512), [
            [vShow, e2.mutableLoading]
          ])
        ])
      ], 512)
    ], 40, ce),
    createVNode(Transition, { name: s.transition }, {
      default: withCtx(() => [
        i.dropdownOpen ? withDirectives((openBlock(), createElementBlock("ul", {
          id: `vs${s.uid}__listbox`,
          ref: "dropdownMenu",
          key: `vs${s.uid}__listbox`,
          class: "vs__dropdown-menu",
          role: "listbox",
          tabindex: "-1",
          onMousedown: t4[2] || (t4[2] = withModifiers((...o) => i.onMousedown && i.onMousedown(...o), ["prevent"])),
          onMouseup: t4[3] || (t4[3] = (...o) => i.onMouseUp && i.onMouseUp(...o))
        }, [
          renderSlot(e2.$slots, "list-header", normalizeProps(guardReactiveProps(i.scope.listHeader))),
          (openBlock(true), createElementBlock(Fragment, null, renderList(i.filteredOptions, (o, p) => (openBlock(), createElementBlock("li", {
            id: `vs${s.uid}__option-${p}`,
            key: s.getOptionKey(o),
            role: "option",
            class: normalizeClass(["vs__dropdown-option", {
              "vs__dropdown-option--deselect": i.isOptionDeselectable(o) && p === e2.typeAheadPointer,
              "vs__dropdown-option--selected": i.isOptionSelected(o),
              "vs__dropdown-option--highlight": p === e2.typeAheadPointer,
              "vs__dropdown-option--disabled": !s.selectable(o)
            }]),
            "aria-selected": p === e2.typeAheadPointer ? true : null,
            onMouseover: (g) => s.selectable(o) ? e2.typeAheadPointer = p : null,
            onClick: withModifiers((g) => s.selectable(o) ? i.select(o) : null, ["prevent", "stop"])
          }, [
            renderSlot(e2.$slots, "option", normalizeProps(guardReactiveProps(i.normalizeOptionForSlot(o))), () => [
              createTextVNode(toDisplayString(s.getOptionLabel(o)), 1)
            ])
          ], 42, be))), 128)),
          i.filteredOptions.length === 0 ? (openBlock(), createElementBlock("li", _e, [
            renderSlot(e2.$slots, "no-options", normalizeProps(guardReactiveProps(i.scope.noOptions)), () => [
              Oe
            ])
          ])) : createCommentVNode("", true),
          renderSlot(e2.$slots, "list-footer", normalizeProps(guardReactiveProps(i.scope.listFooter)))
        ], 40, me)), [
          [y]
        ]) : (openBlock(), createElementBlock("ul", {
          key: 1,
          id: `vs${s.uid}__listbox`,
          role: "listbox",
          style: { display: "none", visibility: "hidden" }
        }, null, 8, we))
      ]),
      _: 3
    }, 8, ["name"]),
    renderSlot(e2.$slots, "footer", normalizeProps(guardReactiveProps(i.scope.footer)))
  ], 10, he);
}
const Ce = /* @__PURE__ */ S(de, [["render", ve]]);
register(t16);
({
  props: {
    // Add VueSelect props to $props
    ...Ce.props,
    ...Ce.mixins.reduce((allProps, mixin) => ({ ...allProps, ...mixin.props }), {}),
    /**
     * `aria-label` for the clear input button
     */
    ariaLabelClearSelected: {
      default: t("Clear selected")
    },
    /**
     * `aria-label` for the listbox element
     */
    ariaLabelListbox: {
      default: t("Options")
    }
  }
});
const _sfc_main$h = {
  name: "AlertCircleOutlineIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$b = ["aria-hidden", "aria-label"];
const _hoisted_2$7 = ["fill", "width", "height"];
const _hoisted_3$6 = { d: "M11,15H13V17H11V15M11,7H13V13H11V7M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20Z" };
const _hoisted_4$5 = { key: 0 };
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon alert-circle-outline-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$6, [
        $props.title ? (openBlock(), createElementBlock("title", _hoisted_4$5, toDisplayString($props.title), 1)) : createCommentVNode("", true)
      ])
    ], 8, _hoisted_2$7))
  ], 16, _hoisted_1$b);
}
const AlertCircle = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h]]);
const _sfc_main$g = {
  name: "CheckIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$a = ["aria-hidden", "aria-label"];
const _hoisted_2$6 = ["fill", "width", "height"];
const _hoisted_3$5 = { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" };
const _hoisted_4$4 = { key: 0 };
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon check-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$5, [
        $props.title ? (openBlock(), createElementBlock("title", _hoisted_4$4, toDisplayString($props.title), 1)) : createCommentVNode("", true)
      ])
    ], 8, _hoisted_2$6))
  ], 16, _hoisted_1$a);
}
const Check = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g]]);
const _sfc_main$f = {
  name: "NcInputField",
  components: {
    NcButton,
    AlertCircle,
    Check
  },
  inheritAttrs: false,
  props: {
    /**
     * The value of the input field
     * If type is 'number' and a number is passed as value than the type of `update:value` will also be 'number'
     */
    modelValue: {
      type: [String, Number],
      required: true
    },
    /**
     * The type of the input element
     */
    type: {
      type: String,
      default: "text",
      validator: (value) => [
        "text",
        "password",
        "email",
        "tel",
        "url",
        "search",
        "number"
      ].includes(value)
    },
    /**
     * The input label, always provide one for accessibility purposes.
     * This will also be used as a placeholder unless the placeholder
     * prop is populated with a different string.
     *
     * Note: If the background color is not `--color-main-background` consider using an external label instead (see `labelOutside`).
     */
    label: {
      type: String,
      default: void 0
    },
    /**
     * Pass in true if you want to use an external label. This is useful
     * if you need a label that looks different from the one provided by
     * this component
     */
    labelOutside: {
      type: Boolean,
      default: false
    },
    /**
     * The placeholder of the input. This defaults as the string that's
     * passed into the label prop. In order to remove the placeholder,
     * pass in an empty string.
     */
    placeholder: {
      type: String,
      default: void 0
    },
    /**
     * Controls whether to display the trailing button.
     */
    showTrailingButton: {
      type: Boolean,
      default: false
    },
    /**
     * Label of the trailing button
     *
     * Required when showTrailingButton is set
     */
    trailingButtonLabel: {
      type: String,
      default: ""
    },
    /**
     * Toggles the success state of the component. Adds a checkmark icon.
     * this cannot be used together with canClear.
     */
    success: {
      type: Boolean,
      default: false
    },
    /**
     * Toggles the error state of the component. Adds an error icon.
     * this cannot be used together with canClear.
     */
    error: {
      type: Boolean,
      default: false
    },
    /**
     * Additional helper text message
     *
     * This will be displayed beneath the input field. In case the field is
     * also marked as having an error, the text will be displayed in red.
     */
    helperText: {
      type: String,
      default: ""
    },
    /**
     * Disable the input field
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * Specifies whether the input should have a pill form.
     * By default, input has rounded corners.
     */
    pill: {
      type: Boolean,
      default: false
    },
    /**
     * Class to add to the root component.
     */
    class: {
      type: [Object, String, Array],
      default: ""
    },
    /**
     * Class to add to the input field.
     * Necessary to use NcInputField in the NcActionInput component.
     */
    inputClass: {
      type: [Object, String],
      default: ""
    }
  },
  emits: [
    "update:modelValue",
    "trailing-button-click"
  ],
  computed: {
    computedId() {
      return this.$attrs.id && this.$attrs.id !== "" ? this.$attrs.id : this.inputName;
    },
    inputName() {
      return "input" + createElementId();
    },
    hasTrailingIcon() {
      return this.success;
    },
    hasPlaceholder() {
      return this.placeholder !== "" && this.placeholder !== void 0;
    },
    computedPlaceholder() {
      return this.hasPlaceholder ? this.placeholder : this.label;
    },
    isValidLabel() {
      const isValidLabel = this.label || this.labelOutside;
      if (!isValidLabel) {
        console.warn("You need to add a label to the NcInputField component. Either use the prop label or use an external one, as per the example in the documentation.");
      }
      return isValidLabel;
    },
    ariaDescribedby() {
      const ariaDescribedby = [];
      if (this.helperText.length > 0) {
        ariaDescribedby.push(`${this.inputName}-helper-text`);
      }
      if (this.$attrs["aria-describedby"]) {
        ariaDescribedby.push(this.$attrs["aria-describedby"]);
      }
      return ariaDescribedby.join(" ") || null;
    }
  },
  methods: {
    /**
     * Focus the input element
     *
     * @public
     */
    focus() {
      this.$refs.input.focus();
    },
    /**
     * Select all the text in the input
     *
     * @public
     */
    select() {
      this.$refs.input.select();
    },
    handleInput(event) {
      this.$emit("update:modelValue", this.type === "number" && typeof this.modelValue === "number" ? parseFloat(event.target.value, 10) : event.target.value);
    },
    handleTrailingButtonClick(event) {
      this.$emit("trailing-button-click", event);
    }
  }
};
const _hoisted_1$9 = { class: "input-field__main-wrapper" };
const _hoisted_2$5 = ["id", "type", "disabled", "placeholder", "aria-describedby", "value"];
const _hoisted_3$4 = ["for"];
const _hoisted_4$3 = { class: "input-field__icon input-field__icon--leading" };
const _hoisted_5$1 = {
  key: 2,
  class: "input-field__icon input-field__icon--trailing"
};
const _hoisted_6 = ["id"];
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_NcButton = resolveComponent("NcButton");
  const _component_Check = resolveComponent("Check");
  const _component_AlertCircle = resolveComponent("AlertCircle");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["input-field", [{
      "input-field--disabled": $props.disabled,
      "input-field--label-outside": $props.labelOutside || !$options.isValidLabel,
      "input-field--leading-icon": !!_ctx.$slots.icon,
      "input-field--trailing-icon": $props.showTrailingButton || $options.hasTrailingIcon,
      "input-field--pill": $props.pill
    }, _ctx.$props.class]])
  }, [
    createBaseVNode("div", _hoisted_1$9, [
      createBaseVNode("input", mergeProps(_ctx.$attrs, {
        id: $options.computedId,
        ref: "input",
        class: ["input-field__input", [
          $props.inputClass,
          {
            "input-field__input--success": $props.success,
            "input-field__input--error": $props.error
          }
        ]],
        type: $props.type,
        disabled: $props.disabled,
        placeholder: $options.computedPlaceholder,
        "aria-describedby": $options.ariaDescribedby,
        "aria-live": "polite",
        value: $props.modelValue.toString(),
        onInput: _cache[0] || (_cache[0] = (...args) => $options.handleInput && $options.handleInput(...args))
      }), null, 16, _hoisted_2$5),
      !$props.labelOutside && $options.isValidLabel ? (openBlock(), createElementBlock("label", {
        key: 0,
        class: "input-field__label",
        for: $options.computedId
      }, toDisplayString($props.label), 9, _hoisted_3$4)) : createCommentVNode("", true),
      withDirectives(createBaseVNode("div", _hoisted_4$3, [
        renderSlot(_ctx.$slots, "icon", {}, void 0, true)
      ], 512), [
        [vShow, !!_ctx.$slots.icon]
      ]),
      $props.showTrailingButton ? (openBlock(), createBlock(_component_NcButton, {
        key: 1,
        class: "input-field__trailing-button",
        "aria-label": $props.trailingButtonLabel,
        disabled: $props.disabled,
        variant: "tertiary-no-background",
        onClick: $options.handleTrailingButtonClick
      }, {
        icon: withCtx(() => [
          renderSlot(_ctx.$slots, "trailing-button-icon", {}, void 0, true)
        ]),
        _: 3
      }, 8, ["aria-label", "disabled", "onClick"])) : $props.success || $props.error ? (openBlock(), createElementBlock("div", _hoisted_5$1, [
        $props.success ? (openBlock(), createBlock(_component_Check, {
          key: 0,
          size: 20,
          style: { "color": "var(--color-success-text)" }
        })) : $props.error ? (openBlock(), createBlock(_component_AlertCircle, {
          key: 1,
          size: 20,
          style: { "color": "var(--color-error-text)" }
        })) : createCommentVNode("", true)
      ])) : createCommentVNode("", true)
    ]),
    $props.helperText.length > 0 ? (openBlock(), createElementBlock("p", {
      key: 0,
      id: `${$options.inputName}-helper-text`,
      class: normalizeClass(["input-field__helper-text-message", {
        "input-field__helper-text-message--error": $props.error,
        "input-field__helper-text-message--success": $props.success
      }])
    }, [
      $props.success ? (openBlock(), createBlock(_component_Check, {
        key: 0,
        class: "input-field__helper-text-message__icon",
        size: 18
      })) : $props.error ? (openBlock(), createBlock(_component_AlertCircle, {
        key: 1,
        class: "input-field__helper-text-message__icon",
        size: 18
      })) : createCommentVNode("", true),
      createTextVNode(" " + toDisplayString($props.helperText), 1)
    ], 10, _hoisted_6)) : createCommentVNode("", true)
  ], 2);
}
const NcInputField = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f], ["__scopeId", "data-v-c64ebaf9"]]);
register(t17, t46);
new Set(Object.keys(NcInputField.props));
({
  props: {
    // Reuse all the props from NcInputField for better typing and documentation
    ...NcInputField.props
  }
});
register(t7);
({
  title: t("Any link"),
  icon_url: h$1("core", "filetypes/link.svg")
});
if (!window._vue_richtext_reference_providers) {
  window._vue_richtext_reference_providers = loadState("core", "reference-provider-list", []);
}
if (!window._vue_richtext_reference_provider_timestamps) {
  window._vue_richtext_reference_provider_timestamps = loadState("core", "reference-provider-timestamps", {});
}
register(t37, t41);
register(t22);
const IDLE_TIMEOUT = 3 * 60 * 1e3;
const _sfc_main$5$1 = {
  name: "NcReferenceWidget",
  components: {
    NcButton
  },
  props: {
    reference: {
      type: Object,
      required: true
    },
    interactive: {
      type: Boolean,
      default: true
    },
    interactiveOptIn: {
      type: Boolean,
      default: false
    }
  },
  setup() {
    const isVisible = ref(false);
    const widgetRoot = ref();
    const { width } = useElementSize(widgetRoot);
    useIntersectionObserver(widgetRoot, ([entry]) => {
      nextTick(() => {
        isVisible.value = entry.isIntersecting;
      });
    });
    return {
      width,
      isVisible,
      widgetRoot
    };
  },
  data() {
    return {
      showInteractive: false,
      rendered: false,
      idleTimeout: null
    };
  },
  computed: {
    isInteractive() {
      return !this.interactiveOptIn && this.interactive || this.showInteractive;
    },
    hasFullWidth() {
      return hasFullWidth(this.reference.richObjectType);
    },
    hasCustomWidget() {
      return isWidgetRegistered(this.reference.richObjectType);
    },
    hasInteractiveView() {
      return isWidgetRegistered(this.reference.richObjectType) && hasInteractiveView(this.reference.richObjectType);
    },
    noAccess() {
      return this.reference && !this.reference.accessible;
    },
    descriptionStyle() {
      if (this.numberOfLines === 0) {
        return {
          display: "none"
        };
      }
      const lineClamp = this.numberOfLines;
      return {
        lineClamp,
        webkitLineClamp: lineClamp
      };
    },
    numberOfLines() {
      const lineCountOffsets = [450, 550, 650, Infinity];
      return lineCountOffsets.findIndex((max) => this.width < max);
    },
    compactLink() {
      const link2 = this.reference.openGraphObject.link;
      if (!link2) {
        return "";
      }
      if (link2.startsWith("https://")) {
        return link2.substring(8);
      }
      if (link2.startsWith("http://")) {
        return link2.substring(7);
      }
      return link2;
    },
    route() {
      return getRoute(this.$router, this.reference.openGraphObject.link);
    },
    referenceWidgetLinkComponent() {
      return this.route ? RouterLink : "a";
    },
    referenceWidgetLinkProps() {
      return this.route ? { to: this.route } : { href: this.reference.openGraphObject.link, target: "_blank" };
    }
  },
  watch: {
    isVisible: {
      handler(val) {
        if (!val) {
          this.idleTimeout = setTimeout(() => {
            if (!this.isVisible) {
              this.destroyWidget();
            }
          }, IDLE_TIMEOUT);
          return;
        }
        if (this.idleTimeout) {
          clearTimeout(this.idleTimeout);
          this.idleTimeout = null;
        }
        if (!this.rendered) {
          this.renderWidget();
        }
      },
      immediate: true
    }
  },
  beforeUnmount() {
    this.destroyWidget();
  },
  methods: {
    t,
    enableInteractive() {
      this.showInteractive = true;
      this.renderWidget();
    },
    renderWidget() {
      if (!this.$refs.customWidget) {
        return;
      }
      if (this?.reference?.richObjectType === "open-graph") {
        return;
      }
      this.$refs.customWidget.innerHTML = "";
      const widget = document.createElement("div");
      widget.style = "width: 100%;";
      this.$refs.customWidget.appendChild(widget);
      this.$nextTick(() => {
        renderWidget(widget, {
          ...this.reference,
          interactive: this.isInteractive
        });
        this.rendered = true;
      });
    },
    destroyWidget() {
      if (this.rendered) {
        destroyWidget(this.reference.richObjectType, this.$el);
        this.rendered = false;
      }
    }
  }
};
const _hoisted_1$5$1 = ["src"];
const _hoisted_2$4$1 = { class: "widget-default--details" };
const _hoisted_3$3$1 = { class: "widget-default--name" };
const _hoisted_4$2$1 = { class: "widget-default--link" };
function _sfc_render$5$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_NcButton = resolveComponent("NcButton");
  return openBlock(), createElementBlock("div", {
    ref: "widgetRoot",
    class: normalizeClass({ "toggle-interactive": $options.hasInteractiveView && !$options.isInteractive })
  }, [
    $props.reference && $options.hasCustomWidget ? (openBlock(), createElementBlock("div", {
      key: 0,
      ref: "customWidget",
      class: normalizeClass(["widget-custom", { "full-width": $options.hasFullWidth }])
    }, null, 2)) : !$options.noAccess && $props.reference && $props.reference.openGraphObject && !$options.hasCustomWidget ? (openBlock(), createBlock(resolveDynamicComponent($options.referenceWidgetLinkComponent), mergeProps({ key: 1 }, $options.referenceWidgetLinkProps, {
      rel: "noopener noreferrer",
      class: "widget-default"
    }), {
      default: withCtx(() => [
        $props.reference.openGraphObject.thumb ? (openBlock(), createElementBlock("img", {
          key: 0,
          class: "widget-default--image",
          src: $props.reference.openGraphObject.thumb
        }, null, 8, _hoisted_1$5$1)) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_2$4$1, [
          createBaseVNode("p", _hoisted_3$3$1, toDisplayString($props.reference.openGraphObject.name), 1),
          createBaseVNode("p", {
            class: "widget-default--description",
            style: normalizeStyle($options.descriptionStyle)
          }, toDisplayString($props.reference.openGraphObject.description), 5),
          createBaseVNode("p", _hoisted_4$2$1, toDisplayString($options.compactLink), 1)
        ])
      ]),
      _: 1
    }, 16)) : createCommentVNode("", true),
    $props.interactiveOptIn && $options.hasInteractiveView && !$options.isInteractive ? (openBlock(), createBlock(_component_NcButton, {
      key: 2,
      class: "toggle-interactive--button",
      onClick: $options.enableInteractive
    }, {
      default: withCtx(() => [
        createTextVNode(toDisplayString($options.t("Enable interactive view")), 1)
      ]),
      _: 1
    }, 8, ["onClick"])) : createCommentVNode("", true)
  ], 2);
}
const NcReferenceWidget = /* @__PURE__ */ _export_sfc(_sfc_main$5$1, [["render", _sfc_render$5$1], ["__scopeId", "data-v-236df0ce"]]);
register(t23);
register(t30, t37, t39);
register(t11, t18);
function ccount(value, character) {
  const source = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index2 = source.indexOf(character);
  while (index2 !== -1) {
    count++;
    index2 = source.indexOf(character, index2 + character.length);
  }
  return count;
}
function ok$1() {
}
const asciiAlpha = regexCheck(/[A-Za-z]/);
const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
function asciiControl(code2) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code2 !== null && (code2 < 32 || code2 === 127)
  );
}
function markdownLineEnding(code2) {
  return code2 !== null && code2 < -2;
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < 0 || code2 === 32);
}
function markdownSpace(code2) {
  return code2 === -2 || code2 === -1 || code2 === 32;
}
const unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u"));
const unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check;
  function check(code2) {
    return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
  }
}
function escapeStringRegexp(string2) {
  if (typeof string2 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
const convert = (
  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok;
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index22 = -1;
    while (++index22 < checks2.length) {
      if (checks2[index22].apply(this, parameters)) return true;
    }
    return false;
  }
}
function propsFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all2);
  function all2(node2) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node2
    );
    let key;
    for (key in check) {
      if (nodeAsRecord[key] !== checkAsRecord[key]) return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function ok() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}
function color(d) {
  return d;
}
const empty = [];
const CONTINUE = true;
const EXIT = false;
const SKIP = "skip";
function visitParents(tree, test, visitor, reverse) {
  let check;
  {
    check = test;
  }
  const is = convert(check);
  const step = 1;
  factory(tree, void 0, [])();
  function factory(node2, index2, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node2 && typeof node2 === "object" ? node2 : {}
    );
    if (typeof value.type === "string") {
      const name2 = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit2, "name", {
        value: "node (" + color(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = empty;
      let subresult;
      let offset;
      let grandparents;
      if (is(node2, index2, parents[parents.length - 1] || void 0)) {
        result = toResult(visitor(node2, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node2
        );
        if (nodeAsParent.children && result[0] !== SKIP) {
          offset = -1 + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset];
            subresult = factory(child, offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return value === null || value === void 0 ? empty : [value];
}
function findAndReplace(tree, list2, options) {
  const settings = options || {};
  const ignored = convert(settings.ignore || []);
  const pairs = toPairs(list2);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents(tree, "text", visitor);
  }
  function visitor(node2, parents) {
    let index2 = -1;
    let grandparent;
    while (++index2 < parents.length) {
      const parent = parents[index2];
      const siblings = grandparent ? grandparent.children : void 0;
      if (ignored(
        parent,
        siblings ? siblings.indexOf(parent) : void 0,
        grandparent
      )) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node2, parents);
    }
  }
  function handler(node2, parents) {
    const parent = parents[parents.length - 1];
    const find2 = pairs[pairIndex][0];
    const replace2 = pairs[pairIndex][1];
    let start = 0;
    const siblings = parent.children;
    const index2 = siblings.indexOf(node2);
    let change = false;
    let nodes = [];
    find2.lastIndex = 0;
    let match = find2.exec(node2.value);
    while (match) {
      const position2 = match.index;
      const matchObject = {
        index: match.index,
        input: match.input,
        stack: [...parents, node2]
      };
      let value = replace2(...match, matchObject);
      if (typeof value === "string") {
        value = value.length > 0 ? { type: "text", value } : void 0;
      }
      if (value === false) {
        find2.lastIndex = position2 + 1;
      } else {
        if (start !== position2) {
          nodes.push({
            type: "text",
            value: node2.value.slice(start, position2)
          });
        }
        if (Array.isArray(value)) {
          nodes.push(...value);
        } else if (value) {
          nodes.push(value);
        }
        start = position2 + match[0].length;
        change = true;
      }
      if (!find2.global) {
        break;
      }
      match = find2.exec(node2.value);
    }
    if (change) {
      if (start < node2.value.length) {
        nodes.push({ type: "text", value: node2.value.slice(start) });
      }
      parent.children.splice(index2, 1, ...nodes);
    } else {
      nodes = [node2];
    }
    return index2 + nodes.length;
  }
}
function toPairs(tupleOrList) {
  const result = [];
  if (!Array.isArray(tupleOrList)) {
    throw new TypeError("Expected find and replace tuple or list of tuples");
  }
  const list2 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
  let index2 = -1;
  while (++index2 < list2.length) {
    const tuple = list2[index2];
    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
  }
  return result;
}
function toExpression(find2) {
  return typeof find2 === "string" ? new RegExp(escapeStringRegexp(find2), "g") : find2;
}
function toFunction(replace2) {
  return typeof replace2 === "function" ? replace2 : function() {
    return replace2;
  };
}
const inConstruct = "phrasing";
const notInConstruct = ["autolink", "link", "image", "label"];
function gfmAutolinkLiteralFromMarkdown() {
  return {
    transforms: [transformGfmAutolinkLiterals],
    enter: {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    },
    exit: {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    }
  };
}
function gfmAutolinkLiteralToMarkdown() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct,
        notInConstruct
      }
    ]
  };
}
function enterLiteralAutolink(token) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token);
}
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token);
  const node2 = this.stack[this.stack.length - 1];
  ok$1(node2.type === "link");
  node2.url = "http://" + this.sliceSerialize(token);
}
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token);
}
function exitLiteralAutolink(token) {
  this.exit(token);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(
    tree,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function findUrl(_2, protocol, domain2, path2, match) {
  let prefix = "";
  if (!previous(match)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain2 = protocol + domain2;
    protocol = "";
    prefix = "http://";
  }
  if (!isCorrectDomain(domain2)) {
    return false;
  }
  const parts = splitUrl(domain2 + path2);
  if (!parts[0]) return false;
  const result = {
    type: "link",
    title: null,
    url: prefix + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_2, atext, label, match) {
  if (
    // Not an expected previous character.
    !previous(match, true) || // Label ends in not allowed character.
    /[-\d_]$/.test(label)
  ) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label,
    children: [{ type: "text", value: atext + "@" + label }]
  };
}
function isCorrectDomain(domain2) {
  const parts = domain2.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  if (!trailExec) {
    return [url, void 0];
  }
  url = url.slice(0, trailExec.index);
  let trail2 = trailExec[0];
  let closingParenIndex = trail2.indexOf(")");
  const openingParens = ccount(url, "(");
  let closingParens = ccount(url, ")");
  while (closingParenIndex !== -1 && openingParens > closingParens) {
    url += trail2.slice(0, closingParenIndex + 1);
    trail2 = trail2.slice(closingParenIndex + 1);
    closingParenIndex = trail2.indexOf(")");
    closingParens++;
  }
  return [url, trail2];
}
function previous(match, email) {
  const code2 = match.input.charCodeAt(match.index - 1);
  return (match.index === 0 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && (!email || code2 !== 47);
}
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
footnoteReference.peek = footnoteReferencePeek;
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteDefinition: enterFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteCallString: enterFootnoteCallString
    },
    exit: {
      gfmFootnoteDefinition: exitFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteCallString: exitFootnoteCallString
    }
  };
}
function gfmFootnoteToMarkdown() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition, footnoteReference }
  };
}
function enterFootnoteDefinition(token) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    token
  );
}
function enterFootnoteDefinitionLabelString() {
  this.buffer();
}
function exitFootnoteDefinitionLabelString(token) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok$1(node2.type === "footnoteDefinition");
  node2.label = label;
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
}
function exitFootnoteDefinition(token) {
  this.exit(token);
}
function enterFootnoteCall(token) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
}
function enterFootnoteCallString() {
  this.buffer();
}
function exitFootnoteCallString(token) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok$1(node2.type === "footnoteReference");
  node2.label = label;
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
}
function exitFootnoteCall(token) {
  this.exit(token);
}
function footnoteReference(node2, _2, state, info) {
  const tracker = state.createTracker(info);
  let value = tracker.move("[^");
  const exit2 = state.enter("footnoteReference");
  const subexit = state.enter("reference");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      ...tracker.current(),
      before: value,
      after: "]"
    })
  );
  subexit();
  exit2();
  value += tracker.move("]");
  return value;
}
function footnoteReferencePeek() {
  return "[";
}
function footnoteDefinition(node2, _2, state, info) {
  const tracker = state.createTracker(info);
  let value = tracker.move("[^");
  const exit2 = state.enter("footnoteDefinition");
  const subexit = state.enter("label");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      ...tracker.current(),
      before: value,
      after: "]"
    })
  );
  subexit();
  value += tracker.move(
    "]:" + (node2.children && node2.children.length > 0 ? " " : "")
  );
  tracker.shift(4);
  value += tracker.move(
    state.indentLines(state.containerFlow(node2, tracker.current()), map$2)
  );
  exit2();
  return value;
}
function map$2(line, index2, blank) {
  if (index2 === 0) {
    return line;
  }
  return (blank ? "" : "    ") + line;
}
const constructsWithoutStrikethrough = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: enterStrikethrough },
    exit: { strikethrough: exitStrikethrough }
  };
}
function gfmStrikethroughToMarkdown() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: constructsWithoutStrikethrough
      }
    ],
    handlers: { delete: handleDelete }
  };
}
function enterStrikethrough(token) {
  this.enter({ type: "delete", children: [] }, token);
}
function exitStrikethrough(token) {
  this.exit(token);
}
function handleDelete(node2, _2, state, info) {
  const tracker = state.createTracker(info);
  const exit2 = state.enter("strikethrough");
  let value = tracker.move("~~");
  value += state.containerPhrasing(node2, {
    ...tracker.current(),
    before: value,
    after: "~"
  });
  value += tracker.move("~~");
  exit2();
  return value;
}
function peekDelete() {
  return "~";
}
function markdownTable(table2, options = {}) {
  const align = (options.align || []).concat();
  const stringLength = options.stringLength || defaultStringLength;
  const alignments = [];
  const cellMatrix = [];
  const sizeMatrix = [];
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;
  while (++rowIndex < table2.length) {
    const row2 = [];
    const sizes2 = [];
    let columnIndex2 = -1;
    if (table2[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table2[rowIndex].length;
    }
    while (++columnIndex2 < table2[rowIndex].length) {
      const cell = serialize(table2[rowIndex][columnIndex2]);
      if (options.alignDelimiters !== false) {
        const size = stringLength(cell);
        sizes2[columnIndex2] = size;
        if (longestCellByColumn[columnIndex2] === void 0 || size > longestCellByColumn[columnIndex2]) {
          longestCellByColumn[columnIndex2] = size;
        }
      }
      row2.push(cell);
    }
    cellMatrix[rowIndex] = row2;
    sizeMatrix[rowIndex] = sizes2;
  }
  let columnIndex = -1;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code2 = toAlignment(align);
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = code2;
    }
  }
  columnIndex = -1;
  const row = [];
  const sizes = [];
  while (++columnIndex < mostCellsPerRow) {
    const code2 = alignments[columnIndex];
    let before = "";
    let after = "";
    if (code2 === 99) {
      before = ":";
      after = ":";
    } else if (code2 === 108) {
      before = ":";
    } else if (code2 === 114) {
      after = ":";
    }
    let size = options.alignDelimiters === false ? 1 : Math.max(
      1,
      longestCellByColumn[columnIndex] - before.length - after.length
    );
    const cell = before + "-".repeat(size) + after;
    if (options.alignDelimiters !== false) {
      size = before.length + size + after.length;
      if (size > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size;
      }
      sizes[columnIndex] = size;
    }
    row[columnIndex] = cell;
  }
  cellMatrix.splice(1, 0, row);
  sizeMatrix.splice(1, 0, sizes);
  rowIndex = -1;
  const lines = [];
  while (++rowIndex < cellMatrix.length) {
    const row2 = cellMatrix[rowIndex];
    const sizes2 = sizeMatrix[rowIndex];
    columnIndex = -1;
    const line = [];
    while (++columnIndex < mostCellsPerRow) {
      const cell = row2[columnIndex] || "";
      let before = "";
      let after = "";
      if (options.alignDelimiters !== false) {
        const size = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
        const code2 = alignments[columnIndex];
        if (code2 === 114) {
          before = " ".repeat(size);
        } else if (code2 === 99) {
          if (size % 2) {
            before = " ".repeat(size / 2 + 0.5);
            after = " ".repeat(size / 2 - 0.5);
          } else {
            before = " ".repeat(size / 2);
            after = before;
          }
        } else {
          after = " ".repeat(size);
        }
      }
      if (options.delimiterStart !== false && !columnIndex) {
        line.push("|");
      }
      if (options.padding !== false && // Donâ€™t add the opening space if weâ€™re not aligning and the cell is
      // empty: there will be a closing space.
      !(options.alignDelimiters === false && cell === "") && (options.delimiterStart !== false || columnIndex)) {
        line.push(" ");
      }
      if (options.alignDelimiters !== false) {
        line.push(before);
      }
      line.push(cell);
      if (options.alignDelimiters !== false) {
        line.push(after);
      }
      if (options.padding !== false) {
        line.push(" ");
      }
      if (options.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
        line.push("|");
      }
    }
    lines.push(
      options.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
    );
  }
  return lines.join("\n");
}
function serialize(value) {
  return value === null || value === void 0 ? "" : String(value);
}
function defaultStringLength(value) {
  return value.length;
}
function toAlignment(value) {
  const code2 = typeof value === "string" ? value.codePointAt(0) : 0;
  return code2 === 67 || code2 === 99 ? 99 : code2 === 76 || code2 === 108 ? 108 : code2 === 82 || code2 === 114 ? 114 : 0;
}
function blockquote(node2, _2, state, info) {
  const exit2 = state.enter("blockquote");
  const tracker = state.createTracker(info);
  tracker.move("> ");
  tracker.shift(2);
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map$1
  );
  exit2();
  return value;
}
function map$1(line, _2, blank) {
  return ">" + (blank ? "" : " ") + line;
}
function patternInScope(stack, pattern) {
  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
function listInScope(stack, list2, none) {
  if (typeof list2 === "string") {
    list2 = [list2];
  }
  if (!list2 || list2.length === 0) {
    return none;
  }
  let index2 = -1;
  while (++index2 < list2.length) {
    if (stack.includes(list2[index2])) {
      return true;
    }
  }
  return false;
}
function hardBreak(_2, _1, state, info) {
  let index2 = -1;
  while (++index2 < state.unsafe.length) {
    if (state.unsafe[index2].character === "\n" && patternInScope(state.stack, state.unsafe[index2])) {
      return /[ \t]/.test(info.before) ? "" : " ";
    }
  }
  return "\\\n";
}
function longestStreak(value, substring) {
  const source = String(value);
  let index2 = source.indexOf(substring);
  let expected = index2;
  let count = 0;
  let max = 0;
  if (typeof substring !== "string") {
    throw new TypeError("Expected substring");
  }
  while (index2 !== -1) {
    if (index2 === expected) {
      if (++count > max) {
        max = count;
      }
    } else {
      count = 1;
    }
    expected = index2 + substring.length;
    index2 = source.indexOf(substring, expected);
  }
  return max;
}
function formatCodeAsIndented(node2, state) {
  return Boolean(
    state.options.fences === false && node2.value && // If thereâ€™s no infoâ€¦
    !node2.lang && // And thereâ€™s a non-whitespace characterâ€¦
    /[^ \r\n]/.test(node2.value) && // And the value doesnâ€™t start or end in a blankâ€¦
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
  );
}
function checkFence(state) {
  const marker = state.options.fence || "`";
  if (marker !== "`" && marker !== "~") {
    throw new Error(
      "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
    );
  }
  return marker;
}
function code$1(node2, _2, state, info) {
  const marker = checkFence(state);
  const raw = node2.value || "";
  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
  if (formatCodeAsIndented(node2, state)) {
    const exit3 = state.enter("codeIndented");
    const value2 = state.indentLines(raw, map);
    exit3();
    return value2;
  }
  const tracker = state.createTracker(info);
  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3));
  const exit2 = state.enter("codeFenced");
  let value = tracker.move(sequence);
  if (node2.lang) {
    const subexit = state.enter(`codeFencedLang${suffix}`);
    value += tracker.move(
      state.safe(node2.lang, {
        before: value,
        after: " ",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  if (node2.lang && node2.meta) {
    const subexit = state.enter(`codeFencedMeta${suffix}`);
    value += tracker.move(" ");
    value += tracker.move(
      state.safe(node2.meta, {
        before: value,
        after: "\n",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  value += tracker.move("\n");
  if (raw) {
    value += tracker.move(raw + "\n");
  }
  value += tracker.move(sequence);
  exit2();
  return value;
}
function map(line, _2, blank) {
  return (blank ? "" : "    ") + line;
}
function checkQuote(state) {
  const marker = state.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error(
      "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  return marker;
}
function definition(node2, _2, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit2 = state.enter("definition");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      before: value,
      after: "]",
      ...tracker.current()
    })
  );
  value += tracker.move("]: ");
  subexit();
  if (
    // If thereâ€™s no url, orâ€¦
    !node2.url || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : "\n",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  exit2();
  return value;
}
function checkEmphasis(state) {
  const marker = state.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
    );
  }
  return marker;
}
emphasis.peek = emphasisPeek;
function emphasis(node2, _2, state, info) {
  const marker = checkEmphasis(state);
  const exit2 = state.enter("emphasis");
  const tracker = state.createTracker(info);
  let value = tracker.move(marker);
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: marker,
      ...tracker.current()
    })
  );
  value += tracker.move(marker);
  exit2();
  return value;
}
function emphasisPeek(_2, _1, state) {
  return state.options.emphasis || "*";
}
const emptyOptions$1 = {};
function toString(value, options) {
  const settings = emptyOptions$1;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one(value, includeImageAlt, includeHtml);
}
function one(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values2, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values2.length) {
    result[index2] = one(values2[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}
function formatHeadingAsSetext(node2, state) {
  let literalWithBreak = false;
  visit(node2, function(node3) {
    if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
      literalWithBreak = true;
      return EXIT$1;
    }
  });
  return Boolean(
    (!node2.depth || node2.depth < 3) && toString(node2) && (state.options.setext || literalWithBreak)
  );
}
function heading(node2, _2, state, info) {
  const rank = Math.max(Math.min(6, node2.depth || 1), 1);
  const tracker = state.createTracker(info);
  if (formatHeadingAsSetext(node2, state)) {
    const exit3 = state.enter("headingSetext");
    const subexit2 = state.enter("phrasing");
    const value2 = state.containerPhrasing(node2, {
      ...tracker.current(),
      before: "\n",
      after: "\n"
    });
    subexit2();
    exit3();
    return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
      // The whole sizeâ€¦
      value2.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)â€¦
      (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
    );
  }
  const sequence = "#".repeat(rank);
  const exit2 = state.enter("headingAtx");
  const subexit = state.enter("phrasing");
  tracker.move(sequence + " ");
  let value = state.containerPhrasing(node2, {
    before: "# ",
    after: "\n",
    ...tracker.current()
  });
  if (/^[\t ]/.test(value)) {
    value = "&#x" + value.charCodeAt(0).toString(16).toUpperCase() + ";" + value.slice(1);
  }
  value = value ? sequence + " " + value : sequence;
  if (state.options.closeAtx) {
    value += " " + sequence;
  }
  subexit();
  exit2();
  return value;
}
html.peek = htmlPeek;
function html(node2) {
  return node2.value || "";
}
function htmlPeek() {
  return "<";
}
image.peek = imagePeek;
function image(node2, _2, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit2 = state.enter("image");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  value += tracker.move(
    state.safe(node2.alt, { before: value, after: "]", ...tracker.current() })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If thereâ€™s no url but there is a titleâ€¦
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit2();
  return value;
}
function imagePeek() {
  return "!";
}
imageReference.peek = imageReferencePeek;
function imageReference(node2, _2, state, info) {
  const type = node2.referenceType;
  const exit2 = state.enter("imageReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  const alt = state.safe(node2.alt, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(alt + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit2();
  if (type === "full" || !alt || alt !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}
inlineCode.peek = inlineCodePeek;
function inlineCode(node2, _2, state) {
  let value = node2.value || "";
  let sequence = "`";
  let index2 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
    value = " " + value + " ";
  }
  while (++index2 < state.unsafe.length) {
    const pattern = state.unsafe[index2];
    const expression = state.compilePattern(pattern);
    let match;
    if (!pattern.atBreak) continue;
    while (match = expression.exec(value)) {
      let position2 = match.index;
      if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
        position2--;
      }
      value = value.slice(0, position2) + " " + value.slice(match.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}
function formatLinkAsAutolink(node2, state) {
  const raw = toString(node2);
  return Boolean(
    !state.options.resourceLink && // If thereâ€™s a urlâ€¦
    node2.url && // And thereâ€™s a no titleâ€¦
    !node2.title && // And the content of `node` is a single text nodeâ€¦
    node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the contentâ€¦
    (raw === node2.url || "mailto:" + raw === node2.url) && // And that starts w/ a protocolâ€¦
    /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesnâ€™t contain ASCII control codes (character escapes and
    // references donâ€™t work), space, or angle bracketsâ€¦
    !/[\0- <>\u007F]/.test(node2.url)
  );
}
link.peek = linkPeek;
function link(node2, _2, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const tracker = state.createTracker(info);
  let exit2;
  let subexit;
  if (formatLinkAsAutolink(node2, state)) {
    const stack = state.stack;
    state.stack = [];
    exit2 = state.enter("autolink");
    let value2 = tracker.move("<");
    value2 += tracker.move(
      state.containerPhrasing(node2, {
        before: value2,
        after: ">",
        ...tracker.current()
      })
    );
    value2 += tracker.move(">");
    exit2();
    state.stack = stack;
    return value2;
  }
  exit2 = state.enter("link");
  subexit = state.enter("label");
  let value = tracker.move("[");
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: "](",
      ...tracker.current()
    })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If thereâ€™s no url but there is a titleâ€¦
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit2();
  return value;
}
function linkPeek(node2, _2, state) {
  return formatLinkAsAutolink(node2, state) ? "<" : "[";
}
linkReference.peek = linkReferencePeek;
function linkReference(node2, _2, state, info) {
  const type = node2.referenceType;
  const exit2 = state.enter("linkReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  const text2 = state.containerPhrasing(node2, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(text2 + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit2();
  if (type === "full" || !text2 || text2 !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}
function checkBullet(state) {
  const marker = state.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  }
  return marker;
}
function checkBulletOther(state) {
  const bullet = checkBullet(state);
  const bulletOther = state.options.bulletOther;
  if (!bulletOther) {
    return bullet === "*" ? "-" : "*";
  }
  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
    throw new Error(
      "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  }
  if (bulletOther === bullet) {
    throw new Error(
      "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
    );
  }
  return bulletOther;
}
function checkBulletOrdered(state) {
  const marker = state.options.bulletOrdered || ".";
  if (marker !== "." && marker !== ")") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  }
  return marker;
}
function checkRule(state) {
  const marker = state.options.rule || "*";
  if (marker !== "*" && marker !== "-" && marker !== "_") {
    throw new Error(
      "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  }
  return marker;
}
function list(node2, parent, state, info) {
  const exit2 = state.enter("list");
  const bulletCurrent = state.bulletCurrent;
  let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
  const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
  let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
  if (!node2.ordered) {
    const firstListItem = node2.children ? node2.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (bullet === "*" || bullet === "-") && // Empty first list item:
      firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
      state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
      state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
    ) {
      useDifferentMarker = true;
    }
    if (checkRule(state) === bullet && firstListItem) {
      let index2 = -1;
      while (++index2 < node2.children.length) {
        const item = node2.children[index2];
        if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
          useDifferentMarker = true;
          break;
        }
      }
    }
  }
  if (useDifferentMarker) {
    bullet = bulletOther;
  }
  state.bulletCurrent = bullet;
  const value = state.containerFlow(node2, info);
  state.bulletLastUsed = bullet;
  state.bulletCurrent = bulletCurrent;
  exit2();
  return value;
}
function checkListItemIndent(state) {
  const style = state.options.listItemIndent || "one";
  if (style !== "tab" && style !== "one" && style !== "mixed") {
    throw new Error(
      "Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  }
  return style;
}
function listItem(node2, parent, state, info) {
  const listItemIndent = checkListItemIndent(state);
  let bullet = state.bulletCurrent || checkBullet(state);
  if (parent && parent.type === "list" && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
  }
  let size = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
    size = Math.ceil(size / 4) * 4;
  }
  const tracker = state.createTracker(info);
  tracker.move(bullet + " ".repeat(size - bullet.length));
  tracker.shift(size);
  const exit2 = state.enter("listItem");
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map2
  );
  exit2();
  return value;
  function map2(line, index2, blank) {
    if (index2) {
      return (blank ? "" : " ".repeat(size)) + line;
    }
    return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line;
  }
}
function paragraph(node2, _2, state, info) {
  const exit2 = state.enter("paragraph");
  const subexit = state.enter("phrasing");
  const value = state.containerPhrasing(node2, info);
  subexit();
  exit2();
  return value;
}
const phrasing = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  convert([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function root(node2, _2, state, info) {
  const hasPhrasing = node2.children.some(function(d) {
    return phrasing(d);
  });
  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow;
  return fn.call(state, node2, info);
}
function checkStrong(state) {
  const marker = state.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
    );
  }
  return marker;
}
strong.peek = strongPeek;
function strong(node2, _2, state, info) {
  const marker = checkStrong(state);
  const exit2 = state.enter("strong");
  const tracker = state.createTracker(info);
  let value = tracker.move(marker + marker);
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: marker,
      ...tracker.current()
    })
  );
  value += tracker.move(marker + marker);
  exit2();
  return value;
}
function strongPeek(_2, _1, state) {
  return state.options.strong || "*";
}
function text$1(node2, _2, state, info) {
  return state.safe(node2.value, info);
}
function checkRuleRepetition(state) {
  const repetition = state.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error(
      "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
    );
  }
  return repetition;
}
function thematicBreak(_2, _1, state) {
  const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
  return state.options.ruleSpaces ? value.slice(0, -1) : value;
}
const handle = {
  blockquote,
  break: hardBreak,
  code: code$1,
  definition,
  emphasis,
  hardBreak,
  heading,
  html,
  image,
  imageReference,
  inlineCode,
  link,
  linkReference,
  list,
  listItem,
  paragraph,
  root,
  strong,
  text: text$1,
  thematicBreak
};
function gfmTableFromMarkdown() {
  return {
    enter: {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    },
    exit: {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit,
      tableHeader: exit,
      tableRow: exit
    }
  };
}
function enterTable(token) {
  const align = token._align;
  this.enter(
    {
      type: "table",
      align: align.map(function(d) {
        return d === "none" ? null : d;
      }),
      children: []
    },
    token
  );
  this.data.inTable = true;
}
function exitTable(token) {
  this.exit(token);
  this.data.inTable = void 0;
}
function enterRow(token) {
  this.enter({ type: "tableRow", children: [] }, token);
}
function exit(token) {
  this.exit(token);
}
function enterCell(token) {
  this.enter({ type: "tableCell", children: [] }, token);
}
function exitCodeText(token) {
  let value = this.resume();
  if (this.data.inTable) {
    value = value.replace(/\\([\\|])/g, replace);
  }
  const node2 = this.stack[this.stack.length - 1];
  ok$1(node2.type === "inlineCode");
  node2.value = value;
  this.exit(token);
}
function replace($0, $1) {
  return $1 === "|" ? $1 : $0;
}
function gfmTableToMarkdown(options) {
  const settings = options || {};
  const padding = settings.tableCellPadding;
  const alignDelimiters = settings.tablePipeAlign;
  const stringLength = settings.stringLength;
  const around = padding ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: "\n", inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: true, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: true, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: inlineCodeWithTable,
      table: handleTable,
      tableCell: handleTableCell,
      tableRow: handleTableRow
    }
  };
  function handleTable(node2, _2, state, info) {
    return serializeData(handleTableAsData(node2, state, info), node2.align);
  }
  function handleTableRow(node2, _2, state, info) {
    const row = handleTableRowAsData(node2, state, info);
    const value = serializeData([row]);
    return value.slice(0, value.indexOf("\n"));
  }
  function handleTableCell(node2, _2, state, info) {
    const exit2 = state.enter("tableCell");
    const subexit = state.enter("phrasing");
    const value = state.containerPhrasing(node2, {
      ...info,
      before: around,
      after: around
    });
    subexit();
    exit2();
    return value;
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength
    });
  }
  function handleTableAsData(node2, state, info) {
    const children = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = state.enter("table");
    while (++index2 < children.length) {
      result[index2] = handleTableRowAsData(children[index2], state, info);
    }
    subexit();
    return result;
  }
  function handleTableRowAsData(node2, state, info) {
    const children = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = state.enter("tableRow");
    while (++index2 < children.length) {
      result[index2] = handleTableCell(children[index2], node2, state, info);
    }
    subexit();
    return result;
  }
  function inlineCodeWithTable(node2, parent, state) {
    let value = handle.inlineCode(node2, parent, state);
    if (state.stack.includes("tableCell")) {
      value = value.replace(/\|/g, "\\$&");
    }
    return value;
  }
}
function gfmTaskListItemFromMarkdown() {
  return {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    }
  };
}
function gfmTaskListItemToMarkdown() {
  return {
    unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
    handlers: { listItem: listItemWithTaskListItem }
  };
}
function exitCheck(token) {
  const node2 = this.stack[this.stack.length - 2];
  ok$1(node2.type === "listItem");
  node2.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
  const parent = this.stack[this.stack.length - 2];
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
    const node2 = this.stack[this.stack.length - 1];
    ok$1(node2.type === "paragraph");
    const head = node2.children[0];
    if (head && head.type === "text") {
      const siblings = parent.children;
      let index2 = -1;
      let firstParaghraph;
      while (++index2 < siblings.length) {
        const sibling = siblings[index2];
        if (sibling.type === "paragraph") {
          firstParaghraph = sibling;
          break;
        }
      }
      if (firstParaghraph === node2) {
        head.value = head.value.slice(1);
        if (head.value.length === 0) {
          node2.children.shift();
        } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
          head.position.start.column++;
          head.position.start.offset++;
          node2.position.start = Object.assign({}, head.position.start);
        }
      }
    }
  }
  this.exit(token);
}
function listItemWithTaskListItem(node2, parent, state, info) {
  const head = node2.children[0];
  const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
  const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
  const tracker = state.createTracker(info);
  if (checkable) {
    tracker.move(checkbox);
  }
  let value = handle.listItem(node2, parent, state, {
    ...info,
    ...tracker.current()
  });
  if (checkable) {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
  }
  return value;
  function check($0) {
    return $0 + checkbox;
  }
}
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown(),
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown(),
    gfmTableFromMarkdown(),
    gfmTaskListItemFromMarkdown()
  ];
}
function gfmToMarkdown(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown(),
      gfmFootnoteToMarkdown(),
      gfmStrikethroughToMarkdown(),
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown()
    ]
  };
}
function splice(list2, start, remove, items) {
  const end = list2.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    list2.splice(...parameters);
  } else {
    if (remove) list2.splice(start, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      list2.splice(...parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}
const hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code2;
    if (right) {
      for (code2 in right) {
        if (!hasOwnProperty.call(left, code2)) left[code2] = [];
        const value = right[code2];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code2],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list2) {
  let index2 = -1;
  const before = [];
  while (++index2 < list2.length) {
    (list2[index2].add === "after" ? existing : before).push(list2[index2]);
  }
  splice(existing, 0, 0, before);
}
const wwwPrefix = {
  tokenize: tokenizeWwwPrefix,
  partial: true
};
const domain = {
  tokenize: tokenizeDomain,
  partial: true
};
const path = {
  tokenize: tokenizePath,
  partial: true
};
const trail = {
  tokenize: tokenizeTrail,
  partial: true
};
const emailDomainDotTrail = {
  tokenize: tokenizeEmailDomainDotTrail,
  partial: true
};
const wwwAutolink = {
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
const protocolAutolink = {
  tokenize: tokenizeProtocolAutolink,
  previous: previousProtocol
};
const emailAutolink = {
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};
const text = {};
function gfmAutolinkLiteral() {
  return {
    text
  };
}
let code = 48;
while (code < 123) {
  text[code] = emailAutolink;
  code++;
  if (code === 58) code = 65;
  else if (code === 91) code = 97;
}
text[43] = emailAutolink;
text[45] = emailAutolink;
text[46] = emailAutolink;
text[95] = emailAutolink;
text[72] = [emailAutolink, protocolAutolink];
text[104] = [emailAutolink, protocolAutolink];
text[87] = [emailAutolink, wwwAutolink];
text[119] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok2, nok) {
  const self2 = this;
  let dot;
  let data;
  return start;
  function start(code2) {
    if (!gfmAtext(code2) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code2);
  }
  function atext(code2) {
    if (gfmAtext(code2)) {
      effects.consume(code2);
      return atext;
    }
    if (code2 === 64) {
      effects.consume(code2);
      return emailDomain;
    }
    return nok(code2);
  }
  function emailDomain(code2) {
    if (code2 === 46) {
      return effects.check(
        emailDomainDotTrail,
        emailDomainAfter,
        emailDomainDot
      )(code2);
    }
    if (code2 === 45 || code2 === 95 || asciiAlphanumeric(code2)) {
      data = true;
      effects.consume(code2);
      return emailDomain;
    }
    return emailDomainAfter(code2);
  }
  function emailDomainDot(code2) {
    effects.consume(code2);
    dot = true;
    return emailDomain;
  }
  function emailDomainAfter(code2) {
    if (data && dot && asciiAlpha(self2.previous)) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeWwwAutolink(effects, ok2, nok) {
  const self2 = this;
  return wwwStart;
  function wwwStart(code2) {
    if (code2 !== 87 && code2 !== 119 || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(
      wwwPrefix,
      effects.attempt(domain, effects.attempt(path, wwwAfter), nok),
      nok
    )(code2);
  }
  function wwwAfter(code2) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeProtocolAutolink(effects, ok2, nok) {
  const self2 = this;
  let buffer = "";
  let seen = false;
  return protocolStart;
  function protocolStart(code2) {
    if ((code2 === 72 || code2 === 104) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkHttp");
      buffer += String.fromCodePoint(code2);
      effects.consume(code2);
      return protocolPrefixInside;
    }
    return nok(code2);
  }
  function protocolPrefixInside(code2) {
    if (asciiAlpha(code2) && buffer.length < 5) {
      buffer += String.fromCodePoint(code2);
      effects.consume(code2);
      return protocolPrefixInside;
    }
    if (code2 === 58) {
      const protocol = buffer.toLowerCase();
      if (protocol === "http" || protocol === "https") {
        effects.consume(code2);
        return protocolSlashesInside;
      }
    }
    return nok(code2);
  }
  function protocolSlashesInside(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      if (seen) {
        return afterProtocol;
      }
      seen = true;
      return protocolSlashesInside;
    }
    return nok(code2);
  }
  function afterProtocol(code2) {
    return code2 === null || asciiControl(code2) || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || unicodePunctuation(code2) ? nok(code2) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code2);
  }
  function protocolAfter(code2) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeWwwPrefix(effects, ok2, nok) {
  let size = 0;
  return wwwPrefixInside;
  function wwwPrefixInside(code2) {
    if ((code2 === 87 || code2 === 119) && size < 3) {
      size++;
      effects.consume(code2);
      return wwwPrefixInside;
    }
    if (code2 === 46 && size === 3) {
      effects.consume(code2);
      return wwwPrefixAfter;
    }
    return nok(code2);
  }
  function wwwPrefixAfter(code2) {
    return code2 === null ? nok(code2) : ok2(code2);
  }
}
function tokenizeDomain(effects, ok2, nok) {
  let underscoreInLastSegment;
  let underscoreInLastLastSegment;
  let seen;
  return domainInside;
  function domainInside(code2) {
    if (code2 === 46 || code2 === 95) {
      return effects.check(trail, domainAfter, domainAtPunctuation)(code2);
    }
    if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || code2 !== 45 && unicodePunctuation(code2)) {
      return domainAfter(code2);
    }
    seen = true;
    effects.consume(code2);
    return domainInside;
  }
  function domainAtPunctuation(code2) {
    if (code2 === 95) {
      underscoreInLastSegment = true;
    } else {
      underscoreInLastLastSegment = underscoreInLastSegment;
      underscoreInLastSegment = void 0;
    }
    effects.consume(code2);
    return domainInside;
  }
  function domainAfter(code2) {
    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
      return nok(code2);
    }
    return ok2(code2);
  }
}
function tokenizePath(effects, ok2) {
  let sizeOpen = 0;
  let sizeClose = 0;
  return pathInside;
  function pathInside(code2) {
    if (code2 === 40) {
      sizeOpen++;
      effects.consume(code2);
      return pathInside;
    }
    if (code2 === 41 && sizeClose < sizeOpen) {
      return pathAtPunctuation(code2);
    }
    if (code2 === 33 || code2 === 34 || code2 === 38 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 60 || code2 === 63 || code2 === 93 || code2 === 95 || code2 === 126) {
      return effects.check(trail, ok2, pathAtPunctuation)(code2);
    }
    if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      return ok2(code2);
    }
    effects.consume(code2);
    return pathInside;
  }
  function pathAtPunctuation(code2) {
    if (code2 === 41) {
      sizeClose++;
    }
    effects.consume(code2);
    return pathInside;
  }
}
function tokenizeTrail(effects, ok2, nok) {
  return trail2;
  function trail2(code2) {
    if (code2 === 33 || code2 === 34 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 63 || code2 === 95 || code2 === 126) {
      effects.consume(code2);
      return trail2;
    }
    if (code2 === 38) {
      effects.consume(code2);
      return trailCharRefStart;
    }
    if (code2 === 93) {
      effects.consume(code2);
      return trailBracketAfter;
    }
    if (
      // `<` is an end.
      code2 === 60 || // So is whitespace.
      code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)
    ) {
      return ok2(code2);
    }
    return nok(code2);
  }
  function trailBracketAfter(code2) {
    if (code2 === null || code2 === 40 || code2 === 91 || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      return ok2(code2);
    }
    return trail2(code2);
  }
  function trailCharRefStart(code2) {
    return asciiAlpha(code2) ? trailCharRefInside(code2) : nok(code2);
  }
  function trailCharRefInside(code2) {
    if (code2 === 59) {
      effects.consume(code2);
      return trail2;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return trailCharRefInside;
    }
    return nok(code2);
  }
}
function tokenizeEmailDomainDotTrail(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    return asciiAlphanumeric(code2) ? nok(code2) : ok2(code2);
  }
}
function previousWww(code2) {
  return code2 === null || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 91 || code2 === 93 || code2 === 126 || markdownLineEndingOrSpace(code2);
}
function previousProtocol(code2) {
  return !asciiAlpha(code2);
}
function previousEmail(code2) {
  return !(code2 === 47 || gfmAtext(code2));
}
function gfmAtext(code2) {
  return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
}
function previousUnbalanced(events) {
  let index2 = events.length;
  let result = false;
  while (index2--) {
    const token = events[index2][1];
    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
      result = true;
      break;
    }
    if (token._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events.length > 0 && !result) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}
function classifyCharacter(code2) {
  if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
    return 1;
  }
  if (unicodePunctuation(code2)) {
    return 2;
  }
}
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}
function factorySpace(effects, ok2, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type);
      return prefix(code2);
    }
    return ok2(code2);
  }
  function prefix(code2) {
    if (markdownSpace(code2) && size++ < limit) {
      effects.consume(code2);
      return prefix;
    }
    effects.exit(type);
    return ok2(code2);
  }
}
const blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
function tokenizeBlankLine(effects, ok2, nok) {
  return start;
  function start(code2) {
    return markdownSpace(code2) ? factorySpace(effects, after, "linePrefix")(code2) : after(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}
const indent = {
  tokenize: tokenizeIndent,
  partial: true
};
function gfmFootnote() {
  return {
    document: {
      [91]: {
        tokenize: tokenizeDefinitionStart,
        continuation: {
          tokenize: tokenizeDefinitionContinuation
        },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [91]: {
        tokenize: tokenizeGfmFootnoteCall
      },
      [93]: {
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let labelStart;
  while (index2--) {
    const token = self2.events[index2][1];
    if (token.type === "labelImage") {
      labelStart = token;
      break;
    }
    if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") {
      break;
    }
  }
  return start;
  function start(code2) {
    if (!labelStart || !labelStart._balanced) {
      return nok(code2);
    }
    const id = normalizeIdentifier(
      self2.sliceSerialize({
        start: labelStart.end,
        end: self2.now()
      })
    );
    if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {
      return nok(code2);
    }
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    return ok2(code2);
  }
}
function resolveToPotentialGfmFootnoteCall(events, context) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][1].type === "labelImage" && events[index2][0] === "enter") {
      events[index2][1];
      break;
    }
  }
  events[index2 + 1][1].type = "data";
  events[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const call = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, events[index2 + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const marker = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, events[index2 + 3][1].end),
    end: Object.assign({}, events[index2 + 3][1].end)
  };
  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  const string2 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, string2.start),
    end: Object.assign({}, string2.end)
  };
  const replacement = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    events[index2 + 1],
    events[index2 + 2],
    ["enter", call, context],
    // The `[`
    events[index2 + 3],
    events[index2 + 4],
    // The `^`.
    ["enter", marker, context],
    ["exit", marker, context],
    // Everything in between.
    ["enter", string2, context],
    ["enter", chunk, context],
    ["exit", chunk, context],
    ["exit", string2, context],
    // The ending (`]`, properly parsed and labelled).
    events[events.length - 2],
    events[events.length - 1],
    ["exit", call, context]
  ];
  events.splice(index2, events.length - index2 + 1, ...replacement);
  return events;
}
function tokenizeGfmFootnoteCall(effects, ok2, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let size = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter("gfmFootnoteCall");
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code2) {
    if (code2 !== 94) return nok(code2);
    effects.enter("gfmFootnoteCallMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallMarker");
    effects.enter("gfmFootnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code2) {
    if (
      // Too long.
      size > 999 || // Closing brace with nothing.
      code2 === 93 && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)
    ) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteCallString");
      if (!defined.includes(normalizeIdentifier(self2.sliceSerialize(token)))) {
        return nok(code2);
      }
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteCallLabelMarker");
      effects.exit("gfmFootnoteCall");
      return ok2;
    }
    if (!markdownLineEndingOrSpace(code2)) {
      data = true;
    }
    size++;
    effects.consume(code2);
    return code2 === 92 ? callEscape : callData;
  }
  function callEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return callData;
    }
    return callData(code2);
  }
}
function tokenizeDefinitionStart(effects, ok2, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let identifier;
  let size = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter("gfmFootnoteDefinition")._container = true;
    effects.enter("gfmFootnoteDefinitionLabel");
    effects.enter("gfmFootnoteDefinitionLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteDefinitionLabelMarker");
    return labelAtMarker;
  }
  function labelAtMarker(code2) {
    if (code2 === 94) {
      effects.enter("gfmFootnoteDefinitionMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteDefinitionMarker");
      effects.enter("gfmFootnoteDefinitionLabelString");
      effects.enter("chunkString").contentType = "string";
      return labelInside;
    }
    return nok(code2);
  }
  function labelInside(code2) {
    if (
      // Too long.
      size > 999 || // Closing brace with nothing.
      code2 === 93 && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)
    ) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteDefinitionLabelString");
      identifier = normalizeIdentifier(self2.sliceSerialize(token));
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      effects.exit("gfmFootnoteDefinitionLabel");
      return labelAfter;
    }
    if (!markdownLineEndingOrSpace(code2)) {
      data = true;
    }
    size++;
    effects.consume(code2);
    return code2 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return labelInside;
    }
    return labelInside(code2);
  }
  function labelAfter(code2) {
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      if (!defined.includes(identifier)) {
        defined.push(identifier);
      }
      return factorySpace(
        effects,
        whitespaceAfter,
        "gfmFootnoteDefinitionWhitespace"
      );
    }
    return nok(code2);
  }
  function whitespaceAfter(code2) {
    return ok2(code2);
  }
}
function tokenizeDefinitionContinuation(effects, ok2, nok) {
  return effects.check(blankLine, ok2, effects.attempt(indent, ok2, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "gfmFootnoteDefinitionIndent",
    4 + 1
  );
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok2(code2) : nok(code2);
  }
}
function gfmStrikethrough(options) {
  const options_ = options || {};
  let single = options_.singleTilde;
  const tokenizer = {
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: {
      [126]: tokenizer
    },
    insideSpan: {
      null: [tokenizer]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function resolveAllStrikethrough(events, context) {
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
        let open = index2;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
          events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
            events[index2][1].type = "strikethroughSequence";
            events[open][1].type = "strikethroughSequence";
            const strikethrough2 = {
              type: "strikethrough",
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index2][1].end)
            };
            const text2 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index2][1].start)
            };
            const nextEvents = [
              ["enter", strikethrough2, context],
              ["enter", events[open][1], context],
              ["exit", events[open][1], context],
              ["enter", text2, context]
            ];
            const insideSpan2 = context.parser.constructs.insideSpan.null;
            if (insideSpan2) {
              splice(
                nextEvents,
                nextEvents.length,
                0,
                resolveAll(insideSpan2, events.slice(open + 1, index2), context)
              );
            }
            splice(nextEvents, nextEvents.length, 0, [
              ["exit", text2, context],
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context],
              ["exit", strikethrough2, context]
            ]);
            splice(events, open - 1, index2 - open + 3, nextEvents);
            index2 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "strikethroughSequenceTemporary") {
        events[index2][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok2, nok) {
    const previous2 = this.previous;
    const events = this.events;
    let size = 0;
    return start;
    function start(code2) {
      if (previous2 === 126 && events[events.length - 1][1].type !== "characterEscape") {
        return nok(code2);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code2);
    }
    function more(code2) {
      const before = classifyCharacter(previous2);
      if (code2 === 126) {
        if (size > 1) return nok(code2);
        effects.consume(code2);
        size++;
        return more;
      }
      if (size < 2 && !single) return nok(code2);
      const token = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code2);
      token._open = !after || after === 2 && Boolean(before);
      token._close = !before || before === 2 && Boolean(after);
      return ok2(code2);
    }
  }
}
class EditMap {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(index2, remove, add) {
    addImpl(this, index2, remove, add);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImpl(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(events) {
    this.map.sort(function(a, b) {
      return a[0] - b[0];
    });
    if (this.map.length === 0) {
      return;
    }
    let index2 = this.map.length;
    const vecs = [];
    while (index2 > 0) {
      index2 -= 1;
      vecs.push(
        events.slice(this.map[index2][0] + this.map[index2][1]),
        this.map[index2][2]
      );
      events.length = this.map[index2][0];
    }
    vecs.push([...events]);
    events.length = 0;
    let slice = vecs.pop();
    while (slice) {
      events.push(...slice);
      slice = vecs.pop();
    }
    this.map.length = 0;
  }
}
function addImpl(editMap, at, remove, add) {
  let index2 = 0;
  if (remove === 0 && add.length === 0) {
    return;
  }
  while (index2 < editMap.map.length) {
    if (editMap.map[index2][0] === at) {
      editMap.map[index2][1] += remove;
      editMap.map[index2][2].push(...add);
      return;
    }
    index2 += 1;
  }
  editMap.map.push([at, remove, add]);
}
function gfmTableAlign(events, index2) {
  let inDelimiterRow = false;
  const align = [];
  while (index2 < events.length) {
    const event = events[index2];
    if (inDelimiterRow) {
      if (event[0] === "enter") {
        if (event[1].type === "tableContent") {
          align.push(
            events[index2 + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
          );
        }
      } else if (event[1].type === "tableContent") {
        if (events[index2 - 1][1].type === "tableDelimiterMarker") {
          const alignIndex = align.length - 1;
          align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
        }
      } else if (event[1].type === "tableDelimiterRow") {
        break;
      }
    } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
      inDelimiterRow = true;
    }
    index2 += 1;
  }
  return align;
}
function gfmTable() {
  return {
    flow: {
      null: {
        tokenize: tokenizeTable,
        resolveAll: resolveTable
      }
    }
  };
}
function tokenizeTable(effects, ok2, nok) {
  const self2 = this;
  let size = 0;
  let sizeB = 0;
  let seen;
  return start;
  function start(code2) {
    let index2 = self2.events.length - 1;
    while (index2 > -1) {
      const type = self2.events[index2][1].type;
      if (type === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      type === "linePrefix")
        index2--;
      else break;
    }
    const tail = index2 > -1 ? self2.events[index2][1].type : null;
    const next = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
    if (next === bodyRowStart && self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    return next(code2);
  }
  function headRowBefore(code2) {
    effects.enter("tableHead");
    effects.enter("tableRow");
    return headRowStart(code2);
  }
  function headRowStart(code2) {
    if (code2 === 124) {
      return headRowBreak(code2);
    }
    seen = true;
    sizeB += 1;
    return headRowBreak(code2);
  }
  function headRowBreak(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      if (sizeB > 1) {
        sizeB = 0;
        self2.interrupt = true;
        effects.exit("tableRow");
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return headDelimiterStart;
      }
      return nok(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, headRowBreak, "whitespace")(code2);
    }
    sizeB += 1;
    if (seen) {
      seen = false;
      size += 1;
    }
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      seen = true;
      return headRowBreak;
    }
    effects.enter("data");
    return headRowData(code2);
  }
  function headRowData(code2) {
    if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
      effects.exit("data");
      return headRowBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? headRowEscape : headRowData;
  }
  function headRowEscape(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return headRowData;
    }
    return headRowData(code2);
  }
  function headDelimiterStart(code2) {
    self2.interrupt = false;
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    effects.enter("tableDelimiterRow");
    seen = false;
    if (markdownSpace(code2)) {
      return factorySpace(
        effects,
        headDelimiterBefore,
        "linePrefix",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(code2);
    }
    return headDelimiterBefore(code2);
  }
  function headDelimiterBefore(code2) {
    if (code2 === 45 || code2 === 58) {
      return headDelimiterValueBefore(code2);
    }
    if (code2 === 124) {
      seen = true;
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return headDelimiterCellBefore;
    }
    return headDelimiterNok(code2);
  }
  function headDelimiterCellBefore(code2) {
    if (markdownSpace(code2)) {
      return factorySpace(effects, headDelimiterValueBefore, "whitespace")(code2);
    }
    return headDelimiterValueBefore(code2);
  }
  function headDelimiterValueBefore(code2) {
    if (code2 === 58) {
      sizeB += 1;
      seen = true;
      effects.enter("tableDelimiterMarker");
      effects.consume(code2);
      effects.exit("tableDelimiterMarker");
      return headDelimiterLeftAlignmentAfter;
    }
    if (code2 === 45) {
      sizeB += 1;
      return headDelimiterLeftAlignmentAfter(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      return headDelimiterCellAfter(code2);
    }
    return headDelimiterNok(code2);
  }
  function headDelimiterLeftAlignmentAfter(code2) {
    if (code2 === 45) {
      effects.enter("tableDelimiterFiller");
      return headDelimiterFiller(code2);
    }
    return headDelimiterNok(code2);
  }
  function headDelimiterFiller(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return headDelimiterFiller;
    }
    if (code2 === 58) {
      seen = true;
      effects.exit("tableDelimiterFiller");
      effects.enter("tableDelimiterMarker");
      effects.consume(code2);
      effects.exit("tableDelimiterMarker");
      return headDelimiterRightAlignmentAfter;
    }
    effects.exit("tableDelimiterFiller");
    return headDelimiterRightAlignmentAfter(code2);
  }
  function headDelimiterRightAlignmentAfter(code2) {
    if (markdownSpace(code2)) {
      return factorySpace(effects, headDelimiterCellAfter, "whitespace")(code2);
    }
    return headDelimiterCellAfter(code2);
  }
  function headDelimiterCellAfter(code2) {
    if (code2 === 124) {
      return headDelimiterBefore(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      if (!seen || size !== sizeB) {
        return headDelimiterNok(code2);
      }
      effects.exit("tableDelimiterRow");
      effects.exit("tableHead");
      return ok2(code2);
    }
    return headDelimiterNok(code2);
  }
  function headDelimiterNok(code2) {
    return nok(code2);
  }
  function bodyRowStart(code2) {
    effects.enter("tableRow");
    return bodyRowBreak(code2);
  }
  function bodyRowBreak(code2) {
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return bodyRowBreak;
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("tableRow");
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, bodyRowBreak, "whitespace")(code2);
    }
    effects.enter("data");
    return bodyRowData(code2);
  }
  function bodyRowData(code2) {
    if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
      effects.exit("data");
      return bodyRowBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? bodyRowEscape : bodyRowData;
  }
  function bodyRowEscape(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return bodyRowData;
    }
    return bodyRowData(code2);
  }
}
function resolveTable(events, context) {
  let index2 = -1;
  let inFirstCellAwaitingPipe = true;
  let rowKind = 0;
  let lastCell = [0, 0, 0, 0];
  let cell = [0, 0, 0, 0];
  let afterHeadAwaitingFirstBodyRow = false;
  let lastTableEnd = 0;
  let currentTable;
  let currentBody;
  let currentCell;
  const map2 = new EditMap();
  while (++index2 < events.length) {
    const event = events[index2];
    const token = event[1];
    if (event[0] === "enter") {
      if (token.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = false;
        if (lastTableEnd !== 0) {
          flushTableEnd(map2, context, lastTableEnd, currentTable, currentBody);
          currentBody = void 0;
          lastTableEnd = 0;
        }
        currentTable = {
          type: "table",
          start: Object.assign({}, token.start),
          // Note: correct end is set later.
          end: Object.assign({}, token.end)
        };
        map2.add(index2, 0, [["enter", currentTable, context]]);
      } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
        inFirstCellAwaitingPipe = true;
        currentCell = void 0;
        lastCell = [0, 0, 0, 0];
        cell = [0, index2 + 1, 0, 0];
        if (afterHeadAwaitingFirstBodyRow) {
          afterHeadAwaitingFirstBodyRow = false;
          currentBody = {
            type: "tableBody",
            start: Object.assign({}, token.start),
            // Note: correct end is set later.
            end: Object.assign({}, token.end)
          };
          map2.add(index2, 0, [["enter", currentBody, context]]);
        }
        rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
      } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
        inFirstCellAwaitingPipe = false;
        if (cell[2] === 0) {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(
              map2,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
            lastCell = [0, 0, 0, 0];
          }
          cell[2] = index2;
        }
      } else if (token.type === "tableCellDivider") {
        if (inFirstCellAwaitingPipe) {
          inFirstCellAwaitingPipe = false;
        } else {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(
              map2,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
          }
          lastCell = cell;
          cell = [lastCell[1], index2, 0, 0];
        }
      }
    } else if (token.type === "tableHead") {
      afterHeadAwaitingFirstBodyRow = true;
      lastTableEnd = index2;
    } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
      lastTableEnd = index2;
      if (lastCell[1] !== 0) {
        cell[0] = cell[1];
        currentCell = flushCell(
          map2,
          context,
          lastCell,
          rowKind,
          index2,
          currentCell
        );
      } else if (cell[1] !== 0) {
        currentCell = flushCell(map2, context, cell, rowKind, index2, currentCell);
      }
      rowKind = 0;
    } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
      cell[3] = index2;
    }
  }
  if (lastTableEnd !== 0) {
    flushTableEnd(map2, context, lastTableEnd, currentTable, currentBody);
  }
  map2.consume(context.events);
  index2 = -1;
  while (++index2 < context.events.length) {
    const event = context.events[index2];
    if (event[0] === "enter" && event[1].type === "table") {
      event[1]._align = gfmTableAlign(context.events, index2);
    }
  }
  return events;
}
function flushCell(map2, context, range, rowKind, rowEnd, previousCell) {
  const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
  const valueName = "tableContent";
  if (range[0] !== 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
    map2.add(range[0], 0, [["exit", previousCell, context]]);
  }
  const now = getPoint(context.events, range[1]);
  previousCell = {
    type: groupName,
    start: Object.assign({}, now),
    // Note: correct end is set later.
    end: Object.assign({}, now)
  };
  map2.add(range[1], 0, [["enter", previousCell, context]]);
  if (range[2] !== 0) {
    const relatedStart = getPoint(context.events, range[2]);
    const relatedEnd = getPoint(context.events, range[3]);
    const valueToken = {
      type: valueName,
      start: Object.assign({}, relatedStart),
      end: Object.assign({}, relatedEnd)
    };
    map2.add(range[2], 0, [["enter", valueToken, context]]);
    if (rowKind !== 2) {
      const start = context.events[range[2]];
      const end = context.events[range[3]];
      start[1].end = Object.assign({}, end[1].end);
      start[1].type = "chunkText";
      start[1].contentType = "text";
      if (range[3] > range[2] + 1) {
        const a = range[2] + 1;
        const b = range[3] - range[2] - 1;
        map2.add(a, b, []);
      }
    }
    map2.add(range[3] + 1, 0, [["exit", valueToken, context]]);
  }
  if (rowEnd !== void 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
    map2.add(rowEnd, 0, [["exit", previousCell, context]]);
    previousCell = void 0;
  }
  return previousCell;
}
function flushTableEnd(map2, context, index2, table2, tableBody) {
  const exits = [];
  const related = getPoint(context.events, index2);
  if (tableBody) {
    tableBody.end = Object.assign({}, related);
    exits.push(["exit", tableBody, context]);
  }
  table2.end = Object.assign({}, related);
  exits.push(["exit", table2, context]);
  map2.add(index2 + 1, 0, exits);
}
function getPoint(events, index2) {
  const event = events[index2];
  const side = event[0] === "enter" ? "start" : "end";
  return event[1][side];
}
const tasklistCheck = {
  tokenize: tokenizeTasklistCheck
};
function gfmTaskListItem() {
  return {
    text: {
      [91]: tasklistCheck
    }
  };
}
function tokenizeTasklistCheck(effects, ok2, nok) {
  const self2 = this;
  return open;
  function open(code2) {
    if (
      // Exit if thereâ€™s stuff before.
      self2.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !self2._gfmTasklistFirstContentOfListItem
    ) {
      return nok(code2);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code2);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code2) {
    if (markdownLineEndingOrSpace(code2)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueUnchecked");
      return close;
    }
    if (code2 === 88 || code2 === 120) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueChecked");
      return close;
    }
    return nok(code2);
  }
  function close(code2) {
    if (code2 === 93) {
      effects.enter("taskListCheckMarker");
      effects.consume(code2);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownLineEnding(code2)) {
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return effects.check(
        {
          tokenize: spaceThenNonSpace
        },
        ok2,
        nok
      )(code2);
    }
    return nok(code2);
  }
}
function spaceThenNonSpace(effects, ok2, nok) {
  return factorySpace(effects, after, "whitespace");
  function after(code2) {
    return code2 === null ? nok(code2) : ok2(code2);
  }
}
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral(),
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable(),
    gfmTaskListItem()
  ]);
}
const emptyOptions = {};
function remarkGfm(options) {
  const self2 = (
    /** @type {Processor<Root>} */
    this
  );
  const settings = options || emptyOptions;
  const data = self2.data();
  const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);
  const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);
  const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);
  micromarkExtensions.push(gfm(settings));
  fromMarkdownExtensions.push(gfmFromMarkdown());
  toMarkdownExtensions.push(gfmToMarkdown(settings));
}
const _sfc_main$1$2 = {
  name: "NcReferenceList",
  components: {
    NcReferenceWidget
  },
  props: {
    text: {
      type: String,
      default: ""
    },
    referenceData: {
      type: Array,
      default: null
    },
    limit: {
      type: Number,
      default: 1
    },
    displayFallback: {
      type: Boolean,
      default: false
    },
    interactive: {
      type: Boolean,
      default: true
    },
    interactiveOptIn: {
      type: Boolean,
      default: false
    }
  },
  emits: ["loaded"],
  data() {
    return {
      references: null,
      loading: true
    };
  },
  computed: {
    isVisible() {
      return this.loading || this.displayedReferences.length !== 0;
    },
    values() {
      if (this.referenceData) {
        return this.referenceData;
      }
      if (this.displayFallback && !this.loading && !this.references) {
        return [this.fallbackReference];
      }
      return this.references ? Object.values(this.references) : [];
    },
    firstReference() {
      return this.values[0] ?? null;
    },
    displayedReferences() {
      return this.values.slice(0, this.limit);
    },
    fallbackReference() {
      return {
        accessible: true,
        openGraphObject: {
          id: this.text,
          link: this.text,
          name: this.text
        },
        richObjectType: "open-graph"
      };
    }
  },
  watch: {
    text: "fetch"
  },
  mounted() {
    this.fetch();
  },
  methods: {
    fetch() {
      this.loading = true;
      if (this.referenceData) {
        this.references = null;
        this.loading = false;
        return;
      }
      if (!new RegExp(URL_PATTERN).exec(this.text)) {
        this.references = null;
        this.loading = false;
        return;
      }
      this.resolve().then((response) => {
        this.references = response.data.ocs.data.references;
        this.loading = false;
        this.$emit("loaded");
      }).catch((error) => {
        console.error("Failed to extract references", error);
        this.loading = false;
        this.$emit("loaded");
      });
    },
    resolve() {
      const match = new RegExp(URL_PATTERN).exec(this.text.trim());
      const isPublic = getCurrentUser() === null;
      if (this.limit === 1 && match) {
        return isPublic ? cancelableClient.get(v("references/resolvePublic") + `?reference=${encodeURIComponent(match[0])}&sharingToken=${getSharingToken()}`) : cancelableClient.get(v("references/resolve") + `?reference=${encodeURIComponent(match[0])}`);
      }
      return isPublic ? cancelableClient.post(v("references/extractPublic"), {
        text: this.text,
        resolve: true,
        limit: this.limit,
        sharingToken: getSharingToken()
      }) : cancelableClient.post(v("references/extract"), {
        text: this.text,
        resolve: true,
        limit: this.limit
      });
    }
  }
};
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_NcReferenceWidget = resolveComponent("NcReferenceWidget");
  return $options.isVisible ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass(["widgets--list", { "icon-loading": $data.loading }])
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($options.displayedReferences, (reference) => {
      return openBlock(), createBlock(_component_NcReferenceWidget, {
        key: reference?.openGraphObject?.id,
        reference,
        interactive: $props.interactive,
        "interactive-opt-in": $props.interactiveOptIn
      }, null, 8, ["reference", "interactive", "interactive-opt-in"]);
    }), 128))
  ], 2)) : createCommentVNode("", true);
}
const NcReferenceList = /* @__PURE__ */ _export_sfc(_sfc_main$1$2, [["render", _sfc_render$e], ["__scopeId", "data-v-8e70b916"]]);
const remarkPlaceholder = function() {
  return function(ast) {
    visit(ast, (node2) => node2.type === "text", visitor);
    function visitor(node2, index2, parent) {
      const placeholders = node2.value.split(/(\{[a-z\-_.0-9]+\})/ig).map((entry, index22, list2) => {
        const matches = entry.match(/^\{([a-z\-_.0-9]+)\}$/i);
        if (!matches) {
          return u("text", entry);
        }
        const [, component] = matches;
        return u("element", {
          tagName: `#${component}`,
          children: []
        });
      });
      parent.children.splice(index2, 1, ...placeholders);
    }
  };
};
const prepareTextNode = ({ h: h2, context }, text2) => {
  if (context.autolink) {
    text2 = parseUrl(text2);
  }
  if (Array.isArray(text2)) {
    return text2.map((entry) => {
      if (typeof entry === "string") {
        return entry;
      }
      const { component, props } = entry;
      const componentClass = component.name === "NcLink" ? void 0 : "rich-text--component";
      return h2(component, {
        ...props,
        class: componentClass
      });
    });
  }
  return text2;
};
const remarkUnescape = function() {
  return function(tree) {
    visit(
      tree,
      (node2) => ["text", "code", "inlineCode"].includes(node2.type),
      (node2, index2, parent) => {
        parent.children.splice(index2, 1, {
          ...node2,
          value: node2.value.replace(/&lt;/gmi, "<").replace(/&gt;/gmi, ">")
        });
        return [SKIP$1, index2 + 1];
      }
    );
  };
};
const LINK_PROTOCOLS = ["http", "https", "mailto", "tel"];
const rehypeHighlight = ref(null);
async function importRehypeHighlightLibrary() {
  const module = await __vitePreload(() => import("./index-BCb9v7K0.chunk.mjs"), true ? __vite__mapDeps([0,1,2,3,4,5,6,7,8]) : void 0, import.meta.url);
  rehypeHighlight.value = module.default;
}
const _sfc_main$e = {
  name: "NcRichText",
  components: {
    NcReferenceList
  },
  props: {
    text: {
      type: String,
      default: ""
    },
    arguments: {
      type: Object,
      default: () => {
        return {};
      }
    },
    referenceLimit: {
      type: Number,
      default: 0
    },
    referenceInteractive: {
      type: Boolean,
      default: true
    },
    referenceInteractiveOptIn: {
      type: Boolean,
      default: false
    },
    /** Provide data upfront to avoid extra http request */
    references: {
      type: Array,
      default: null
    },
    /** Provide basic Markdown syntax */
    useMarkdown: {
      type: Boolean,
      default: false
    },
    /** Provide GitHub Flavored Markdown syntax */
    useExtendedMarkdown: {
      type: Boolean,
      default: false
    },
    /** Provide event from rendered markdown inputs */
    interactive: {
      type: Boolean,
      default: false
    },
    autolink: {
      type: Boolean,
      default: true
    }
  },
  emits: ["interact:todo"],
  data() {
    return {
      parentId: createElementId()
    };
  },
  methods: {
    renderPlaintext() {
      const placeholders = this.text.split(/(\{[a-z\-_.0-9]+\})/ig).map((entry) => {
        const matches = entry.match(/^\{([a-z\-_.0-9]+)\}$/i);
        if (!matches) {
          return prepareTextNode({ h, context: this }, entry);
        }
        const argumentId = matches[1];
        const argument = this.arguments[argumentId];
        if (typeof argument === "object") {
          const { component, props } = argument;
          return h(typeof component === "string" ? resolveComponent(component) : component, {
            ...props,
            class: "rich-text--component"
          });
        }
        if (argument) {
          return h("span", { class: "rich-text--fallback" }, argument);
        }
        return entry;
      });
      return h("div", { class: "rich-text--wrapper" }, [
        h("div", {}, placeholders.flat()),
        this.referenceLimit > 0 ? h("div", { class: "rich-text--reference-widget" }, [
          h(NcReferenceList, {
            text: this.text,
            referenceData: this.references,
            interactive: this.referenceInteractive,
            interactiveOptIn: this.referenceInteractiveOptIn
          })
        ]) : null
      ]);
    },
    renderMarkdown() {
      const renderedMarkdown = unified().use(remarkParse).use(remarkAutolink, {
        autolink: this.autolink,
        useMarkdown: this.useMarkdown,
        useExtendedMarkdown: this.useExtendedMarkdown
      }).use(remarkUnescape).use(this.useExtendedMarkdown ? remarkGfm : void 0).use(remarkBreaks).use(remarkUnlinkProtocols, { except: LINK_PROTOCOLS }).use(remarkRehype, {
        handlers: {
          component(toHast2, node2) {
            return toHast2(node2, node2.component, { value: node2.value });
          }
        }
      }).use(this.useExtendedMarkdown ? rehypeHighlight.value : void 0).use(remarkPlaceholder).use(rehypeExternalLinks, {
        target: "_blank",
        rel: ["noopener noreferrer"]
      }).use(rehypeReact, {
        Fragment,
        jsx: this.createElement,
        jsxs: this.createElement,
        elementAttributeNameCase: "html",
        prefix: false
      }).processSync(
        this.text.replace(/<[^>]+>/g, (match) => match.replace(/</g, "&lt;")).replace(/&gt;/gmi, ">")
      ).result;
      return h("div", { class: "rich-text--wrapper rich-text--wrapper-markdown" }, [
        renderedMarkdown,
        this.referenceLimit > 0 ? h("div", { class: "rich-text--reference-widget" }, [
          h(NcReferenceList, {
            text: this.text,
            referenceData: this.references,
            interactive: this.referenceInteractive,
            interactiveOptIn: this.referenceInteractiveOptIn
          })
        ]) : null
      ]);
    },
    createElement(type, props, key) {
      if (key) {
        props.key = key;
      }
      const children = props.children ?? [];
      delete props.children;
      if (!String(type).startsWith("#")) {
        let nestedNode = null;
        if (this.useExtendedMarkdown) {
          if (String(type) === "code" && !rehypeHighlight.value && props?.class?.includes("language")) {
            importRehypeHighlightLibrary();
          }
          if (String(type) === "li" && Array.isArray(children) && children[0].type === "input" && children[0].props.type === "checkbox") {
            const [inputNode, , ...labelParts] = children;
            const nestedNodeIndex = labelParts.findIndex((child) => ["ul", "ol", "li", "blockquote", "pre"].includes(child.type));
            if (nestedNodeIndex !== -1) {
              nestedNode = labelParts[nestedNodeIndex];
              labelParts.splice(nestedNodeIndex);
            }
            const id = this.parentId + "-markdown-input-" + createElementId();
            const propsToForward = { ...inputNode.props };
            delete propsToForward.checked;
            const inputComponent = h(NcCheckboxRadioSwitch, {
              ...propsToForward,
              modelValue: inputNode.props.checked,
              id,
              disabled: !this.interactive,
              "onUpdate:modelValue": () => {
                this.$emit("interact:todo", id);
              }
            }, { default: () => labelParts });
            return h(type, props, [inputComponent, nestedNode]);
          }
        }
        if (String(type) === "a") {
          const route = getRoute(this.$router, props.href);
          if (route) {
            delete props.href;
            delete props.target;
            return h(RouterLink, {
              ...props,
              to: route
            }, { default: () => children });
          }
        }
        return h(type, props, children);
      }
      const placeholder = this.arguments[type.slice(1)];
      if (!placeholder) {
        return h("span", { ...props, class: "rich-text--fallback" }, [`{${type.slice(1)}}`]);
      }
      if (!placeholder.component) {
        return h("span", { ...props }, [placeholder]);
      }
      return h(
        typeof placeholder.component === "string" ? resolveComponent(placeholder.component) : placeholder.component,
        {
          ...props,
          ...placeholder.props,
          class: "rich-text--component"
        },
        { default: () => children }
      );
    }
  },
  render() {
    return this.useMarkdown || this.useExtendedMarkdown ? this.renderMarkdown() : this.renderPlaintext();
  }
};
const NcRichText = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-9d3e4618"]]);
const _sfc_main$1$1 = {
  name: "NcUserBubbleDiv"
};
function _sfc_render$1$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "trigger")
  ]);
}
const NcUserBubbleDiv = /* @__PURE__ */ _export_sfc(_sfc_main$1$1, [["render", _sfc_render$1$1]]);
const _sfc_main$d = {
  name: "NcUserBubble",
  components: {
    NcAvatar,
    NcPopover,
    NcUserBubbleDiv
  },
  props: {
    /**
     * Override generated avatar, can be an url or an icon class
     */
    avatarImage: {
      type: String,
      default: void 0
    },
    /**
     * Provide the user id if this is a user
     */
    user: {
      type: String,
      default: void 0
    },
    /**
     * Displayed label
     */
    displayName: {
      type: String,
      default: void 0
    },
    /**
     * Whether or not to display the user-status
     */
    showUserStatus: {
      type: Boolean,
      default: false
    },
    /**
     * Define the whole bubble as a link
     */
    url: {
      type: String,
      default: void 0,
      validator: (url) => {
        try {
          url = new URL(url, url?.startsWith?.("/") ? window.location.href : void 0);
          return !!url;
        } catch (error) {
          return false;
        }
      }
    },
    /**
     * Use bubble as a router-link for in-app navigation
     */
    to: {
      type: [String, Object],
      default: void 0
    },
    /**
     * Default popover state. Requires the UserBubble
     * to have some content to render inside the popover
     */
    open: {
      type: Boolean,
      default: false
    },
    /**
     * Use the primary colour
     */
    primary: {
      type: Boolean,
      default: false
    },
    /**
     * This is the height of the component
     */
    size: {
      type: Number,
      default: 20
    },
    /**
     * This is the margin of the avatar (size - margin = avatar size)
     */
    margin: {
      type: Number,
      default: 2
    }
  },
  emits: [
    "click",
    "update:open"
  ],
  computed: {
    /**
     * Is the provided avatar url valid or not
     *
     * @return {boolean}
     */
    isAvatarUrl() {
      if (!this.avatarImage) {
        return false;
      }
      try {
        const url = new URL(this.avatarImage);
        return !!url;
      } catch (error) {
        return false;
      }
    },
    /**
     * Do we have a custom avatar or not
     *
     * @return {boolean}
     */
    isCustomAvatar() {
      return !!this.avatarImage;
    },
    hasUrl() {
      return this.url && this.url.trim() !== "";
    },
    isLinkComponent() {
      if (this.hasUrl) {
        return "a";
      } else if (this.to) {
        return RouterLink;
      } else {
        return "div";
      }
    },
    styles() {
      return {
        content: {
          height: this.size + "px",
          lineHeight: this.size + "px",
          borderRadius: this.size / 2 + "px"
        },
        avatar: {
          marginInlineStart: this.margin + "px"
        }
      };
    }
  },
  mounted() {
    if (!this.displayName && !this.user) {
      warn("[NcUserBubble] At least `displayName` or `user` property should be set.");
    }
  },
  methods: {
    onOpenChange(state) {
      this.$emit("update:open", state);
    },
    /**
     * Catch and forward click event to parent
     *
     * @param {Event} event the click event
     */
    onClick(event) {
      this.$emit("click", event);
    }
  }
};
const _hoisted_1$8 = { class: "user-bubble__name" };
const _hoisted_2$4 = {
  key: 0,
  class: "user-bubble__secondary"
};
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_NcAvatar = resolveComponent("NcAvatar");
  return openBlock(), createBlock(resolveDynamicComponent(!!_ctx.$slots.default ? "NcPopover" : "NcUserBubbleDiv"), {
    trigger: "hover focus",
    shown: $props.open,
    class: "user-bubble__wrapper",
    "onUpdate:open": $options.onOpenChange
  }, {
    trigger: withCtx(({ attrs }) => [
      (openBlock(), createBlock(resolveDynamicComponent($options.isLinkComponent), mergeProps({
        class: ["user-bubble__content", { "user-bubble__content--primary": $props.primary }],
        style: $options.styles.content,
        to: $props.to,
        href: $options.hasUrl ? $props.url : null
      }, attrs, { onClick: $options.onClick }), {
        default: withCtx(() => [
          createVNode(_component_NcAvatar, {
            url: $options.isCustomAvatar && $options.isAvatarUrl ? $props.avatarImage : void 0,
            "icon-class": $options.isCustomAvatar && !$options.isAvatarUrl ? $props.avatarImage : void 0,
            user: $props.user,
            "display-name": $props.displayName,
            size: $props.size - $props.margin * 2,
            style: normalizeStyle($options.styles.avatar),
            "disable-tooltip": true,
            "disable-menu": true,
            "show-user-status": $props.showUserStatus,
            class: "user-bubble__avatar"
          }, null, 8, ["url", "icon-class", "user", "display-name", "size", "style", "show-user-status"]),
          createBaseVNode("span", _hoisted_1$8, toDisplayString($props.displayName || $props.user), 1),
          !!_ctx.$slots.name ? (openBlock(), createElementBlock("span", _hoisted_2$4, [
            renderSlot(_ctx.$slots, "name", {}, void 0, true)
          ])) : createCommentVNode("", true)
        ]),
        _: 2
      }, 1040, ["style", "to", "href", "class", "onClick"]))
    ]),
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ]),
    _: 3
  }, 40, ["shown", "onUpdate:open"]);
}
const NcUserBubble = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d], ["__scopeId", "data-v-6e4010a7"]]);
const _sfc_main$c = {
  name: "AddressBookRichArgument",
  props: {
    name: {
      type: String,
      required: true
    }
  }
};
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "strong",
    null,
    toDisplayString($props.name),
    1
    /* TEXT */
  );
}
const AddressBookRichArgument = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["render", _sfc_render$c], ["__file", "/var/www/html/custom_apps/extended_activity/src/components/richArgumentsTypes/AddressBookRichArgument.vue"]]);
const _sfc_main$b = {
  name: "CalendarEventRichArgument",
  props: {
    name: {
      type: String,
      required: true
    },
    title: {
      type: String,
      required: true
    },
    link: {
      type: String,
      required: true
    }
  }
};
const _hoisted_1$7 = ["href", "title"];
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("a", {
    href: $props.link,
    title: $props.title
  }, [
    createBaseVNode(
      "strong",
      null,
      toDisplayString($props.name),
      1
      /* TEXT */
    )
  ], 8, _hoisted_1$7);
}
const CalendarEventRichArgument = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["render", _sfc_render$b], ["__file", "/var/www/html/custom_apps/extended_activity/src/components/richArgumentsTypes/CalendarEventRichArgument.vue"]]);
const _sfc_main$a = {
  name: "CalendarRichArgument",
  props: {
    name: {
      type: String,
      required: true
    }
  }
};
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "strong",
    null,
    toDisplayString($props.name),
    1
    /* TEXT */
  );
}
const CalendarRichArgument = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["render", _sfc_render$a], ["__file", "/var/www/html/custom_apps/extended_activity/src/components/richArgumentsTypes/CalendarRichArgument.vue"]]);
const _sfc_main$9 = {
  name: "EmailRichArgument",
  props: {
    id: {
      type: String,
      required: true
    },
    name: {
      type: String,
      required: true
    }
  }
};
const _hoisted_1$6 = ["href"];
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("a", {
    href: `mailto:${$props.id}`
  }, toDisplayString($props.name), 9, _hoisted_1$6);
}
const EmailRichArgument = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["render", _sfc_render$9], ["__file", "/var/www/html/custom_apps/extended_activity/src/components/richArgumentsTypes/EmailRichArgument.vue"]]);
const _sfc_main$8 = {
  name: "FileRichArgument",
  props: {
    name: {
      type: String,
      required: true
    },
    path: {
      type: String,
      required: true
    },
    link: {
      type: String,
      required: true
    }
  },
  computed: {
    /**
     * Return true if the path is the root folder.
     */
    isRoot() {
      return isSamePath(this.path, "");
    },
    /**
     * Return true if the parent path is the root folder.
     */
    parentPathIsRoot() {
      return isSamePath(this.parentFolder, "/");
    },
    /**
     * Remove the file name from the path.
     */
    parentFolder() {
      return dirname$1(this.name);
    }
  },
  methods: {
    t: translate
  }
};
const _hoisted_1$5 = { class: "rich-text-file" };
const _hoisted_2$3 = ["href"];
const _hoisted_3$3 = ["title", "aria-label", "href"];
const _hoisted_4$2 = ["title"];
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", _hoisted_1$5, [
    !$options.isRoot && $options.parentPathIsRoot ? (openBlock(), createElementBlock("a", {
      key: 0,
      href: $props.link
    }, toDisplayString($props.name), 9, _hoisted_2$3)) : createCommentVNode("v-if", true),
    !$options.isRoot && !$options.parentPathIsRoot ? (openBlock(), createElementBlock("a", {
      key: 1,
      title: $options.t("activity", "in {path}", { path: $options.parentFolder }),
      "aria-label": $options.t("activity", "in {path}", { path: $options.parentFolder }),
      href: $props.link
    }, toDisplayString($props.name), 9, _hoisted_3$3)) : createCommentVNode("v-if", true),
    $options.isRoot ? (openBlock(), createElementBlock("span", {
      key: 2,
      title: $options.t("activity", "Home"),
      "aria-label": "t('activity', 'Home')",
      class: "icon-home"
    }, null, 8, _hoisted_4$2)) : createCommentVNode("v-if", true)
  ]);
}
const FileRichArgument = /* @__PURE__ */ _export_sfc$1(_sfc_main$8, [["render", _sfc_render$8], ["__scopeId", "data-v-1e310300"], ["__file", "/var/www/html/custom_apps/extended_activity/src/components/richArgumentsTypes/FileRichArgument.vue"]]);
const _sfc_main$7 = {
  name: "OpenGraphRichArgument",
  props: {
    id: {
      type: String,
      required: true
    },
    name: {
      type: String,
      required: true
    },
    description: {
      type: String,
      required: true
    },
    thumb: {
      type: String,
      default: ""
    },
    link: {
      type: String,
      required: true
    },
    website: {
      type: String,
      required: true
    }
  },
  computed: {
    thumbIsDefined() {
      return this.thumb !== "";
    }
  }
};
const _hoisted_1$4 = ["href"];
const _hoisted_2$2 = ["id"];
const _hoisted_3$2 = { class: "opengraph-website" };
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("a", { href: $props.link }, [
    createBaseVNode("div", {
      id: `opengraph-${$props.id}`,
      class: "opengraph"
    }, [
      $options.thumbIsDefined ? (openBlock(), createElementBlock(
        "div",
        {
          key: 0,
          class: "opengraph-thumb",
          style: normalizeStyle(`background-image: url('${$props.thumb}')`)
        },
        null,
        4
        /* STYLE */
      )) : createCommentVNode("v-if", true),
      createBaseVNode(
        "div",
        {
          class: normalizeClass(["opengraph-name", { "opengraph-with-thumb": $options.thumbIsDefined }])
        },
        toDisplayString($props.name),
        3
        /* TEXT, CLASS */
      ),
      createBaseVNode(
        "div",
        {
          class: normalizeClass(["opengraph-description", { "opengraph-with-thumb": $options.thumbIsDefined }])
        },
        toDisplayString($props.description),
        3
        /* TEXT, CLASS */
      ),
      createBaseVNode(
        "span",
        _hoisted_3$2,
        toDisplayString($props.website),
        1
        /* TEXT */
      )
    ], 8, _hoisted_2$2)
  ], 8, _hoisted_1$4);
}
const OpenGraphRichArgument = /* @__PURE__ */ _export_sfc$1(_sfc_main$7, [["render", _sfc_render$7], ["__file", "/var/www/html/custom_apps/extended_activity/src/components/richArgumentsTypes/OpenGraphRichArgument.vue"]]);
const _sfc_main$6 = {
  name: "SystemTagRichArgument",
  props: {
    name: {
      type: String,
      required: true
    }
  }
};
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "strong",
    null,
    toDisplayString($props.name),
    1
    /* TEXT */
  );
}
const SystemTagRichArgument = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["render", _sfc_render$6], ["__scopeId", "data-v-68cdf5ca"], ["__file", "/var/www/html/custom_apps/extended_activity/src/components/richArgumentsTypes/SystemTagRichArgument.vue"]]);
const _sfc_main$5 = {
  name: "UnknownArgument",
  props: {
    name: {
      type: String,
      required: true
    }
  }
};
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "strong",
    null,
    toDisplayString($props.name),
    1
    /* TEXT */
  );
}
const UnknownArgument = /* @__PURE__ */ _export_sfc$1(_sfc_main$5, [["render", _sfc_render$5], ["__file", "/var/www/html/custom_apps/extended_activity/src/components/richArgumentsTypes/UnknownArgument.vue"]]);
const _sfc_main$4 = {
  name: "UnknownLinkArgument",
  props: {
    name: {
      type: String,
      required: true
    },
    link: {
      type: String,
      required: true
    }
  }
};
const _hoisted_1$3 = ["href"];
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("a", { href: $props.link }, toDisplayString($props.name), 9, _hoisted_1$3);
}
const UnknownLinkArgument = /* @__PURE__ */ _export_sfc$1(_sfc_main$4, [["render", _sfc_render$4], ["__file", "/var/www/html/custom_apps/extended_activity/src/components/richArgumentsTypes/UnknownLinkArgument.vue"]]);
function mapRichObjectsToRichArguments(richObjects) {
  const args = {};
  for (const richObjectName in richObjects) {
    args[richObjectName] = mapRichObjectToRichArgument(richObjects[richObjectName]);
  }
  return args;
}
function mapRichObjectToRichArgument(richObject) {
  switch (richObject.type) {
    case "file":
      return {
        component: FileRichArgument,
        props: richObject
      };
    case "user":
      if (richObject.server) {
        return {
          component: NcUserBubble,
          props: {
            avatarImage: "icon-user",
            displayName: richObject.name,
            user: richObject.id,
            url: richObject.link
          }
        };
      }
      return {
        component: NcUserBubble,
        props: { displayName: richObject.name, user: richObject.id, url: richObject.link }
      };
    case "group":
      return {
        component: NcUserBubble,
        props: {
          avatarImage: "icon-group",
          displayName: richObject.name,
          primary: true
        }
      };
    case "email":
      return {
        component: EmailRichArgument,
        props: richObject
      };
    case "systemtag":
      return {
        component: SystemTagRichArgument,
        props: richObject
      };
    case "opengraph":
      return {
        component: OpenGraphRichArgument,
        props: richObject
      };
    case "calendar":
      return {
        component: CalendarRichArgument,
        props: richObject
      };
    case "calendar-event":
      return {
        component: CalendarEventRichArgument,
        props: richObject
      };
    case "addressbook":
      return {
        component: AddressBookRichArgument,
        props: richObject
      };
    default:
      if (richObject.link) {
        return {
          component: UnknownLinkArgument,
          props: richObject
        };
      }
      return {
        component: UnknownArgument,
        props: richObject
      };
  }
}
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "CommentActivity",
  props: {
    activity: { type: Object, required: true },
    showPreviews: { type: Boolean, required: true }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const authorId = computed(() => props.activity.subjectRichObjects?.author?.id ?? props.activity.user);
    const authorDisplayName = computed(() => {
      if (props.activity.user === getCurrentUser()?.uid) {
        return translate("activity", "You commented");
      }
      return props.activity.subjectRichObjects?.author?.name ?? props.activity.user;
    });
    const timestamp = computed(() => props.activity.timestamp);
    const messageText = computed(() => props.activity.messageRichTemplate || props.activity.message || translate("activity", "Message deleted by author"));
    const subjectText = computed(() => props.activity.subjectRichTemplate || props.activity.subject);
    const subjectArguments = computed(() => mapRichObjectsToRichArguments(props.activity.subjectRichObjects));
    const __returned__ = { props, authorId, authorDisplayName, timestamp, messageText, subjectText, subjectArguments, get NcAvatar() {
      return NcAvatar;
    }, get NcDateTime() {
      return _sfc_main$i;
    }, get NcRichText() {
      return NcRichText;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$2 = { class: "activity-entry comments-activity" };
const _hoisted_2$1 = { class: "comments-activity__content" };
const _hoisted_3$1 = {
  key: 1,
  class: "comments-activity__title"
};
const _hoisted_4$1 = { class: "hidden-visually" };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", _hoisted_1$2, [
    createVNode($setup["NcAvatar"], {
      class: "comments-activity__icon",
      "disable-menu": false,
      user: $setup.authorId
    }, null, 8, ["user"]),
    createBaseVNode("div", _hoisted_2$1, [
      $props.showPreviews ? (openBlock(), createBlock($setup["NcRichText"], {
        key: 0,
        class: "comments-activity__title",
        text: $setup.subjectText,
        arguments: $setup.subjectArguments
      }, null, 8, ["text", "arguments"])) : (openBlock(), createElementBlock(
        "div",
        _hoisted_3$1,
        toDisplayString($setup.authorDisplayName),
        1
        /* TEXT */
      )),
      createVNode($setup["NcRichText"], {
        class: "comments-activity__subline",
        text: $setup.messageText,
        arguments: $props.activity.messageRichObjects
      }, null, 8, ["text", "arguments"])
    ]),
    createBaseVNode(
      "span",
      _hoisted_4$1,
      toDisplayString($props.activity.formattedDate),
      1
      /* TEXT */
    ),
    createVNode($setup["NcDateTime"], {
      class: "comments-activity__date",
      "data-testid": "activity-date",
      timestamp: $setup.timestamp,
      "ignore-seconds": true
    }, null, 8, ["timestamp"])
  ]);
}
const CommentActivity = /* @__PURE__ */ _export_sfc$1(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-a396141a"], ["__file", "/var/www/html/custom_apps/extended_activity/src/components/activities/CommentActivity.vue"]]);
class ActivityModel {
  _activity;
  /**
   * Create the activity object
   *
   * @param rawActivity the activity object from the ocs response
   */
  constructor(rawActivity) {
    if (typeof rawActivity !== "object") {
      throw new Error("Received activity data is not an object.");
    }
    if (typeof rawActivity.activity_id !== "number") {
      throw new Error("The activity_id argument is not a number");
    }
    if (typeof rawActivity.type !== "string" || rawActivity.type.trim() === "") {
      throw new Error("The type argument is not a valid string");
    }
    if (typeof rawActivity.subject !== "string" || rawActivity.subject.trim() === "") {
      throw new Error("The subject argument is not a valid string");
    }
    if (typeof rawActivity.icon !== "string" || rawActivity.icon.trim() === "") {
      throw new Error("The icon argument is not a valid string");
    }
    if (typeof rawActivity.datetime !== "string" || rawActivity.datetime.trim() === "") {
      throw new Error("The datetime argument is not a valid string");
    }
    this._activity = rawActivity;
  }
  /**
   * get the activity id
   */
  get id() {
    return this._activity.activity_id;
  }
  /**
   * Get the app causing the activity
   */
  get app() {
    return this._activity.app;
  }
  /**
   * Get the activity type
   */
  get type() {
    return this._activity.type;
  }
  /**
   * Get the user ID of the user causing the activity or affected by the activity
   */
  get user() {
    return this._activity.user;
  }
  /**
   * Get the activity subject
   */
  get subject() {
    return this._activity.subject;
  }
  /**
   * Get the activity subject_rich template
   */
  get subjectRichTemplate() {
    return this._activity.subject_rich[0];
  }
  /**
   * Get the activity subject_rich objects
   */
  get subjectRichObjects() {
    if (Array.isArray(this._activity.subject_rich[1])) {
      return {};
    }
    return this._activity.subject_rich[1];
  }
  /**
   * Get the activity message
   */
  get message() {
    return this._activity.message;
  }
  /**
   * Get the activity message_rich template
   */
  get messageRichTemplate() {
    return this._activity.message_rich[0];
  }
  /**
   * Get the activity message_rich objects
   */
  get messageRichObjects() {
    if (!Array.isArray(this._activity.message_rich[1])) {
      return {};
    }
    return this._activity.message_rich[1];
  }
  /**
   * Get the object_type
   */
  get objectType() {
    return this._activity.object_type;
  }
  /**
   * Get the activity object_id
   */
  get objectId() {
    return this._activity.object_id;
  }
  /**
   * Get the activity object_name
   */
  get objectName() {
    return this._activity.object_name;
  }
  /**
   * Get the activity link
   */
  get link() {
    return this._activity.link;
  }
  /**
   * Get the activity icon
   */
  get icon() {
    return this._activity.icon;
  }
  /**
   * Get the activity datetime
   */
  get datetime() {
    return this._activity.datetime;
  }
  /**
   * Get the activity formatted date from the current date
   */
  get dateFromNow() {
    return moment(this._activity.datetime).fromNow();
  }
  /**
   * Get the activity formatted datetime
   */
  get formattedDate() {
    return moment(this._activity.datetime).format("LLL");
  }
  /**
   * Get the activity timestamp
   */
  get timestamp() {
    return moment(this._activity.datetime).valueOf();
  }
  /**
   * Get previews of affected files
   */
  get previews() {
    return this._activity.previews ?? [];
  }
}
const _sfc_main$2 = defineComponent({
  name: "GenericActivity",
  components: {
    NcAvatar,
    NcDateTime: _sfc_main$i,
    NcRichText
  },
  props: {
    /**
     * The activity to render.
     */
    activity: {
      type: ActivityModel,
      required: true
    },
    /**
     * Whether to show previews
     */
    showPreviews: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    /**
     * The timestamp of the activity as JS timestamp
     */
    timestamp() {
      return this.activity.timestamp;
    },
    /**
     * @return The activity's messageRichTemplate. Fallback to message if messageRichTemplate does not exists
     */
    messageText() {
      return this.activity.messageRichTemplate || this.activity.message;
    },
    /**
     * @return A map of rich arguments with a Component to build them.
     */
    messageArguments() {
      return mapRichObjectsToRichArguments(this.activity.messageRichObjects);
    },
    /**
     * @return The activity's subjectRichTemplate. Fallback to subject if subjectRichTemplate does not exists
     */
    subjectText() {
      return this.activity.subjectRichTemplate || this.activity.subject;
    },
    /**
     * @return A map of rich arguments with a Component to build them.
     */
    subjectArguments() {
      return mapRichObjectsToRichArguments(this.activity.subjectRichObjects);
    },
    applyMonochromeIconColor() {
      const monochromeIcon = this.activity.type !== "file_created" && this.activity.type !== "file_deleted" && this.activity.type !== "favorite" && !this.activity.icon.endsWith("-color.svg");
      if (monochromeIcon) {
        return "monochrome";
      }
      return "";
    }
  },
  methods: {
    t: translate,
    /**
     * Handle clicking a preview
     * Check if viewer is available and can open the file, if not navigate to it
     *
     * @param event The click event
     * @param preview The preview to open
     */
    handlePreviewClick(event, preview) {
      if (preview.filePath && window?.OCA?.Viewer?.open !== void 0 && window.OCA.Viewer.mimetypes.includes(preview.mimeType)) {
        try {
          window.OCA.Viewer.open({ path: preview.filePath.replace(/^\/[^/]+\/files/, "") });
          event.preventDefault();
          event.stopPropagation();
        } catch (error) {
          logger$1.debug(error);
        }
      }
    }
  }
});
const _hoisted_1$1 = { class: "activity-entry" };
const _hoisted_2 = { class: "activity-entry__content" };
const _hoisted_3 = { class: "hidden-visually" };
const _hoisted_4 = {
  key: 0,
  class: "activity-entry__preview-wrapper"
};
const _hoisted_5 = ["src", "alt"];
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_NcAvatar = resolveComponent("NcAvatar");
  const _component_NcRichText = resolveComponent("NcRichText");
  const _component_NcDateTime = resolveComponent("NcDateTime");
  return openBlock(), createElementBlock("li", _hoisted_1$1, [
    createVNode(_component_NcAvatar, {
      class: normalizeClass([_ctx.applyMonochromeIconColor, "activity-entry__icon", "activity-icon", "avatardiv--unknown"]),
      "disable-menu": true,
      "disable-tooltip": true,
      url: _ctx.activity.icon,
      size: 20
    }, null, 8, ["class", "url"]),
    createBaseVNode("div", _hoisted_2, [
      createVNode(_component_NcRichText, {
        class: "activity-entry__content__subject",
        text: _ctx.subjectText,
        arguments: _ctx.subjectArguments
      }, null, 8, ["text", "arguments"]),
      createVNode(_component_NcRichText, {
        class: "activity-entry__content__message",
        text: _ctx.messageText,
        arguments: _ctx.messageArguments
      }, null, 8, ["text", "arguments"])
    ]),
    createBaseVNode(
      "span",
      _hoisted_3,
      toDisplayString(_ctx.activity.formattedDate),
      1
      /* TEXT */
    ),
    createVNode(_component_NcDateTime, {
      class: "activity-entry__date",
      timestamp: _ctx.timestamp,
      "ignore-seconds": true,
      "data-testid": "activity-date"
    }, null, 8, ["timestamp"]),
    _ctx.showPreviews ? (openBlock(), createElementBlock("ul", _hoisted_4, [
      (openBlock(true), createElementBlock(
        Fragment,
        null,
        renderList(_ctx.activity.previews, (preview, index2) => {
          return openBlock(), createElementBlock("li", {
            key: preview.fileId ?? `preview-${index2}`
          }, [
            (openBlock(), createBlock(resolveDynamicComponent(preview.link ? "a" : "span"), {
              class: "activity-entry__preview",
              href: preview.link,
              onClick: ($event) => _ctx.handlePreviewClick($event, preview)
            }, {
              default: withCtx(() => [
                createBaseVNode("img", {
                  class: normalizeClass(["activity-entry__preview-image", {
                    "activity-entry__preview-mimetype": preview.isMimeTypeIcon
                  }]),
                  src: preview.source,
                  alt: preview.link ? _ctx.t("activity", "Open {filename}", { filename: preview.filename }) : ""
                }, null, 10, _hoisted_5)
              ]),
              _: 2
              /* DYNAMIC */
            }, 1032, ["href", "onClick"]))
          ]);
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ])) : createCommentVNode("v-if", true)
  ]);
}
const GenericActivity = /* @__PURE__ */ _export_sfc$1(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-3de9cd45"], ["__file", "/var/www/html/custom_apps/extended_activity/src/components/activities/GenericActivity.vue"]]);
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "PluginActivity",
  props: {
    activity: { type: Object, required: true }
  },
  emits: ["reload"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const props = __props;
    const emit = __emit;
    const activityMount = ref();
    onMounted(() => props.activity.mount(activityMount.value, { context: getCurrentInstance()?.proxy, reload: () => emit("reload") }));
    onUnmounted(() => props.activity.unmount());
    const __returned__ = { props, emit, activityMount };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1 = { ref: "activityMount" };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "li",
    _hoisted_1,
    null,
    512
    /* NEED_PATCH */
  );
}
const PluginActivity = /* @__PURE__ */ _export_sfc$1(_sfc_main$1, [["render", _sfc_render$1], ["__file", "/var/www/html/custom_apps/extended_activity/src/components/activities/PluginActivity.vue"]]);
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "ActivityComponent",
  props: {
    activity: { type: Object, required: true },
    showPreviews: { type: Boolean, required: true }
  },
  emits: ["reload"],
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const activityOptions = computed(() => props);
    const activityComponent = computed(() => {
      if (!(props.activity instanceof ActivityModel)) {
        logger$1.warn("Activity is not an instance of ActivityModel", { activity: props.activity });
        return PluginActivity;
      }
      switch (props.activity.type) {
        case "comments":
          return CommentActivity;
        default:
          return GenericActivity;
      }
    });
    const __returned__ = { props, activityOptions, activityComponent };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    resolveDynamicComponent($setup.activityComponent),
    mergeProps($setup.activityOptions, {
      onReload: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("reload"))
    }),
    null,
    16
    /* FULL_PROPS */
  );
}
const ActivityComponent = /* @__PURE__ */ _export_sfc$1(_sfc_main, [["render", _sfc_render], ["__file", "/var/www/html/custom_apps/extended_activity/src/components/ActivityComponent.vue"]]);
export {
  ActivityComponent as A,
  NcIconSvgWrapper as N,
  moment as a,
  ActivityModel as b,
  NcEmptyContent as c,
  NcActionButton as d,
  NcInputField as e,
  convert$1 as f,
  convertElement as g,
  logger as l,
  mdiArrowRight as m,
  ok$2 as o,
  visit as v
};
//# sourceMappingURL=ActivityComponent-Dd9WZpZW.chunk.mjs.map
